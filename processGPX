#! /usr/bin/env perl -w
use strict;
use Getopt::Long;
use Geo::Gpx;
use XML::Descent;    # for extension tags
use POSIX qw(floor ceil);
use Date::Parse;
use Pod::Usage;

# version 0.33: add start and finishing circuits
# version 0.34: add circle fitting
# version 0.35: add straight line fitting
# version 0.36: shifted turn-arounds to after min radius
# version 0.37: autospacing considers minRadius
# version 0.38: fixed bug in speed model
# version 0.39: add named segments, fixed spline smoothing
# version 0.40: adjust default margin, smoothing after minRadius
# version 0.41: improvements to snapping, adds splitting, single track, outAndBack shortcuts, auto-straighten
# version 0.42: fixed error in autonamed segments
# version 0.43: fixed -segment option
# version 0.44: fixed -join
# version 0.45: selectiveSmooth, selectiveSmoothZ, fixed append + prepend bug, fixed transition bug, retuned z-autosmoothing
# version 0.46: efficiency improvements in calling smoothing.
# version 0.47: added gradient smoothing w/ corner effect.  Simplified -zShift, -zScale, added -zScaleRef.
#               added aliases for start/finish circuit distances.
# version 0.48: added arc fitting, loopLeft, loopRight.  Added loopLeft and loopRight options.  Improved splines
# version 0.49: some clean-up, bug fixes, reduced smoothAngle from 20 to 15.  Added -selectiveLaneShift, -repeat, -laneShiftTransition
# version 0.50: added -deleteRange; fixed -join problem not merging segments
# version 0.51: added circuitFromPosition, circuitToPosition
# version 0.52: switch from RGT to Biketerra, moved nonstandard tokens to extensions.  Changed "direction" field to "heading",
#               added "-autoLap" and "-autoLoop".  added -cornerCrop, -minCornerCropDegs, and -maxCornerCropDegs
#               Also added -saveCrossingsCSV (previously it was implied)
# version 0.53 bug fixes: straighten, added simplify, changed interpolateCorner to Catmull-Rom spline; latlng2dxdy uses spherical geometry
#               boolean operations now negateable.  Added -shiftX and -shiftY.
#               fixed problem with interpolatePoint when lng jumps 360 deg
#               fixed -cornerCrop handing of loop courses

my $version = "0.53";             # make sure this matches pod value

my $number_regexp =
  '[+-]?\d*(?:\d|(?:\.\d+))(?:[eE][-+]?\d+)?';

$0 =~ s(.*/)();

# a function which transitions from 1 (x = -1) to 1/2 (x = 0) to 0 ( x = 1 )
my $pi2 = atan2(1, 0);
sub transition {
  my $x = shift;
  return (
          ($x < -1) ? 1 :
          ($x > 1) ? 0 :
          (1 - sin($x * $pi2)) / 2
         );
}

# set the suffix of a filename
sub setFileNameSuffix {
  my $f = shift;
  my $suffix = shift;
  return if ($f eq "-");
  (my $f2 = $f) =~ s/\.(\w\w\w?\w?)$/$suffix/;
  $f2 .= $suffix if ($f2 eq $f);
  return($f2);
}

# find distance between lat, lng points
my $pi          = atan2(0, -1);
my $twopi       = 2 * $pi;
my $ln2         = log(2);
my $sqrt2       = sqrt(2);
my $sqrt2pi     = sqrt(2 * $pi);
my $rEarth      = 20037392 / $pi;
my $deg2rad     = $pi / 180;
my $lat2y       = $rEarth * $deg2rad;

sub reduceAngle {
  my $theta = shift;
  $theta -= $twopi * floor(0.5 + $theta / $twopi);
  return $theta;
}

sub averageAngles {
  my $d1 = shift;
  my $d2 = shift;
  return reduceAngle( $d1 + 0.5 * reduceAngle($d2 - $d1) );
}

sub deltaAngle {
  my $d1 = shift;
  my $d2 = shift;
  return reduceAngle( $d2 - $d1 );
}

sub latlngDistance {
  my $p1 = shift;
  my $p2 = shift;
  my $lat1 = $deg2rad * $p1->{lat};
  my $lat2 = $deg2rad * $p2->{lat};
  my $lng1 = $deg2rad * $p1->{lon};
  my $lng2 = $deg2rad * $p2->{lon};
  my $dlng = $lng2 - $lng1;
  my $dlat = $lat2 - $lat1;
  my $a = sin($dlat / 2) ** 2 + cos($lat1) * cos($lat2) * sin($dlng / 2) ** 2;
  my $d = 2 * $rEarth * atan2( sqrt($a), sqrt(1-$a) );
  return $d;
}

sub deltaxy {
  my $p1 = shift;
  my $p2 = shift;
  return( [$p2->[0] - $p1->[0], $p2->[1] - $p1->[1]] );
}

sub pointsAreClose {
  my $p1 = shift;
  my $p2 = shift;

  my $sMax = shift // 0.05;
  my $zMax = shift // 1;
  my $dz = ((defined $p1->{ele}) && (defined $p2->{ele})) ? ($p2->{ele} - $p1->{ele}) : 0;
  return (abs($dz) < $zMax && (latlngDistance($p1, $p2) < $sMax));
}

sub latlngDotProduct {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $p4 = shift;
  my ($dx12, $dy12) = latlng2dxdy($p1, $p2);
  my ($dx34, $dy34) = latlng2dxdy($p3, $p4);
  my $denom = sqrt(($dx12 ** 2 + $dy12 ** 2) * ($dx34 ** 2 + $dy34 ** 2));
  return ( ($denom == 0) ? undef : ($dx12 * $dx34 + $dy12 * $dy34) / $denom );
}

sub crossProduct {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $p4 = shift;
  my $dx12 = $p2->[0] - $p1->[0];
  my $dx34 = $p4->[0] - $p3->[0];
  my $dy12 = $p2->[1] - $p1->[1];
  my $dy34 = $p4->[1] - $p3->[1];
  my $denom = sqrt(($dx12 ** 2 + $dy12 ** 2) * ($dx34 ** 2 + $dy34 ** 2));
  return ( ($denom == 0) ? undef : ($dx12 * $dy34 - $dx34 * $dy12) / $denom );
}

sub latlngCrossProduct {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $p4 = shift;
  my ($dx12, $dy12) = latlng2dxdy($p1, $p2);
  my ($dx34, $dy34) = latlng2dxdy($p3, $p4);
  my $denom = sqrt(($dx12 ** 2 + $dy12 ** 2) * ($dx34 ** 2 + $dy34 ** 2));
  return ( ($denom == 0) ? undef : ($dx12 * $dy34 - $dx34 * $dy12) / $denom );
}

# vector cross product sign:
# right turn => 1
# left turn => -1
sub turnDirection {
  my $v1 = shift;
  my $v2 = shift;
  my $v3 = shift;
  my $dv1 = deltaxy($v1, $v2);
  my $dv2 = deltaxy($v2, $v3);
  return ($dv1->[1] * $dv2->[0] <=> $dv1->[0] * $dv2->[1]);
}

# given 3 points, return the subtended angle
sub latlngAngle {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $s = latlngCrossProduct ($p1, $p2, $p2, $p3);
  my $c = latlngDotProduct ($p1, $p2, $p2, $p3);
  my $a = ((defined $s) && (defined $c)) ? reduceAngle(atan2($s, $c)) : undef;
  return $a;
}

# direction from p1 to p2
# 0 deg = eastward
# 90 deg: northward
# 180 deg: westward
# 270 deg: southward
sub latlngDirection {
  my $p1 = shift;
  my $p2 = shift;
  my ($dx, $dy) = latlng2dxdy($p1, $p2);
  return atan2($dy,$dx);
}

# the direction of a point p2, which is the average
# of the directions of the adjacent sgements
sub pointDirection {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  return averageAngles(latlngDirection($p1, $p2), latlngDirection($p2, $p3));
}

#
# shift a point by a given distance in a given direction
#
sub shiftPoint {
  my %var = @_;
  my $point = $var{point};
  my $direction = $var{direction};
  my $distance = $var{distance};

  die("ERROR: shiftPoint() called without valid direction.\n")
    unless (defined $direction);
  die("ERROR: shiftPoint() called without valid point distance.\n")
    unless (defined $distance);

  my $c = cos($direction);
  my $s = sin($direction);

  # lane shift, 90 degrees
  my $dx = $s * $distance;
  my $dy = -$c * $distance;
  my $dlng = $dx / ($lat2y * cos($deg2rad * $point->{lat}));
  my $dlat = $dy / $lat2y;
  my %pNew = %$point;
  $pNew{lon} += $dlng;
  $pNew{lat} += $dlat;
  return \%pNew;
}

#
# shift a vertex by a given distance in a given direction
# the vertex is the intercection of two lines, each of
# which are shifted
#
sub shiftVertex {
  my %var = @_;
  my $point = $var{point};
  my $directions = $var{directions};
  my $distance = $var{distance};

  my $c1 = cos($directions->[0]);
  my $s1 = sin($directions->[0]);
  my $c2 = cos($directions->[1]);
  my $s2 = sin($directions->[1]);

  # lane shift, 90 degrees
  my $denom = $c1 * $s2 - $c2 * $s1;
  my ($dx, $dy);
  if (abs($denom) < 0.001) {
    $dx =  ($s1 + $s2) * $distance / 2;
    $dy = -($c1 + $c2) * $distance / 2;
  } else {
    $dx = ($c1 - $c2) / $denom * $distance;
    $dy = ($s1 - $s2) / $denom * $distance;
  }
  my $dlng = $dx / ($lat2y * cos($deg2rad * $point->{lat}));
  my $dlat = $dy / $lat2y;
  my %pNew = %$point;
  $pNew{lon} += $dlng;
  $pNew{lat} += $dlat;
  return \%pNew;
}

# calculate a coordinate difference between points:
# uses formula for distance and heading between points on a sphere
sub latlng2dxdy {
  my $p1 = shift;
  my $p2 = shift;
  die("latlng2dxdy called with undefined point #1\n")
    unless (defined $p1);
  die("latlng2dxdy called with undefined point #2\n")
    unless (defined $p2);
  my $lat1 = $deg2rad * $p1->{lat};
  my $lat2 = $deg2rad * $p2->{lat};
  my $lng1 = $deg2rad * $p1->{lon};
  my $lng2 = $deg2rad * $p2->{lon};
  my $dlng = $lng2 - $lng1;

  my $u = cos($lat1) * sin($lat2) - sin($lat1) * cos($lat2) * cos($dlng);
  my $v = sin($dlng) * cos($lat2);
  my $uv = sqrt($u ** 2 + $v ** 2);
  my ($dx, $dy);
  if ($uv == 0) {
    $dx = 0;
    $dy = 0;
  } else {
    my $s = $u / $uv;
    my $c = $v / $uv;
    my $d = latlngDistance($p1, $p2);
    $dx = $d * $c;
    $dy = $d * $s;
  }
  return ($dx, $dy);
}

#
# for a range of points, interpolate the fields based on distance between
# the first and last point
# use distance field if present on internal points else calculate distance field
#


sub interpolateFields {
  my @points = @_;
  return unless (@points > 2);
  my $p1 = $points[0];
  my $p2 = $points[-1];

  # calculate distance: don't trust existing distance field
  my @ds = ( 0 );
  for my $i ( 1 .. $#points ) {
    push @ds, $ds[-1] + latlngDistance($points[$i - 1], $points[$i]);
  }

  for my $i ( 1 .. $#points ) {
    my $p = $points[$i];
    my $f = $ds[$i] / $ds[-1];
    for my $k ( keys %$p1 ) {
      next if ($k eq "lat" || $k eq "lon");
      if ((defined $p1->{$k}) && (defined $p2->{$k})) {
        if ($k eq "segment" ) {
          if ( $p1->{$k} eq $p2->{$k} ) {
            $p->{$k} = $p1->{$k};
          } else {
            $p->{$k} = 0;
          }
        } elsif (($p1->{$k} =~ /^$number_regexp$/o) && ($p2->{$k} =~ /^$number_regexp$/o)) {
          $p->{$k} = $p1->{$k} * (1 - $f) + $p2->{$k} * $f;
        } else {
          $p->{$k} = ($f < 0.5) ? $p1->{$k} : $p2->{$k};
        }
      }
    }
  }
}

#
# point linearly interpolated between p1 and p2, with f the
# fraction of the distance to p2
# note since deleting repeated points results in the second point of a pair being deleted,
# for non-numeric fields, I need to assume interpolated points are associated with the
# latter point
# for segments, I need to have the interpolated interval be a fresh segment
#
sub interpolatePoint {
  my $p1 = shift;
  my $p2 = shift;
  my $f = shift;
  # interpolate lat and lng using distances, not angles
  my ($dx, $dy) = latlng2dxdy($p1, $p2);
  my $p = addVectorToPoint($p1, [$dx * $f, $dy * $f]);
  # interpolate other random values
  for my $k ( keys %$p1 ) {
    next if ($k eq "lat" || $k eq "lon");
    if ((defined $p1->{$k}) && (defined $p2->{$k})) {
      if ($k eq "segment" ) {
        if ( $p1->{$k} eq $p2->{$k} ) {
          $p->{$k} = $p1->{$k};
        } else {
          $p->{$k} = 0;
        }
      } elsif (($p1->{$k} =~ /^$number_regexp$/o) && ($p2->{$k} =~ /^$number_regexp$/o)) {
        $p->{$k} = $p1->{$k} * (1 - $f) + $p2->{$k} * $f;
      } else {
        $p->{$k} = ($f < 0.5) ? $p1->{$k} : $p2->{$k};
      }
    }
  }
  return $p;
}

#
# return a new list of points and the index of a point at a given
# position.  The point is interpolated if necessary
#
sub pointAtPosition {
  my $s0     = shift;
  my $points = shift;
  my $isLoop = shift // 0;

  my @pNew = ();

  addDistanceField(points=> $points) unless (exists $points->[0]->{distance});

  # handling of open loop
  my $courseDistance = $points->[-1]->{distance};
  $courseDistance += latlngDistance( $points->[-1], $points->[0] ) if ($isLoop);
  return ($points, 0)     if (abs($s0 - $points->[0]->{distance}) < 0.001);
  return ($points, undef) if (($s0 < $points->[0]->{distance}) || ($s0 > $courseDistance));

  my $pointAdded = 0;
  my $pIndex;
  for ( my $i = 1 ; $i <= $#$points; $i ++ ) {
    push @pNew, $points->[$i - 1];
    if ( ($s0 > 0) && ($points->[$i]->{distance} >= $s0) && ($points->[$i - 1]->{distance} < $s0) ) {
      my $ds = $points->[$i]->{distance} - $points->[$i - 1]->{distance};
      my $f = ($s0 - $points->[$i - 1]->{distance}) / $ds;
      my $d1 = $f * $ds;
      my $d2 = (1 - $f) * $ds;
      if (($d1 < 0.01) && ($d1 < $ds / 2)) {
        $pIndex = $i - 1;
      } elsif (($d2 < 0.01) && ($d1 >= $ds / 2)) {
        $pIndex = $i;
      } else {
        push @pNew, interpolatePoint($points->[$i - 1], $points->[$i], $f);
        $pIndex = $#pNew;
      }
    }
    # add new point if necessary: only if we've not found the point yet
    if ( ($i == $#$points ) && (! $pointAdded) && (! (defined $pIndex)) ) {
      my %p = %{$points->[0]};
      $p{distance} = $courseDistance;
      push @{$points}, \%p;
      $pIndex = $#$points;
      $pointAdded ++;
    }
  }

  # add the last point unless it was added here for interpolation
  push @pNew, $points->[-1] unless ($pointAdded);

  # return
  return (\@pNew, $pIndex);
}

# for splines...
# Catmull-Rom spline
# f is the fraction between points 2 and 3
# f1 is the normalized distance from p1 to p2
# f4 is the normalized distance from p3 to p4
# they are provided as arguments to spare calculation
sub interpolateCorner {
  my ($p1, $p2, $p3, $p4, $f1, $f4, $f) = @_;
  my $a1 = interpolatePoint($p1, $p2, 1 + $f / $f1);
  my $a2 = interpolatePoint($p2, $p3, $f);
  my $a3 = interpolatePoint($p3, $p4, ($f - 1) / $f4);
  my $b1 = interpolatePoint($a1, $a2, ($f1 + $f) / ($f1 + 1));
  my $b2 = interpolatePoint($a2, $a3, $f / ($f4 + 1));
  my $px = interpolatePoint($b1, $b2, $f);
  return $px;
}

# given two segments, each with two points, return the normalized positions on
# the segments where the intersections occur
# this is used by the crossing code
# avoid near-parallel lines
# if they intersect, report the fractions of the intersection along the segments
# (2 values)
sub segmentIntercept {
  my $s12 = shift;
  my $s34 = shift;
  my ($p1, $p2) = @$s12;
  my ($p3, $p4) = @$s34;
  die("segmentIntercept called with undefined point #1\n")
    unless (defined $p1);
  die("segmentIntercept called with undefined point #2\n")
    unless (defined $p2);
  die("segmentIntercept called with undefined point #3\n")
    unless (defined $p3);
  die("segmentIntercept called with undefined point #4\n")
    unless (defined $p4);
  my ($x1, $y1) = (0, 0);
  my ($x2, $y2) = latlng2dxdy($p1, $p2);
  my ($x3, $y3) = latlng2dxdy($p1, $p3);
  my ($x4, $y4) = latlng2dxdy($p1, $p4);
  my ($dx12, $dy12) = ($x2, $y2);
  my ($dx34, $dy34) = latlng2dxdy($p3, $p4);

  my $denom = $dx34 * $dy12 - $dx12 * $dy34;
  my $a = ( ($dx12 ** 2 + $dy12 ** 2) * ($dx34 ** 2 + $dy34 ** 2) ) ** (1/2);

  # lines are parallel
  if (($a == 0) || (abs($denom) < 0.01 * $a)) {
    return ();
  }

  my $f12 = ($dx34 * ($y3 - $y1) - $dy34 * ($x3 - $x1)) / $denom;
  if (($f12 >= 0) && ($f12 < 1)) {
    my $x = $f12 * $x2 + (1 - $f12) * $x1;
    my $y = $f12 * $y2 + (1 - $f12) * $y1;
    my $f23 = ((abs ($x3 - $x4) > abs($y3 - $y4)) ? ($x - $x3) / ($x4 - $x3) : ($y - $y3) / ($y4 - $y3));
    if (($f23 >= 0) && ($f23 < 1)) {
      return ($f12, $f23);
    }
  }
  return ();
}

# add a vector to a point
# a single iteration will use the average cosine for the path rather than
# a starting cosine, just for maximal accuracy
# note there will be no elevation field for this point:
# that will need to be added somewhere else
sub addVectorToPoint {
  my $p = shift;
  my $v = shift;
  my ($dx, $dy) = @$v;
  my %p2;
  my $lon0 = $p->{lon};
  my $lat0 = $p->{lat};
  my $dlat = $dy / $lat2y;      # this is independent of latitude
  my $lat = $lat0 + $dlat;
  $lat -= 360 * floor( 0.5 + $lat / 360);

  die("ERROR -- attempted to cross beyond pole!\n")
    if (abs($lat) > 90);

  my $c = cos($deg2rad * ($lat0 + $dlat / 2));
  my $dlon = $dx / $c / $lat2y;
  my $lon = $lon0 + $dlon;
  $lon -= 360 * floor( 0.5 + $lon / 360);
  $p2{lat} = $lat;
  $p2{lon} = $lon;
  return \%p2;
}

# return points between p2 and p3 using a spline
sub splineInterpolation {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $p4 = shift;
  my $dd = shift // ($pi / 16); # minimum angle for spline

  # calculate number of points based on the angles
  my $angle = abs(latlngAngle($p1, $p2, $p3)) + abs(latlngAngle($p2, $p3, $p4));
  my $NPoints = floor($angle / $dd);

  # calculate normalized distances
  my $d23 = latlngDistance($p2, $p3);
  my $f1  = latlngDistance($p1, $p2) / $d23;
  my $f4  = latlngDistance($p3, $p4) / $d23;

  my @points = ();

  for my $i ( 1 .. $NPoints ) {
    my $f = $i / ($NPoints + 1);
    my $p = interpolateCorner($p1, $p2, $p3, $p4, $f1, $f4, $f);
    push @points, $p;
  }

  # interpolate fields onto the new points
  interpolateFields($p1, @points, $p2);

  return \@points;
}

# use the arc fitting algorithm to add points between p2 and p3
sub arcFitInterpolation {
  my $p1 = shift; # for first circle fit
  my $p2 = shift; # interpolation starts here
  my $p3 = shift; # interpolation ends here
  my $p4 = shift; # for second circle fit
  my $dd = shift // ($pi / 16); # interpolation angle

  my @xy1 = latlng2dxdy($p2, $p1);
  my @xy2 = (0, 0);
  my @xy3 = latlng2dxdy($p2, $p3);
  my @xy4 = latlng2dxdy($p2, $p4);

  my ($cxy0, $cr0) = circle3PointFit( \@xy1, \@xy2, \@xy3 );
  my ($cxy1, $cr1) = circle3PointFit( \@xy2, \@xy3, \@xy4 );

  # check the circle is on the right side of the corner
  my $t1  = turnDirection( \@xy1, \@xy2, \@xy3 );
  my $t2  = turnDirection( \@xy2, \@xy3, \@xy4 );

  # points: find which circle spans the greatest angle, and divide that angle by
  # the angle spacing
  my ($phi11, $phi12, $dphi1, $phi21, $phi22, $dphi2);
  my $dphiMax = 0;
  if (defined $cxy0) {
    return []
      unless (
              ( $t1 == turnDirection( \@xy1, \@xy2, $cxy0 ) ) &&
              ( $t1 == turnDirection( \@xy2, \@xy3, $cxy0 ) )
             );

    # calculate angles
    $phi11 = atan2($xy2[1] - $cxy0->[1], $xy2[0] - $cxy0->[0]);
    $phi12 = atan2($xy3[1] - $cxy0->[1], $xy3[0] - $cxy0->[0]);
    $dphi1 = deltaAngle($phi11, $phi12);
    $dphiMax = abs($dphi1) if (abs($dphi1) > $dphiMax);
  }
  if (defined $cxy1) {
    return []
      unless (
              ( $t2 == turnDirection( \@xy2, \@xy3, $cxy1 ) ) &&
              ( $t2 == turnDirection( \@xy3, \@xy4, $cxy1 ) )
             );

    $phi21 = atan2($xy2[1] - $cxy1->[1], $xy2[0] - $cxy1->[0]);
    $phi22 = atan2($xy3[1] - $cxy1->[1], $xy3[0] - $cxy1->[0]);
    $dphi2 = deltaAngle($phi21, $phi22);
    $dphiMax = abs($dphi2) if (abs($dphi2) > $dphiMax);
  }

  # find number of points to interpolate
  my $NPoints = floor($dphiMax / abs($dd));
  my $NPointsMax = floor(latlngDistance($p2, $p3) / 0.1);
  $NPoints = $NPointsMax if ($NPoints > $NPointsMax);

  my @points = ();
  for my $i ( 1 .. $NPoints ) {
    my $f = $i / ($NPoints + 1);
    my $phi1 = $phi11 + $dphi1 * $f
      if (defined $dphi1);
    my $phi2 = $phi21 + $dphi2 * $f
      if (defined $dphi2);
    my ($x1, $y1, $x2, $y2);
    if (defined $phi1) {
      $x1 = $cxy0->[0] + $cr0 * cos($phi1);
      $y1 = $cxy0->[1] + $cr0 * sin($phi1);
    } else {
      $x1 = $xy2[0] + $f * ($xy3[0] - $xy2[0]);
      $y1 = $xy2[1] + $f * ($xy3[1] - $xy2[1]);
    }
    if (defined $phi2) {
      $x2 = $cxy1->[0] + $cr1 * cos($phi2);
      $y2 = $cxy1->[1] + $cr1 * sin($phi2);
    } else {
      $x2 = $xy2[0] + $f * ($xy4[0] - $xy3[0]);
      $y2 = $xy2[1] + $f * ($xy4[1] - $xy3[1]);
    }
    my $dx = (1 - $f) * $x1 + $f * $x2 - $xy2[0];
    my $dy = (1 - $f) * $y1 + $f * $y2 - $xy2[1];
    my $p = addVectorToPoint($p2, [$dx, $dy]);
    push @points, $p;
  }

  # interpolate points with respect to distance along spline
  interpolateFields($p2, @points, $p3);

  return \@points;
}


#
# remove duplicate points of the same segment, and reduce point triplets
#
sub removeDuplicatePoints {
  my %var = @_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop} // 0;

  note("removing duplicate points...\n");

  my @pNew = ();
  my $removedCount = 0;
  for (my $i = 0; $i <= $#$points;) {
    # i is the present point
    my $p = $points->[$i];
    last unless (defined $p);
    my $lat0 = $p->{lat};
    my $lng0 = $p->{lon};
    my $s0 = $p->{segment};
    last unless (defined $lat0);

    # points from i to i1 will be combined
    my $i1 = $i;
    my $iNext = ($i1 + 1) % @$points;

    while(
          (($iNext > $i) || ($isLoop && $iNext != $i)) &&
          (abs($points->[$iNext]->{lat} - $lat0) < 1e-9) &&
          (abs($points->[$iNext]->{lon} - $lng0) < 1e-9) &&
          (($iNext + 1) % @$points != $i)
         ) {
      $i1 = $iNext;
      $iNext = ($iNext + 1) % @$points;
    }

    if ($i1 == $i) {
      push @pNew, \%$p;
    }
    else {
      # if this is the first point removed, then clean out derived fields
      if ($removedCount == 0) {
        deleteDerivedFields( $points );
        deleteDerivedFields( \@pNew );
      }
      $removedCount += ($i1 - $i);

      # average together the points: if there's a triplet or more at S/F boundary, this won't
      # be a true average, but good enough
      my %sum1;
      my %sum0;
      my %newPoint = %$p;
      for( my $j = $i; $j != ($i1 + 1) % @$points; $j = ($j + 1) % @$points ) {
        for my $key ( keys %{$points->[$j]} ) {
          # average fields of combined points
          if ( ($key ne "segment") && (ref $points->[$j]->{$key} eq "") && ($points->[$j]->{$key}  =~ /^$number_regexp$/o) ) {
            $sum1{$key} += $points->[$j]->{$key};
            $sum0{$key} ++;
          }
        }
      }
      for my $key ( keys %sum1 ) {
        if ($sum0{$key} > 1) {
          $newPoint{$key} = $sum1{$key} / $sum0{$key};
        }
      }
      push @pNew, { %newPoint };

      # if this wrapped around, also replace the first point
      if ($i1 < $i) {
        $pNew[0] = { %newPoint };
        last;
      }
    }
    last if ($iNext < $i);
    $i = $iNext;
  }

  if ($removedCount > 0) {
    warn("Removed $removedCount duplicate points\n");
  }

  return \@pNew;
}


#
# crop corners
#

#
# replace sharp corners with circular arcs
#
sub cropCorners {
  my %var = @_;
  my $points     = $var{points} // [];
  my $cornerCrop = $var{cornerCrop} // 0;
  my $minRadians = $var{minRadians} // $pi / 3;
  my $maxRadians = $var{maxRadians};
  my $start      = $var{start};
  my $end        = $var{end};
  my $spacing    = $var{spacing} // 0;
  my $autoSpacing = $var{autoSpacing} // 0;
  my $isLoop     = $var{isLoop} // 0;
  my $minRadius  = $var{minRadius} // 0;

  # threshold distance for points aligning with corner point
  my $epsilon = 0.01 + 0.05 * $cornerCrop;

  # if arguments exclude any points or angles
  return $points
    if (((defined $maxRadians) && (defined $minRadians) && ($maxRadians < $minRadians)) || ((! $isLoop) && (defined $start) && (defined $end) && ($start > $end)));

  #
  # create a direction field
  #
  addDirectionField(points=> $points, isLoop=>$isLoop);

  # find indices of corners meeting the cropping criteria
  my @cropCorners = ();

  # make sure last point isn't same as first point
  # assume rest of code can deal with this
  pop @$points while ($isLoop && @$points && pointsAreClose($points->[0], $points->[-1]));

  for my $i ( 0 .. $#$points ) {
    next if ( (! $isLoop) && (($i == 0) || ($i == $#$points)) );
    my $p0 = $points->[($i - 1) % @$points];
    my $p1 = $points->[$i];
    my $p2 = $points->[($i + 1) % @$points];
    my $a  = latlngAngle($p0, $p1, $p2);
    $a = (defined $a) ? abs($a) : 0;
    push @cropCorners, $i
      if (($a >= $minRadians) && ((! defined $maxRadians) || ($a < $maxRadians)));
  }

  note("cropping " . scalar(@cropCorners) . " corners\n");

  return $points unless (@cropCorners);

  # add a distance field if needed
  addDistanceField(points=> $points)
    unless ( (defined $points->[0]->{distance}) || (! ( (defined $start) || (defined $end) )) );

  # corners which are too close get pruned
  my $dMin = 2 * $cornerCrop;
  my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);

  my @cc = ();
  for my $ic ( 0 .. $#cropCorners ) {
    my $d = $points->[$cropCorners[$ic]]->{distance};
    my $dPrev;
    if ((! $isLoop) && ($ic == 0)) {
      $dPrev = 0;
    } else {
      $dPrev = $points->[$cropCorners[($ic - 1) % @cropCorners]]->{distance};
      $dPrev -= $courseDistance
	if ($ic == 0);
    }
    my $dNext;
    if ((! $isLoop) && ($ic == $#cropCorners)) {
      $dNext = $points->[-1]->{distance};
    } else {
      $dNext = $points->[$cropCorners[($ic + 1) % @cropCorners]]->{distance};
      $dNext += $courseDistance
	if ($ic == $#cropCorners);
    }

    # pass criteria:
    # 1. point is in limits defined by start and/or stop (if isLoop, start can be > stop)
    # 2. corner is sufficiently far from neighbor corners (or for point-to-point, course terminals)
    push @cc, $cropCorners[$ic]
      if (
	  (
	   (defined $start) ?
	   (
	    (defined $end) ?
	    (
	     ($isLoop && ($end < $start)) ?
	     (($d >= $end) && ($d <= $start)) :
	     (($d <= $end) && ($d >= $start))
	    ) :
	    ($d >= $start)
	   ) :
	   ((! defined $end) || ($d <= $end))
	  ) &&
	  ($dNext >= $d + $dMin) &&
	  ($dPrev <= $d - $dMin)
	 );
  }

  @cropCorners = @cc;

  return $points
    unless (@cropCorners);

  # we've identified corners to be cropped.
  # insert points before and after, then eliminate points between the inserted points
  # if isLoop, last corner could result in cropping of route beginning

  # special case:
  # if the crop zone of the last corner or the crop zone of the first corner
  # overlaps a lap S/F then the S/F needs to be interpolated onto
  # the cropped interval


  my @pNew = ();

  my $ic = 0;
  # position of first crop point: may be before start of course if a loop
  my $dc1 = $points->[$cropCorners[$ic]]->{distance} - $cornerCrop;
  # position of second crop point
  my $dc2 = $dc1 + 2 * $cornerCrop;
  my $i = 0;
  my $p1 = $points->[$i];
  my $p2 = $points->[($i + 1) % @$points];
 pointLoop: while ($i < @$points) {
    # if it's a point to point and we reached the last point, we're done
    if ((! $isLoop) && ($i >= $#$points)) {
      push @pNew, $points->[$i] if ($i == $#$points);
      last pointLoop;
    }

    my $dp1 = $p1->{distance};  # this point
    my $dp2 = $p2->{distance};  # next point
    $dp2 += $courseDistance if ($dp2 < $dp1); # if wrap-around

    # if the first point is before or roughly coincident with the corner, it gets added
    push @pNew, $p1
      if ($dp1 <= $dc1 + $epsilon);

    # if the next point is still before the crop interval, then skip to the next point
    # if this point is close to the corner entry it will get added next interation
    if ($dp2 < $dc1 + $epsilon) {
      $i ++;
      $p1 = $points->[$i];
      $p2 = $points->[($i + 1) % @$points];
      next pointLoop;
    }

    # next point > start of crop interval: interpolate a point if needed
    # if point is immediately before corner entry, it's been added
    if  (($dc1 > $dp1 + $epsilon) && ($dc1 < $dp2 - $epsilon)) {
      $p1 = interpolatePoint($p1, $p2, ($dc1 - $dp1) / ($dp2 - $dp1));
      $dp1 = $dc1;
      push @pNew, $p1;
    }

    # p1 has been processed
    # p2 is past the entry point if we're at this point
    # need to jump ahead to exit point

    while ($dp2 < $dc2 - $epsilon) {
      # if p1 will extend to point set of points, we're done
      # note for laps we can wrap around
      if  ( $isLoop ) {
	if ($i + 1 > $#$points) {
	  # corner wraps around: interpolate points
	  # code commented out until next version:
	  # my $newPoints = turnArcFit($pNew[-2], $pNew[-1], $pNew[0], $pNew[1], $cornerCrop);
	  # my $iMid = int(@$newPoints / 2);
	  # push @pNew, @$newPoints[0 .. $iMid - 1];
	  # add the curve points to the beginning of the new points
	  # unshift @pNew, @$newPoints[$iMid .. $#$newPoints];
	  last pointLoop;
	}
      } elsif ($i > $#$points) {
	last pointLoop;
      }

      # skip to next point
      $i ++;
      $p1 = $p2;
      $p2 = $points->[($i + 1) % @$points];
      $dp1 = $dp2;
      $dp2 = $p2->{distance};
      $dp2 += $courseDistance if ($dp2 < $dp1); # if wrap-around
    }

    # p2 is now either priximate to or beyond exit point
    # exit point is along interval from p1 to p2
    # set p1 to the exit point
    if (abs($dp2 - $dc2) < $epsilon) {
      $i ++;
      $p1 = $p2;
      $p2 = $points->[($i + 1) % @$points];
      $dp1 = $dp2;
      $dp2 = $p2->{distance};
      $dp2 += $courseDistance if ($dp2 < $dp1); # if wrap-around
    } elsif (abs($dp1 - $dc2) > $epsilon) {
      $p1 = interpolatePoint($points->[$i], $points->[($i + 1) % @$points], ($dc2 - $dp1) / ($dp2 - $dp1));
      $dp1 = $dc2;
    }

    # code for next version: arc fits
    # interpolate points up to p1 if needed
    # this doesn't work for first corner
    # if (@pNew) {
    #   my $arcPoint1 = (@pNew > 1) ? $pNew[-2] : $points->[-1];
    #   my $arcPoint2 = $pNew[-1];
    #   my $arcPoint3 = $p1;
    #   my $arcPoint4 = $p2;
    #   #  my $newPoints = cornerArcFit($cornerCrop, $arcPoint1, $arcPoint2, $arcPoint3, $arcPoint4);
    #   my $newPoints = turnArcFit($arcPoint1, $arcPoint2, $arcPoint3, $arcPoint4, $cornerCrop);
    #   push @pNew, @$newPoints;
    # }

    # skip to next corner point
    $ic ++;

    # skip to next crop corner, else dump rest of points
    if ($ic > $#cropCorners) {
      if ($isLoop) {
	$ic -= @cropCorners;
      } else {
	push @pNew, $p1
	  unless (@pNew && pointsAreClose($pNew[-1], $p1));
	push @pNew, @$points[$i + 1 .. $#$points];
	last pointLoop;
      }
    }

    # set corner points for new corner
    $dc1 = ($points->[$cropCorners[$ic]]->{distance} - $cornerCrop);
    $dc1 += $courseDistance while ($dc1 < $dp1);
    $dc2 = ($points->[$cropCorners[$ic]]->{distance} + $cornerCrop);
    $dc2 += $courseDistance while ($dc2 < $dc1);
  }

  deleteDerivedFields(\@pNew);
  return \@pNew;
}

#
# adds splines to points
# this can also be used for arc fitting
#
sub addSplines {
  my %var = @_;
  my $points     = $var{points};
  my $minRadians = $var{minRadians};
  my $maxRadians = $var{maxRadians};
  my $start      = $var{start};
  my $end        = $var{end};
  my $isLoop     = $var{isLoop} // 0;
  my $splineType = $var{splineType} // "spline";

  note("starting $splineType processing...\n");

  #
  # create a direction field
  #
  addDirectionField(points=> $points, isLoop=>$isLoop);

  # add a distance field if needed
  addDistanceField(points=> $points)
    unless ( (defined $points->[0]->{distance}) || (! ( (defined $start) || (defined $end) )) );

  # find corners which meet spline criteria
  # two turns in the same direction, both less than max
  # assume sharper or single-point turns are intentional
  my @pNew = ();
  my $isArcFit = ($splineType eq "arcFit");

  my $count = 0;

  # i : first point on interpolation interval
 iLoop: for my $i ( 0 .. $#$points ) {
    push @pNew, $points->[$i];

    # add points if appropriate
    # splines cannot be fit to first or last interval unless it's a loop
    if ($isLoop || (($i > 0) && ($i < ($#$points - 1)))) {
      my $j = ($i + 1) % @$points;
      next iLoop if (pointsAreClose($points->[$i], $points->[$j], 1));

      # if start and stop points are specified, then check these
      # both points i and j must pass the test
      if ((defined $start) && (defined $end) && ($end < $start)) {
        next iLoop if (($points->[$i]->{distance} > $start) || ($points->[$j]->{distance} > $start) );
        next iLoop if (($points->[$i]->{distance} < $end)   || ($points->[$j]->{distance} < $end) );
      } else {
        next iLoop if ((defined $start) && ( ($points->[$i]->{distance} < $start) || ($points->[$j]->{distance} < $start) ) );
        next iLoop if ((defined $end)   && ( ($points->[$i]->{distance} > $end)   || ($points->[$j]->{distance} > $end) ) );
      }

      my $k = ($i - 1) % @$points;
      while (pointsAreClose($points->[$i], $points->[$k], 1)) {
        next iLoop if ($k == ($isLoop ? $j : 0));
        $k = ($k - 1) % @$points;
      }

      my $l = ($j + 1) % @$points;
      while (pointsAreClose($points->[$j], $points->[$l], 1)) {
        $l = ($l + 1) % @$points;
        if ($isLoop) {
          next iLoop if ( ($l <= $i) && ($l >= $k) );
        } else {
          next iLoop if ($l <= $j);
        }
      }
      if ($isLoop) {
        next iLoop if ( ($l <= $j) && ($l >= $k) );
      } else {
        next if ($l <= $j);
      }

      # turn angles
      my $a1 = latlngAngle($points->[$k], $points->[$i], $points->[$j]);
      my $a2 = latlngAngle($points->[$i], $points->[$j], $points->[$l]);
      my $turn = ($a1 + $a2) / 2;
      if (
          (abs($turn) > $minRadians) &&
          (abs($turn) <= $maxRadians)
         ) {
        my $newPoints;
        if ($isArcFit) {
          $newPoints = arcFitInterpolation( $points->[$k], $points->[$i], $points->[$j], $points->[$l], $minRadians );
        } else {
          $newPoints = splineInterpolation( $points->[$k], $points->[$i], $points->[$j], $points->[$l], $minRadians );
        }
        $count += scalar(@$newPoints);
        push @pNew, @$newPoints;
      }
    }
  }

  # remove distance field if we've added any points
  if (@pNew && ($count > 0)) {
    for my $f ( qw( direction distance ) ) {
      deleteField(points=> \@pNew, field => $f) if (defined $pNew[0]->{$f});
    }
  }
  return \@pNew;
}


# calculate the normal between a point p3, and the segment connecting points p1 and p2
# 1: formula for segment:
#   (y - y1) / (x - x1) = (y2 - y1) / (x2 - x1)
#   (y - y1) (x2 - x1) = (x - x1) (y2 - y1)
# 2: formula for perpendicular line, passing thru x3
#   (y - y3) / (x - x3) = -(x2 - x1) / (y2 - y1)
#   (y - y3) (y2 - y1) = - (x - x3) (x2 - x1)
# 3: solve for x (from 1)
#   x = x1 + (y - y1) (x2 - x1) / (y2 - y1)
#   x = x1 + (x2 - x1) [ (y - y1) / (y2 - y1) ]
# 4: plug into 2:
#   (y - y3) (y2 - y1) = - ((x1 - x3) + (y - y1) (x2 - x1) / (y2 - y1)) (x2 - x1)
#   (y - y3) (y2 - y1)^2 = -((x1 - x3)  (x2 - x1) (y2 - y1) + (y - y1) (x2 - x1)^2)
#   (y - y3) (y2 - y1)^2 + (x1 - x3)  (x2 - x1) (y2 - y1) + (y - y1) (x2 - x1)^2 = 0
#   (y - y3) (y2 - y1)^2 + (y - y1) (x2 - x1)^2  + (x1 - x3)  (x2 - x1) (y2 - y1)  = 0
#   y [ (y2 - y1)^2  + (x2 - x1)^2 ] - y1 (x2 - x1)^2 - y3 (y2 - y1)^2 + (x1 - x3)  (x2 - x1) (y2 - y1)  = 0
#   y [ (y2 - y1)^2  + (x2 - x1)^2 ] = y1 (x2 - x1)^2 + y3 (y2 - y1)^2 - (x1 - x3)  (x2 - x1) (y2 - y1)
#   y = [ y1 (x2 - x1)^2 + y3 (y2 - y1)^2 - (x1 - x3) (x2 - x1) (y2 - y1) ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
#   y = [ y1 (x2 - x1)^2 + y3 (y2 - y1)^2 + (x3 - x1) (x2 - x1) (y2 - y1) ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
# for (3), we need...
#   (y - y1) = [ y1 (x2 - x1)^2 + y3 (y2 - y1)^2 + (x3 - x1) (x2 - x1) (y2 - y1) - y1 (y2 - y1)^2  - y1 (x2 - x1)^2 ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
#   (y - y1) = [ (y3 - y1) (y2 - y1)^2 + (x3 - x1) (x2 - x1) (y2 - y1) ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
#   (y - y1) / (y2 - y1)= [ (y3 - y1) (y2 - y1) + (x3 - x1) (x2 - x1) ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
#   x = x1 + (x2 - x1) [ (y3 - y1) (y2 - y1) + (x3 - x1) (x2 - x1) ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
# summary (putting y into same form as x):
#   x = x1 + (x2 - x1) [ (y3 - y1) (y2 - y1) + (x3 - x1) (x2 - x1) ] / [ (y2 - y1)^2  + (x2 - x1)^2 ]
#   y = y1 + (y2 - y1) [ (y3 - y1) (y2 - y1) + (x3 - x1) (x2 - x1) ] / [ (y2 - y1)^2  + (x2 - x1)^2 ]
# parametric position on line: (this should be [0, 1])
#   f = [ (y3 - y1) (y2 - y1) + (x3 - x1) (x2 - x1) ] / [ (y2 - y1)^2  + (x2 - x1)^2 ]
# distance from line
#   x - x3 = (x1 - x3) + f (x2 - x1)
#   y - y3 = (y1 - y3) + f (y2 - y2)
#   (x - x3)^2 + (y - y3)^2 = [ (x1 - x3) + f (x2 - x1) ]^2 + [ (y1 - y3) + f (y2 - y2) ]^2
#   d = sqrt( [ (x1 - x3) + f (x2 - x1) ]^2 + [ (y1 - y3) + f (y2 - y1) ]^2 )

sub xyPointOnLine {
  # x,y points
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my ($x1, $y1) = @$p1;
  my ($x2, $y2) = @$p2;
  my ($x3, $y3) = @$p3;
  return (undef, undef) if ( ($x1 == $x2) && ($y1 == $y2) );
  my $f = ( ($y3 - $y1) * ($y2 - $y1) + ($x3 - $x1) * ($x2 - $x1) ) / ( ($y2 - $y1) ** 2  + ($x2 - $x1) ** 2 );
  my $d = sqrt( ( $x1 - $x3 + $f * ($x2 - $x1) ) ** 2 + ( $y1 - $y3 + $f * ($y2 - $y1) ) ** 2 );
  return ( $f, $d );
}

# checks whether px is on the line connecting p1 and p2
sub isPointOnRoad {
  my $p1 = shift();
  my $p2 = shift();
  my $px = shift();
  my $dmax  = shift() // 1;
  # if point is "on" an endpoint (within 10 cm) then true
  return 1 if (pointsAreClose($p1, $px) || pointsAreClose($p2, $px));
  # else check if it is within the margin of the line
  my ($dx1, $dy1) = latlng2dxdy($px, $p1);
  my ($dx2, $dy2) = latlng2dxdy($px, $p2);
  my ($f, $d)     = xyPointOnLine([$dx1, $dy1], [$dx2, $dy2], [0, 0]);
  my $isOnRoad    = ((defined $f) && (defined $d) && ($f >= 0) && ($f <= 1) && ($d <= $dmax));
  return $isOnRoad;
}

# a corner version of whether the point is on the road...
# but requires more points.
# given 4 points, takes a direction from p1 to p2
# and a direction from p3 to p4
# if the direction from p2 to px, and from px to p3, falls in
# between the cirections from p1 to p2 and from p2 to p3,
# then it's compatible with being on the line
sub isPointOnRoadCorner {
  my $p1 = shift();
  my $p2 = shift();
  my $p3 = shift();
  my $p4 = shift();
  my $px = shift;

  return 0 unless ((defined $px) && (defined $p2) && (defined $p3));

  return 1
    if (pointsAreClose($px, $p2) || pointsAreClose($px, $p3));

  return 0
    unless ((defined $p1) && (defined $p4));

  return 0
    if (pointsAreClose($p2, $p3) || pointsAreClose($p1, $p2) || pointsAreClose($p3, $p4));

  my $d12 = latlngDirection($p1, $p2);
  my $d34 = latlngDirection($p3, $p4);
  my $d2x = latlngDirection($p2, $px);
  my $dx3 = latlngDirection($px, $p3);

  # these angles are between -pi/2 and +pi/2
  my $dA = deltaAngle($d12, $d2x);
  my $dB = deltaAngle($d12, $dx3);
  my $dC = deltaAngle($d12, $d34);
  # if angles are monotonic, success
  my $isPointOnRoadCorner =
    (
     ( ($dA >= 0) && ($dB >= $dA) && ($dC >= $dB) ) ||
     ( ($dA <= 0) && ($dB <= $dA) && ($dC <= $dB) )
    );

  return $isPointOnRoadCorner;
}


# do tests of if point i falls on the road in the range (j, k, l, m)
sub roadTest {
  my $points = shift;
  my $j = shift;                # point before first point
  my $k = shift;                # first point
  my $l = shift;                # second point
  my $m = shift;                # point after second point
  my $i = shift;                # test point
  my $d = shift;                # distance error margin

  # first check to see if the point i falls in the range k .. l
  return 0
    unless (
            ($i > 0) &&
            ($k > 0) &&
            ($l > 0) &&
            ($i <= $#$points) &&
            ($k <= $#$points) &&
            ($l <= $#$points)
           );

  return 1
    if (
        isPointOnRoad($points->[$k], $points->[$l], $points->[$i], $d)
       );

  return 0
    unless (
            ($j > 0) &&
            ($m > 0) &&
            ($j <= $#$points) &&
            ($m <= $#$points)
           );

  return ( isPointOnRoadCorner($points->[$j], $points->[$k], $points->[$l], $points->[$m], $points->[$i]) );
}

#
# zig-zags: pairs of 180 degree turns within a certain distance are probably misplaced control points
# this is just a warning for now... easy to fix if it's along a line, but what if it goes around a corner?
# added 5.13: fix zig-zags @ S/F on loops
#

sub fixZigZags {
  my %var = @_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop} // 0;

  for my $zigZagIter ( 1 .. 10 ) {
    note("checking for zig-zags iteration $zigZagIter...\n");
    my $dzigZag = 100;
    my @UTurns = ();
    my $iStart = $isLoop ? 0 : 1;
    my $iEnd = $isLoop ? $#$points : $#$points - 1;

    for my $i ( $iStart .. $iEnd ) {
      push @UTurns, $i
        if (UTurnCheck($points->[$i - 1], $points->[$i], $points->[$i], $points->[($i + 1) % @$points], -0.9));
    }

    addDistanceField(points=> $points);
    my $zigZagCount = 0;
    if (@UTurns) {
      while ( @UTurns > 1 ) {
        my $U1 = shift @UTurns;
        my $U2 = $UTurns[0];
        my $p1 = $points->[$U1];
        my $p2 = $points->[$U2];

        if ($p2->{distance} - $p1->{distance} < $dzigZag) {
          warn("WARNING: zig-zag found on points : ",
               $U1, " and ", $U2, " : ",
               sprintf("%.4f km: (%g, %g)", 0.001 * $p1->{distance}, $p1->{lon}, $p1->{lat}),
               " to ",
               sprintf("%.4f km: (%g, %g)", 0.001 * $p2->{distance}, $p2->{lon}, $p2->{lat}),
               " : separation = ", sprintf("%.4f", $p2->{distance} - $p1->{distance}), " meters\n");

          # repairing zig-zags...
          # zig-zags are two U-turns within a specified distance
          # p1 -> p2 -> ... ->  p3 -> p4
          # U-turn @ p2, and U-turn @ p3
          # 1. eliminate all points between p2 and p3
          # 2. as long as P3 has a U-turn, delete it... there will be a new P3
          # 3. as long as P2 has a U-turn, delete it...
          # 4. go back step 2 if we deleted any U-turns

          # eliminate points between
          warn("repairing zig-zag iteration $zigZagIter...\n");
          my $u = $U1;      # keep points up to u
          my $v = $U2 + 1;  # keep points starting with v
          $v ++
            while (
                   ($v < $#$points) &&
                   UTurnCheck($points->[$u], $points->[$v], $points->[$v], $points->[$v + 1])
                  );

          warn("eliminating ", $v - $u - 1, " points\n");
          $zigZagCount ++;

          my @pNew =  @$points[0 .. $u];
          push @pNew, @$points[$v .. $#$points];

          # if we ran out of points, something is wrong
          die("repairing zig-zags eliminated entire route\n")
            if (@pNew < 2);

          $points = \@pNew;

          # adjust U-turn coordinates
          # We've eliminated the next Uturn, so pop it
          shift @UTurns;

          # adjust coordinates of remaining U-turns
          for my $U ( @UTurns ) {
            $U += $u - $v + 1;
          }

          # get rid of obsolete U-turns
          shift @UTurns
            while (@UTurns && ( $UTurns[0] < 0));
        }
      }
      # may need to redo distance if zig-zag repair
      deleteDerivedFields($points)
        if ($zigZagCount > 0);
    }
    return $points if ($zigZagCount == 0);
  }
  return $points;
}

#
# look for loops
#
sub findLoops  {
  my $points = shift;
  my $isLoop = shift;
  note("checking for loops...\n");
  my $loopDistance = 100;
  # add direction field: distance field was just calculated by zig-zag check
  addDirectionField(points=> $points, isLoop=> $isLoop);
  my $u = 0;
  my $v = 0;
  my $loopAngle = 0.7 * $twopi;
  while ($v < $#$points) {
    my $p = $points->[$u];
    $v ++ while (($v < $#$points) && ($points->[$v + 1]->{distance} < $p->{distance} + $loopDistance));
    if (abs($p->{heading} - $points->[$v]->{heading}) > $loopAngle) {
      $u ++ while (($u + 1 < $v) && (abs($points->[$u + 1]->{heading} - $points->[$v]->{heading}) > $loopAngle));
      warn(
           "WARNING: loop between distance: ",
           sprintf("%.3f km and %.3f km",
                   $points->[$u]->{distance} / 1000,
                   $points->[$v]->{distance} / 1000
                  ),
           "\n");
      $u = $v;
      next;
    }
    $u ++;
  }
  deleteField(field=> "heading", points=> $points);
}

sub applyLaneShift {
  my %var = @_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop} // 0;

  return $points unless (@$points);

  my @pNew = ();

  # create list of (x, y) coordinates
  my @dxs = ();
  my @dys = ();
  my @dss = ();
  my @ss  = (0);
  my @dirs = ();

  for my $i ( 0 .. $#$points ) {
    push @ss, $ss[-1] + $dss[-1] if ($i > 0);
    if ($isLoop || ($i < $#$points)) {
      my ($dx, $dy) = latlng2dxdy($points->[$i], $points->[($i + 1) % @$points]);
      push @dxs, $dx;
      push @dys, $dy;
      push @dss, sqrt($dx ** 2 + $dy ** 2);
      push @dirs, atan2($dy, $dx);
    }
  }

  # final point for point-to-point
  if (! $isLoop) {
    push @dxs, $dxs[-1];
    push @dys, $dys[-1];
    push @dss, $dss[-1];
    push @dirs, $dirs[-1];
  }

  # lane shift: to right, which means adding pi/2 to the direction
 shiftLoop: for my $i ( 0 .. $#$points ) {
    my ($dir1, $dir2);
    if (($i > 0) || $isLoop) {
      $dir1 = $dirs[$i - 1];
      $dir2 = $dir1 + reduceAngle($dirs[$i] - $dir1);
    } else {
      $dir1 = $dirs[$i];
      $dir2 = $dirs[$i];
    }

    # for sharp turns repeat a point: there's no way to decide if it's an "inside" or "outside" sharp turn
    if ( ($isLoop || (($i > 0) && ($i < $#$points))) && (abs($dir2 - $dir1) > 0.99 * $pi) ) {
      my @pTurns = ();
      for my $dir ( $dir1, $dir2 ) {
        push @pTurns,
          shiftPoint(point=> $points->[$i], direction=> $dir, distance=> $points->[$i]->{shift});
      }
      # check if there's a knot.. if not use the doubled points
      my @fs = segmentIntercept( [$points->[$i - 1], $pTurns[0]], [$pTurns[1], $points->[($i + 1) % @$points]] );
      if ( @fs == 0 ) {
        push @pNew, @pTurns;
        next shiftLoop;
      }
    }

    push @pNew, shiftVertex(point=> $points->[$i], directions=> [$dir1, $dir2], distance=> $points->[$i]->{shift});
  }

  deleteDerivedFields( \@pNew );
  return \@pNew;
}

#
# smoothing:
# foreach field, smooth using a combination of a baseline
# sigma and a specified sigma-field, each optional.
# the smoothing is applied to the listed fields, for example
# elevation or lat and lon.
#
sub smoothing {
  my %var = @_;
  my $fields      = $var{fields}  // [];
  my $isLoop      = $var{isLoop} // 0;
  my $points      = $var{points} // [];
  my $sigmaField  = $var{sigmaField} // "";
  my $sigmaFactor = $var{sigmaFactor} // 1;
  my $sigma0      = $var{sigma} // 0;   # uniform smoothing across all points
  my $weighting   = $var{weighting} // [];
  my $cornerEffect = $var{cornerEffect} // 0;

  my $sigma02 = $sigma0 ** 2;

  note("smoothing proc called...\n");
  note("smoothing @$fields with σ = $sigma0\n");
  note("smoothing sigma field = $sigmaField\n")
    if ($sigmaField ne "");

  return $points unless ( (@$fields > 0) && (( $sigma0 > 0) || ((defined $sigmaField) && ($sigmaField ne "") && ($sigmaFactor > 0))) );

  my @pNew;

  addCurvatureField(points=> $points, isLoop=> $isLoop)
    if ( $cornerEffect && (! defined $points->[0]->{curvature}) );

  my $useWeighting = (@$weighting > 0);
  note("smoothing @$fields with weighting.\n") if ($useWeighting);
  note("smoothing @$fields with the corner effect = $cornerEffect.\n") if ($cornerEffect > 0);

  # step thru the points
  for my $i ( 0 .. $#$points ) {
    my $p = $points->[$i];
    my $sigmap = (defined $p->{$sigmaField}) ? abs($sigmaFactor * $p->{$sigmaField}) : 0;
    my $sigma =
      ($sigmap <= 0) ?
      $sigma0 :
      (
       ($sigma0 <= 0) ?
       $sigmap :
       sqrt($sigma02 + $sigmap ** 2)
      );

    # create smoothed data: initialize with unsmoothed data
    my %var = %$p;

    if ($sigma > 0) {
      $sigma /= $weighting->[$i]
        if ($useWeighting && ($weighting->[$i] > 0));

      if ($sigma < 0.01) {
        push @pNew, $p;
        next;
      }

      my $dsMax = abs(4 * $sigma);

      my $j = $i;
      my $s = 0;
      while ((($j > 0) || $isLoop) &&
             ($j > $i - @$points) &&
             ($s  < $dsMax)
            ) {
        my $ds = latlngDistance( $points->[$j], $points->[$j - 1] );
        $s += $ds;

        # a 1 radian turn is the same as 2 sigma for cornerEffect = 1
        $s += $ds * $cornerEffect * ($points->[$j - 1]->{curvature} + $points->[$j]->{curvature}) * $sigma
          if ($cornerEffect > 0);
        $j --;
      }

      $s = 0;
      my $k = $i;
      while ((($k < $#$points) || $isLoop) &&
             ($k < $i + @$points) &&
             ($s < $dsMax )
            ) {
        my $l = $k % @$points;
        my $m = ($k + 1) % @$points;
        my $ds = latlngDistance( $points->[$l], $points->[$m] );
        $s += $ds;
        $s += $ds * $cornerEffect * ($points->[$l]->{curvature} + $points->[$m]->{curvature}) * $sigma
          if ($cornerEffect > 0);
        $k ++;
      }

      # create list of separations
      $s = 0;
      my @ss = (0);
      for my $ii ( $j .. $k - 1 ) {
        $s += latlngDistance($points->[($ii + 1) % @$points], $points->[$ii % @$points]);
        push @ss, $s;
      }

      my $sum0 = 0;
      my %sum1;

      my @us = ();

      # find normalized distance to center point
      for my $ii ( 0 .. $#ss ) {
        push @us, ($ss[$ii] - $ss[$i - $j]) / $sigma;
      }

      next
        if ( (@us < 2) );

      # linearized approximation
      # more sophisticated approach could use 2D convolution
      for my $ii ( 0 .. $#us ) {
        my $u = $us[$ii];
        my $p = $points->[($j + $ii) % @$points];

        # weight by distance
        my $du = ($ii > 0) ? $u - $us[$ii - 1] : 0;
        $du += $us[$ii + 1] - $u if ($ii < $#us);
        my $w = exp(-($u ** 2) / 2) * $du;
        $sum0 += $w;

        for my $field ( @$fields ) {
          $sum1{$field} += $w * $p->{$field};
        }
      }
      for my $field ( @$fields ) {
        $var{$field} = $sum1{$field} / $sum0 if ($sum0 != 0);
      }
    }
    push @pNew, \%var;
  }

  # delete curvature field if we modified position
  if (grep(/^lat/, @$fields) || grep(/^lon/, @$fields)) {
    deleteDerivedFields(\@pNew);
  }

  return \@pNew;
}


sub doAutoSpacing {
  my %var = @_;
  my $points    = $var{points}  // [];
  my $isLoop    = $var{isLoop} // 0;
  my $lSmooth   = $var{lSmooth} // 0;
  my $smoothAngle = $var{smoothAngle} // 0;
  my $minRadius = $var{minRadius} // 0;

  my $smoothRadians = $smoothAngle * $deg2rad;

  # iterate a few times
  for my $autoSpacingIteration ( 0 ) {
    # do this in each direction
    for my $direction (0, 1 ) {

      my @pNew = ();

      # refine distance -- need to exceed the smoothing length
      # on spacing: minRadius will increase the separation of points,
      # so we need to be careful how we consider this
      my $lambda = sqrt(1 + $lSmooth ** 2);
      my $dRefine = 3 * sqrt($lSmooth ** 2 + $minRadius ** 2);

    iLoop: for my $i ( 0 .. $#$points ) {
        push @pNew, $points->[$i]; # temporarily put the latest point on the new points list

        # there's nothing behind the first point -- copy it to the last point to get refinement
        next iLoop
          if ( $i == 0 );

        if ( $isLoop || ($i < $#$points) ) {
          # find points which define an angle
          my $i1 = ($i - 1) % scalar(@$points);
          my $i2 = ($i + 1) % scalar(@$points);
          my $d1;
          my $d2;
          while (($d1 = latlngDistance($points->[$i1], $points->[$i])) < 0.01) {
            $i1 --;
            next iLoop
              if ( ((! $isLoop) && ($i1 < 0)) || ($i1 == $i));
            $i1 %= scalar(@$points);
          }
          while (($d2 = latlngDistance($points->[$i2], $points->[$i])) < 0.01) {
            $i2 ++;
            next iLoop
              if (((! $isLoop) && ($i2 > $#$points)) || ($i2 == $i));
            $i1 %= scalar(@$points);
          }
          # determine the angle between the points
          my $a = latlngAngle($points->[$i1], $points->[$i], $points->[$i2]);

          # add points if needed
          die("ERROR: smoothRadians not defined (smoothAngle = $smoothAngle\n")
            unless (defined $smoothRadians);
          if ( abs($a) > abs($smoothRadians) ) {
            # refine spacing -- need to refine to sufficient resolution to resolve the angle
            # this was multipled by 0.5, but that generated too many points, so updating
            my $spacing = $lambda * (0.01 + abs($smoothRadians / $a));

            # tricky bit -- we need to insert points back to the desired range, but that may extend earlier than points
            # which we've already placed, so we'll need to keep track of points as we rewind.

            # find interval on which to add first point
            my $s = 0;
            my $i3 = $#pNew;
            my @ds;
            $ds[$i3] = 0;
          sLoop: while ($s < $dRefine) {
              last sLoop if ($i3 <= 0);
              $i3 --;
              $ds[$i3] = latlngDistance($pNew[$i3], $pNew[$i3 + 1]);
              $s += $ds[$i3];
            }

            # find the start point, between point i3 and i3 + 1
            my $f;
            if ($s > $dRefine) {
              $f = ($s - $dRefine) / $ds[$i3]; # how far over the segment goes
            } else {
              $f = 0;
            }

            # strip off the points beyond i3, to save for later
            my @pStack = ();
            push @pStack, pop @pNew
              while ($#pNew > $i3);

            # add first point for corner smoothing, unless another point is close
            my $ff = 0.5 * $spacing / $ds[$#pNew]; # normalized spacing of new points
            if ( ($f > $ff) && ($f < 1 - $ff) ) {
              push @pNew, interpolatePoint($pNew[-1], $pStack[-1], $f);
              # adjust spacing to next point to account for interpolated point
              $ds[$#pNew] = $ds[$#pNew - 1] * (1 - $f);
              $ds[$#pNew - 1] *= $f;
            }

            # go thru points in stack, and adjust spacings
            while (@pStack) {
              my $p1 = $pNew[-1];
              my $p2 = $pStack[-1];
              my $dsTot = latlngDistance($p1, $p2);
              my $N = int($dsTot / $spacing  + 0.5);
              if ($N > 0 ) {
                $ds[$#pNew] = $dsTot / $N;
                for my $n ( 1 .. $N - 1 ) {
                  push @pNew, interpolatePoint($p1, $p2, $n / $N);
                  $ds[$#pNew] = $dsTot / $N;
                }
              } else {
                $ds[$#pNew] = $dsTot;
              }
              push @pNew, pop @pStack;
              $ds[$#pNew] = 0;
            }
          }
        }
      }
      $points = [ reverse @pNew ];
    }
  }
  return $points;
}

sub doPointInterpolation {
  my %var = @_;
  my $points    = $var{points}  // [];
  my $isLoop    = $var{isLoop} // 0;
  my $spacing   = $var{spacing} // 0;

  note("interpolation..\n");
  my @pNew = ();
  my $iMax = $#$points - ($isLoop ? 0 : 1);
  for my $i ( 0 .. $iMax ) {
    my $p1 = $points->[$i];
    my $p2 = $points->[($i + 1) % @$points];
    push @pNew, $p1;
    my $ps = latlngDistance( $p1, $p2 );
    my $npoints = int( $ps / $spacing + 0.5);
    # interpolate points...
    for my $n ( 1 .. $npoints - 1 ) {
      push @pNew,  interpolatePoint( $p1, $p2, $n / $npoints);
    }
  }
  push @pNew, $points->[-1] unless ($isLoop);
  note("interpolation increased course from ", scalar @$points, " to ", scalar @pNew, " points\n");
  $points = \@pNew;
  return $points;
}


sub snapPoints {
  my %var = @_;
  my $points = $var{points} // [];
  my $snap   = $var{snap}   // 0;
  my $snapTransition  = $var{snapTransition} // 0;
  my $snapDistance    = $var{snapDistance} // 2;
  my $snapAltitude    = $var{snapAltitude} // 1;
  my $spacing         = $var{spacing} // 0;

  addDistanceField(points=> $points);

  my %vals = @_;
  # snap = 1: subsequent laps snap to position of earlier laps
  # snap = 2: earlier laps snap to position of layer laps
  # snap 2 can be handled by reversing points, then doing snap, then reversing back
  #
  # snapping can happen either on sections done in the same direction, or in opposite directions
  #

  # if we're snapping later for earlier, flip points
  if ( $snap == 2 ) {
    @$points = reverse(@$points);
  }

  # on large courses, since initial search is O(N-squared), step thru multiple points, then refine
  # snap step 1 has a potential bug (infinite loop) so lower bound is 2
  my $snapStep = 2 + int(scalar(@$points) / 200);

  #
  # maximum range at which we check for snapping...
  # so if colinear points are spaced more than twice this, we may miss snapping onto that interval
  #
  my $snapRange = ($spacing > 0) ? $snapStep * $spacing : 100;
  $snapRange  = 100 if ($snapRange > 100);

  # threshold for checking if points are close for snapping
  my $dsClose = $snapDistance / 2;

  # i is on the "earlier" segment, j on the "later" segment
  # note this excludes starting point and end point
 iLoop: for ( my $i = 0; $i < $#$points - 1; $i += $snapStep ) {
    my $p1 = $points->[$i];
    my @jCount;

    my $j = $i + $snapStep;
    next iLoop if ( $j > $#$points);

    # get out of snap range: get point j beyond the snap range of point i
    # this is geometric distance, not course distance, which could potentially be an issue
    my $d = 0;
    while ( ($d = latlngDistance( $p1, $points->[$j] ) ) <= $snapRange ) {
      $j += $snapStep;          # use big jumps to save time
      next iLoop if ($j >= $#$points);
    }

    # keep going until distance between j and i stops increasing
    while ( (my $d2 = latlngDistance( $p1, $points->[$j] ) ) >= $d ) {
      $d = $d2;
      $j += $snapStep;
      next iLoop if ($j >= $#$points);
    }

    # keep moving until j comes back into snap range of i
  jLoop1: while ( $j <= $#$points) {
      # make sure we don't try the same value twice (moving forward and backward could cause this)
      next iLoop
        if ($jCount[$j] ++);

      # looking for j sufficiently close to i and connected with less than a 30% slope
      # slope requirement avoids snapping across tight switchbacks or a hypothetical "spiral"
      while ((($d = latlngDistance( $p1, $points->[$j])) > $snapRange ) || (abs($p1->{ele} - $points->[$j]->{ele}) > $snapAltitude + 0.3 * $d)) {
        $j += $snapStep;
        next iLoop if ($j >= $#$points);
      }

      # find local minimum of distance... reduced step distance to 1
    jLoop2: while ( $j <= $#$points ) {
        $d = latlngDistance( $p1, $points->[$j] );
        # distance to point forward
        my $df = latlngDistance( $p1, $points->[$j + 1] )
          if ( $j < $#$points );
        # distance to point backward
        my $db = latlngDistance( $p1, $points->[$j - 1] )
          if ( $j > 0 );
        if ( (defined $df) && ($df < $d) ) {
          $j ++;
          next jLoop2;
        }
        if ( (defined $db) && ($db < $d) ) {
          $j --;
          next jLoop2;
        }
        last jLoop2;
      }


      # we've now brought point j close to point i.  This could be fooled with a sufficiently complicated
      # route, but so far it seems to work fairly well

      # check altitude.  If altitude is out of range, maybe we're across a tight swichback, or there's a bridge or tunnel
      # this was already done previously, but now we're closer
      if (abs($p1->{ele} - $points->[$j]->{ele}) > 1 + 0.3 * $d) {
        $j += $snapStep;
        next jLoop1;
      }

      #
      # we've got a possible point match between two points.
      # check dot products
      # the lines need to be in similar directions
      #
      # set direction for checking dot product
      my $di = 0;
      if (( $j < $#$points ) && ( $i < $#$points )) {
        $di = 1;
      } elsif (( $j > 0 ) && ( $i > 0 )) {
        $di = -1;
      } else {
        next iLoop;
      }
      my $p2 = $points->[$i + $di];
      my $p3 = $points->[$j];
      my $p4 = $points->[$j + $di];

      # dot product
      # dot product = 1: same direction
      # dot product = -1: opposite direction
      # dot product close to zero: intersection, perhaps -- ignore
      # set for 45 degree angle right now
      my $dot = latlngDotProduct($p1, $p2, $p3, $p4) // 0;
      my $sign;
      if ( $dot > 0.7 ) {
        $sign = 1;
      } elsif ($dot < -0.7 ) {
        $sign = -1;
      } else {
        # vectors are relatively perpendicular, move on
        $j += $snapStep;
        next jLoop1;
      }

      # point i is matched to point j, and the two are moving in the same direction
      # for each point j, if it falls on a line of points i, then replace the nearest point i

      # first we need to find values of j which are encapsulated by i
      # j will be replaced by i
      my ($ja, $jb);
    jLoop2: while(1) {
        # search range near j: j was point nearest i so it should be close
        # nearest found the nearest point, but we're looking for the segment,
        # and the nearest point may not mark the intersecting segment, so check proximity
        for my $ja ( $j, $j - $sign, $j + $sign, $j - 2 * $sign ) {
          $jb = $ja + $sign;

          # checking if point i falls on the line between ja and jb
          if (
              roadTest(
                       $points,
                       $ja - 1,
                       $ja,
                       $jb,
                       $jb + 1,
                       $i,
                       $snapDistance
                      )
             ) {
            $j = $jb;
            last jLoop2;
          }
        }
        # didn't find a match... move to next point
        next iLoop;
      }

      my $j1 = $j - $sign;
      my $j2 = $j;

      # starting point:
      # j1 ... i1 ... i2 ... j2
      # i's are encapsulated by j's
      # initial point is we have only a single point i1 = i2 = i
      # j2 = $j1 + 1
      # algorithm:
      # shift down i1 as long as it remains in range j1 .. j2....  and i1 >= 0
      # extend downward:
      #   1. test point: iTest = i1 - 1, jTest = j1... we know iTest is outside range j1 .. j2
      #   2. decrease jTest while iTest .. jTest .. i1 and jTest > i1
      #   3. decrease jTest if new jTest .. iTest .. j1
      #   4. if this was successful, then j1 = jTest, i1 = iTest
      #   5. shift down i1 as long as j1 .. i1 ... j1 + 1
      #   repeat until failure
      #
      # extend upward: similar, but up
      #   1. shift up i2 as long as it remains in range j1 .. j2....  and i2 <= j1

      my $i1 = $i;
      my $i2 = $i;

      # keep shifting boundaries until we don't expand them anymore
      my ($flag1, $flag2);

      do {
        # shift i1 down as long as along line from j1 to j2
        $i1 --
          while (
                 ($i1 > 0) &&
                 roadTest(
                          $points,
                          $j1 - $sign,
                          $j1,  # point 1
                          $j2,  # point 2
                          $j2 + $sign,
                          $i1 - 1, # test point
                          $snapDistance
                         )
                );

        # as long as they are coincident, increase i1 and j1 together (short cut)
        while ( ($i1 > 0) && ($j1 > $i2) && ($j1 < $#$points) && pointsAreClose($points->[$i1 - 1], $points->[$j1 - $sign], $dsClose, $snapAltitude) ) {
          $i1 --;
          $j1 -= $sign;
        }

        # shift up i2 down as along line from j1 to j2
        $i2 ++
          while (
                 ($i2 < $j1) &&
                 roadTest(
                          $points,
                          $j1 - $sign,
                          $j1,  # point 1
                          $j2,  # point 2
                          $j2 + $sign,
                          $i2 + 1, # test point
                          $snapDistance
                         )
                );

        # as long as they are coincident, increase i1 and j1 together (short cut)
        while ( ($i2 < $j1) && ($j2 > $i2) && ($j2 < $#$points) && pointsAreClose($points->[$i2 + 1], $points->[$j2 + $sign], $dsClose, $snapAltitude) ) {
          $i2 ++;
          $j2 += $sign;
        }

        $flag1 = 0;
        my $iTest = $i1 - 1;
        if ($iTest > 0) {

          # push jTest up against iTest
          my $jTest = $j1;
          $jTest -= $sign
            while (
                   ($jTest > $i2) &&
                   ($jTest < $#$points) &&
                   roadTest(
                            $points,
                            $iTest - 1,
                            $iTest,     # point 1
                            $iTest + 1, # point 2
                            $iTest + 2,
                            $jTest - $sign, # test point
                            $snapDistance
                           )
                  );

          # hop jTest past iTest: test that iTest lays in line of j points
          $jTest -= $sign
            if (
                ($jTest > $i2) &&
                ($jTest < $#$points) &&
                ($flag1 =
                 roadTest(
                          $points,
                          $jTest - 2 * $sign,
                          $jTest - $sign, # point 1
                          $jTest,         # point 2
                          $jTest + $sign,
                          $iTest, # test point
                          $snapDistance
                         )
                )
               );


          if ($flag1) {
            $j1 = $jTest;
            $i1 = $iTest;
          }
        }

        $flag2 = 0;
        $iTest = $i2 + 1;
        if ($iTest >= $j1) {
          my $jTest = $j2;

          # push jTest up against iTest (it's between j2 and jTest)
          $jTest += $sign
            while (
                   ($jTest > $iTest) &&
                   ($jTest < $#$points) &&
                   roadTest(
                            $points,
                            $iTest - 2,
                            $iTest - 1, # point 1
                            $iTest,     # point 2
                            $iTest + 1,
                            $jTest + $sign, # test point
                            $snapDistance
                           )
                  );
          # hop past iTest
          $jTest += $sign
            if (
                ($jTest > $iTest) &&
                ($jTest < $#$points) &&
                ($flag2 =
                 roadTest(
                          $points,
                          $jTest - $sign,
                          $jTest,         # point 1
                          $jTest + $sign, # point 2
                          $jTest + 2 * $sign,
                          $iTest, # test point
                          $snapDistance
                         )
                )
               );

          if ($flag2) {
            $j2 = $jTest;
            $i2 = $iTest;
          }
        }
      } while ($flag1 || $flag2);

      # splice in the snapped points
      # irange encapsulates j range
      # may need to retain outer points of j range if they're not duplicated by points in irange

      # avoid duplicate points at ends of range
      # this is the same independent of sign: i1 connects with j1, i2 connects with j2
      $i1 ++ while (($i1 < $i2) && pointsAreClose($points->[$i1], $points->[$j1]));
      $i2 -- while (($i2 > $i1) && pointsAreClose($points->[$i2], $points->[$j2]));

      if ($i1 >= $i2) {
        $j += $snapStep;
        next jLoop1;
      }

      die "zero sign encountered\n" if ($sign == 0);

      # now check for zig-zags at start... algorithm shouldn't allow them.
      while (1) {
        my $p1 = $points->[$j1];
        my $p2 = $points->[$i1];
        my $p3 = $points->[$i1 + 1];
        if ((defined $p1) && (defined $p2) && (defined $p3)) {
          my $dot = latlngDotProduct($p1, $p2, $p2, $p3);
          last if ((defined $dot) && ($dot > -0.9));
        }
        $i1 ++;
        if ($i1 >= $i2) {
          $j += $snapStep;
          next jLoop1;
        }
      }

      # now check for zig-zags at end... algorithm shouldn't allow them.
      while (1) {
        my $p1 = $points->[$j2];
        my $p2 = $points->[$i2];
        my $p3 = $points->[$i2 - 1];
        if ((defined $p1) && (defined $p2) && (defined $p3)) {
          my $dot = latlngDotProduct($p1, $p2, $p2, $p3);
          last if ((defined $dot) && ($dot > -0.9));
        }
        $i2 --;
        if ($i1 >= $i2) {
          $j += $snapStep;
          next jLoop1;
        }
      }

      if (($i2 > $i1) && (abs($j2 - $j1) > 0)) {
        note("i = $i, j = $j: snapping ", ($sign > 0) ? "forward" : "reverse", " segment: $i1 .. $i2 <=> $j1 .. $j2\n");

        my @pNew;
        if ( $sign > 0 ) {
          # keep everything up to start of j range
          @pNew = @$points[0 .. $j1];
          # splice in i range (exclude end-points)
          # try to match up segments if possible
          # segment matching by relative distance, but we need to nudge if we encounter a duplicate
          my $j = $j1;
          for my $i ( $i1 .. $i2 ) {
            $j ++ if (($j < $j2) && (abs($points->[$i]->{distance} - $points->[$i - 1]->{distance}) < 0.05));
            $j++
              while (
                     ($j < $j2) &&
                     (
                      abs(abs($points->[$j + 1]->{distance} - $points->[$j1]->{distance}) - abs($points->[$i]->{distance} - $points->[$i1]->{distance})) <
                      abs(abs($points->[$j]->{distance} - $points->[$j1]->{distance}) - abs($points->[$i]->{distance} - $points->[$i1]->{distance}))
                     )
                    );
            my %p = %{$points->[$i]};
            $p{segment} = $points->[$j]->{segment};
            push @pNew, \%p;
          }
          push @pNew, @$points[$j2 .. $#$points]; # keep everything which follows j range
        } else {
          @pNew = @$points[0 .. $j2];
          my $j = $j2;
          for my $i ( reverse($i1 .. $i2) ) {
            $j ++
              if (
                  ($j < $j1) &&
                  (abs($points->[$i]->{distance} - $points->[$i - 1]->{distance}) < 0.05)
                 );
            $j++
              while (
                     ($j < $j1) &&
                     (
                      abs(abs($points->[$j + 1]->{distance} - $points->[$j1]->{distance}) - abs($points->[$i]->{distance} - $points->[$i1]->{distance})) <
                      abs(abs($points->[$j]->{distance} - $points->[$j1]->{distance}) - abs($points->[$i]->{distance} - $points->[$i1]->{distance}))
                     )
                    );
            my %p = %{$points->[$i]};
            $p{segment} = $points->[$j]->{segment};
            push @pNew, \%p;
          }
          push @pNew, @$points[$j1 .. $#$points];
        }
        $points = \@pNew;
      }

      # snap transition...
      # adjust altitude...
      # the first pass goes from i1 to i2
      # the replaced portion goes from j3 to j4
      # for points beyond this range, transition the altitude
      # this presently does not work with loops
      if ( $snapTransition > 0 ) {
        my $j3 = (($sign > 0) ? $j1 : $j2) + 1;
        my $j4 = $j3 + $i2 - $i1 + 1;

        # d = 1: forward direction, -1: backard direction
        for my $d ( -1, 1 ) {
          my $s = 0;
          $i = ($d > 0) ? $i2 : $i1;
          my @sis = (0);
          my @is = ($i);
          while (($s < $snapTransition) && ($i > 0) && ($i < $#$points)) {
            $s += latlngDistance($points->[$i], $points->[$i + $d]);
            $i += $d;
            push @sis, $s;
            push @is, $i;
          }
          my $jd = $d * $sign;
          $j = ($jd > 0) ? $j4 : $j3;
          my @sjs = (0);
          my @js = ($j);

          $s = 0;
          while (($s < $snapTransition) && ($j > 0) && ($j < $#$points)) {
            $s += latlngDistance($points->[$j], $points->[$j + $jd]);
            $j += $jd;
            push @sjs, $s;
            push @js, $j;
          }
          # step thru and adjust altitudes
          my $u = 0;
          my $v = 0;
          my @zis   = ( $points->[$is[0]]->{ele} );
          my @zjs   = ( $points->[$js[0]]->{ele} );
          while (($u < $#sis) && ($v < $#sjs)) {
            my $i = $is[$u];
            my $j = $js[$v];
            if ($sis[$u + 1] < $sjs[$v + 1]) {
              $u ++;
              # interpolate the point onto the other interval
              my $f = ($sis[$u] - $sjs[$v]) / ($sjs[$v + 1] - $sjs[$v]);
              my $z0   = (1 - $f) * $points->[$js[$v]]->{ele} + $f * $points->[$js[$v + 1]]->{ele};
              # note: in limit of being close to the snapped section, altitude is average of two branches, then it diverges
              my $g = ( 1 + cos($pi * $sis[$u] / $snapTransition) ) / 4; # from 0.5 to 0
              die "negative g!" if ($g < 0);
              my $z1 = $points->[$is[$u]]->{ele};
              $zis[$u] = $g * $z0 + (1 - $g) * $z1;
            } else {
              $v ++;
              my $f = ($sjs[$v] - $sis[$u]) / ($sis[$u + 1] - $sis[$u]);
              my $z0   = (1 - $f) * $points->[$is[$u]]->{ele} + $f * $points->[$is[$u + 1]]->{ele};
              my $g = ( 1 + cos($pi * $sjs[$v] / $snapTransition) ) / 4; # from 0.5 to 0
              die "negative g!" if ($g < 0);
              # note: in limit of being close to the snapped section, altitude is average of two branches, then it diverges
              my $z1 = $points->[$js[$v]]->{ele};
              $zjs[$v] = $g * $z0 + (1 - $g) * $z1;
            }
          }

          # assign the new elevations to the appropriate points
          for my $u ( 0 .. $#zis ) {
            $points->[$is[$u]]->{ele} = $zis[$u];
          }
          for my $v ( 0 .. $#zjs ) {
            $points->[$js[$v]]->{ele} = $zjs[$v];
          }
        }
      }
      # end of snap transition

      # jump to next ivalue outside of range if we did replacement
      # this isn't perfect, but note points in j range are changed, so
      # j indices are no longer valid: this is why need to jump to outer loop
      $i = $i2 if ($i2 > $i);
      next iLoop;
    }
  }

  if ( $snap == 2 ) {
    @$points = reverse(@$points);
  }
  return $points;
}

#
# determines whether point p3 can be removed from segment p1 - p3 - p2
# without affecting path or altitude profile
#
sub isPointPrunable {
  my %var = @_;
  my ($p1, $p2, $p3) = @{$var{points}};
  my $dmax = $var{distance} // 2;
  my $X = $var{X}           // 0.001;
  my $dgmax = $var{dg}      // 0.001;
  die("isPointPrunable requires 3 points\n") unless (defined $p3);

  my ($x1, $y1) = latlng2dxdy( $p3, $p1);
  my ($x2, $y2) = latlng2dxdy( $p3, $p2);
  my ($x3, $y3) = (0, 0);
  my $z1 = $p1->{ele};
  my $z2 = $p2->{ele};
  my $z3 = $p3->{ele};
  my $s1 = $p1->{segment};
  my $s2 = $p2->{segment};
  my $s3 = $p3->{segment};

  # only prune points in the same segment
  return 0 unless (($s1 == $s2) && ($s2 == $s3));

  if (isPointOnRoad ( $p1, $p2, $p3, 1 ) ) {
    my $d13 = sqrt(($y3 - $y1) ** 2 + ($x3 - $x1) ** 2);
    my $d23 = sqrt(($y3 - $y2) ** 2 + ($x3 - $x2) ** 2);

    # duplicate points are not prunable
    return 0
      if ( ($d13 == 0) || ($d23 == 0) );

    # check gradient, and alignment
    my $dg =  ($z2 - $z3) / $d23 - ($z3 - $z1) / $d13;
    my $cross = crossProduct( [$x1, $y1], [$x3, $y3], [$x3, $y3], [$x2, $y2] );
    return ( (abs($dg) <= $dgmax) && (abs($cross) <= $X) );
  }
  return 0;
}

#
# simplifyPoints: similar to prune, but with alternative algorithm
# this is in principle recursive but take some steps to avoid trivial recursion
#
sub simplifyPoints {
  my %vars   = @_;
  my $z0 = $vars{z0} // 0.1;
  my $r0 = $vars{r0} // 1;
  my $points = $vars{points} // [];


  return $points if (@$points < 3);

  # search for segment boundaries
  for my $i ( 0 .. $#$points - 1 ) {
    if ($points->[$i]->{segment} != $points->[$i + 1]->{segment}) {
      my $p1 = simplifyPoints(points=> [@$points[0 .. $i]], z0 => $z0, r0 => $r0);
      my $p2 = simplifyPoints(points=> [@$points[$i + 1 .. $#$points]], z0 => $z0, r0 => $r0);
      return [@$p1, @$p2];
    }
  }

  # find the point of maximum deviation and recurse around that point
  # find distance between points and 3D line connecting endpoints
  my ($xf, $yf) = latlng2dxdy($points->[0], $points->[-1]);
  # if this point is too close to the first point, then find the furthest point and simplify on that
  if ($xf ** 2 + $yf ** 2 < 10) {
    my $iFurthest;
    my $dFurthest = 0;
    for my $i ( 1 .. $#$points - 1 ) {
      my $d = latlngDistance($points->[0], $points->[$i]);
      if ($d > $dFurthest) {
        $iFurthest = $i;
        $dFurthest = $d;
      }
    }
    if (defined $iFurthest) {
      my $p1 = simplifyPoints(points=> [@$points[0 .. $iFurthest]], z0 => $z0, r0 => $r0);
      my $p2 = simplifyPoints(points=> [@$points[$iFurthest + 1 .. $#$points]], z0 => $z0, r0 => $r0);
      return [@$p1, @$p2];
    } else {
      return $points;
    }
  }
  my $zi = $points->[0]->{ele};
  my $dzf = $points->[-1]->{ele} - $zi;
  my $iMax;
  my $scoreMax = 1;  # only accept points if score is at least 1
  for my $i ( 1 .. $#$points - 1 ) {
    my ($x, $y) = latlng2dxdy($points->[0], $points->[$i]);
    my $dz = $points->[$i]->{ele} - $zi;
    # find the nearest point on the curve
    my ($f, $d) = xyPointOnLine([0, 0], [$xf, $yf], [$x, $y]);  # distance of the interpolated point
    my $ddz = $dzf * $f - $dz;   # interpolated altitude difference
    my $score = ($d / $r0) ** 2 + ($ddz / $z0) ** 2;
    if ($score > $scoreMax) {
      $iMax = $i;
      $scoreMax = $score;
    }
  }
  if (defined $iMax) {
    my $p1 = simplifyPoints(points=> [@$points[0 .. $iMax]], z0 => $z0, r0 => $r0);
    my $p2 = simplifyPoints(points=> [@$points[$iMax .. $#$points]], z0 => $z0, r0 => $r0);
    return [@$p1, @$p2[1 .. $#$p2]];
  } else {
    return [$points->[0], $points->[-1]];
  }
}

#
# my heuristic bike speed model
# see https://djconnel.blogspot.com/2013/01/calibrating-heuristic-bike-speed-model.html
# extreme gradients: 1/3 gradient cuts speed 50%.
#
sub bikeSpeedModel {
  my %vars = @_;
  my $vMax   = $vars{vMax} // 17;
  my $VAMMax = $vars{VAMMax} // 0.53;
  my $v0     = $vars{v0} // 9.5;
  my $g      = $vars{g} // 0;
  # convert g to sine
  $g /= sqrt(1 + $g ** 2);
  my $a      = $vMax / $VAMMax;
  my $b      = $vMax / $v0 - $ln2;
  my $fV     = (1 + (3 * $g) ** 4) * ($b + log(1 + exp($a * $g)));
  return  $vMax / $fV;
}

#
# if there is a distance field, calculate the distance between points, which is more complicated
# on a loop course, which is why we need the total course distance
# this requires the distance field be already present.
#
sub distanceDifference {
  my $p1 = shift;
  my $p2 = shift;
  my $courseDistance = shift;
  my $isLoop = shift;
  die("distanceDifference called w/o distance field\n") unless ((defined $p1->{distance}) && (defined $p2->{distance}));
  my $d = $p2->{distance} - $p1->{distance};
  $d -= $courseDistance * floor($d / $courseDistance) if ($isLoop && ($courseDistance > 0)); # for loop courses
  return $d;
}
#
# separation of 2 points in course distance.... similar to distance difference but either direction
#
sub pointSeparation {
  my $p1 = shift;
  my $p2 = shift;
  my $courseDistance = shift;
  my $isLoop = shift;
  my $d = distanceDifference($p1, $p2, $courseDistance, $isLoop);
  if ($isLoop) {
    $d -= $courseDistance * floor(0.5 + $d / $courseDistance) if ($isLoop && ($courseDistance > 0)); # for loop courses
  }
  return abs($d);
}

#
# Fiets climb rating, modified
# Fiets is gradient times altitude
# this uses gradient to gradientPower times altitude (> 1 => more focus on gradient)
# gradient is normalized to 10%, so if the gradient averages 10%, the rating
# equals the altitude gain
#
sub climbRating {
  my %var = @_;
  my ($p1, $p2) = @{$var{points}};
  my $gradientPower = $var{gradientPower} // 2;
  my $courseDistance = $var{courseDistance};
  my $isLoop = $var{isLoop} // 0;
  my $dz = $p2->{ele} - $p1->{ele};
  my $ds = distanceDifference($p1, $p2, $courseDistance, $isLoop);
  return (($ds == 0) ? 0 : $dz * abs((10 * $dz / $ds)) ** $gradientPower);
}


#
# add automatic segments
#
sub addAutoSegments {
  my %var = @_;
  my $courseDistance = $var{courseDistance};
  my $gradientPower = ($var{gradientPower} // 2);
  my $isLoop = $var{isLoop};
  my $margin = $var{margin} // 400;
  my $finishMargin = $var{finishMargin} // 0;
  my $startMargin = $var{startMargin} // 0;
  my $names = $var{names};
  my $points = $var{points};
  my $segmentDefined = $var{segmentDefined} // {};
  my $segmentName = $var{segmentNames} // {};
  my $simplifyPoints = $var{simplifyPoints} // 1;
  my $stretch = $var{stretch};
  my $threshold = $var{threshold} // 100;
  note("creating auto-segments...\n");

  addDistanceField(points=> $points);
  $courseDistance //= calcCourseDistance(isLoop=> $isLoop, points=> $points);
  # these terms were important in RGT
  my $dMin = $startMargin;
  my $dMax = $courseDistance - $finishMargin;

  my @c =
    findClimbs(
               points => $points,
               courseDistance=> $courseDistance,
               simplifyPoints=> $simplifyPoints,
               shiftCircuit=> 0,
               gradientPower=> $gradientPower,
               threshold=> $threshold,
               isLoop=> $isLoop,
               sign=> 1,
              );

  # adjust margin for rounding error
  my $m = 0.999 * $margin;

  my @climbs = ();
  for my $c ( sort {$a->[0] <=> $b->[0]} @c ) {
    # if we are too close to the S or finish line, consider nudging the climb endpoints, if that
    # doesn't reduce the climb length too much
    my $d1 = $points->[$c->[0]]->{distance};
    my $d2 = $points->[$c->[1]]->{distance};
    my $L  = $d2 - $d1;

    if (($d1 < $dMin) && (($dMin - $d1) < 0.02 * $L)) {
      $c->[0] ++
        while (
               ($c->[0] < $c->[1] - 1) &&
               ($points->[$c->[0]]->{distance} < $dMin) &&
               ($points->[$c->[0] + 1]->{distance} - $d1 < 0.02 * $L)
              );
      note(sprintf("shifted start of climb from %.3f meters to %.3f meters to accomodate start margin\n", $d1, $points->[$c->[0]]->{distance}))
        if ($points->[$c->[0]]->{distance} > $d1);
      # add interpolation code here
    }

    if (($d2 > $dMax) && (($d2 - $dMax) < 0.02 * $L)) {
      $c->[1] --
        while (
               ($c->[1] > $c->[0] + 1) &&
               ($points->[$c->[1]]->{distance} > $dMax) &&
               ($d2 - $points->[$c->[1] - 1]->{distance} < 0.02 * $L)
              );
      note(sprintf("shifted end of climb from %.3f meters to %.3f meters to accomodate finish margin\n", $d2, $points->[$c->[1]]->{distance}))
        if ($points->[$c->[1]]->{distance} < $d2);
      # add interpolation code here
    }

    if (
        ( $points->[$c->[0]]->{distance} >= $dMin ) &&
        ( $points->[$c->[1]]->{distance} <= $dMax )
       ) {
      if ( (@climbs == 0) || ($points->[$c->[0]]->{distance} > $points->[$climbs[-1]->[1]]->{distance} + $m) ) {
        note(sprintf("autoSegments: identified climb from %.3f to %.3f km\n", $points->[$c->[0]]->{distance} / 1000, $points->[$c->[1]]->{distance} / 1000));
        push @climbs, $c;
      } else {
        warn("autoSegments: removing detected lower-rated climb due to inadequate margin to higher-rated adjacent climb.\n");
        # climb is too close to preceding climb: take the one with the higher rating
        my $r1 = climbRating(
                             points=> [$points->[$climbs[-1]->[0]], $points->[$climbs[-1]->[1]]],
                             gradientPower=> $gradientPower,
                             courseDistance=> $courseDistance,
                             isLoop => $isLoop,
                            );
        my $r2 = climbRating(
                             points=> [$points->[$c->[0]], $points->[$c->[1]]],
                             gradientPower=> $gradientPower,
                             courseDistance=> $courseDistance,
                             isLoop => $isLoop,
                            );
        if ($r2 < $r1) {
          pop @climbs;
          push @climbs, $c;
        }
      }
    }
  }

  #
  # insert climbs into points -- need to be a bit careful to not
  # create point triplets is fhte climb happens to begin/end on point pairs,
  # for example existing segment boundaries
  #
  my @newPoints = ();
  my $nS = 1;
  my $i0 = 0;
  my $i1 = 0;

  for my $nc ( 0 .. $#climbs ) {
    my $climb = $climbs[$nc];

    # maximum distance to shift points to find peak or valley
    my $d = $stretch * ($points->[$climb->[1]]->{distance} - $points->[$climb->[0]]->{distance});

    # see if we can find a point within the search distance which is an altitude minimum
    my $j0 = $climb->[0];
    my $j = $j0 - 1;
    while (
           ($j > 0) &&
           ($points->[$j]->{distance} > $points->[$j0]->{distance} - $d) &&
           (($points->[$j]->{distance} >= $dMin)) &&
           (($nc == 0) || ($points->[$j]->{distance} >= $points->[$climbs[$nc - 1]->[1]]->{distance} + $m))
          ) {
      if (($points->[$j + 1]->{ele} >  $points->[$j]->{ele}) &&
          ($points->[$j - 1]->{ele} >= $points->[$j]->{ele})
         ) {
        note(sprintf("autoSegments: extending climb start from %.3f to %.3f km\n", $points->[$climb->[0]]->{distance} / 1000, $points->[$j]->{distance} / 1000));
        $climb->[0] = $j;
        last;
      }
      $j --;
    }

    my $j1 = $climb->[1];
    $j = $j1 + 1;
    while (
           ($j < $#$points) &&
           ($points->[$j]->{distance} < $points->[$j1]->{distance} + $d) &&
           ($points->[$j]->{distance} <= $dMax) &&
           (($nc == $#climbs) || ($points->[$j]->{distance} <= $points->[$climbs[$nc + 1]->[0]]->{distance} - $m))
          ) {
      if (($points->[$j + 1]->{ele} <= $points->[$j]->{ele}) &&
          ($points->[$j - 1]->{ele} <  $points->[$j]->{ele})
         ) {
        note(sprintf("autoSegments: extending climb finish from %.3f to %.3f km\n", $points->[$climb->[1]]->{distance} / 1000, $points->[$j]->{distance} / 1000));
        $climb->[1] = $j;
        last;
      }
      $j ++;
    }

    $nS ++ while ($segmentDefined->{$nS});
    $segmentDefined->{$nS} ++;
    $segmentName->{$nS} = (defined $names->[$nc]) ? $names->[$nc] : ( (@climbs > 1) ? ("GPM " . ($nc + 1)) : "GPM" );

    # if the climb limits are at point pairs, move each to the appropriate point
    $climb->[0] ++ while ( ($climb->[0] < $climb->[1]) && ($points->[$climb->[0] + 1]->{distance} < $points->[$climb->[0]]->{distance} + 0.05) );
    $climb->[1] -- while ( ($climb->[1] > $climb->[0]) && ($points->[$climb->[1]]->{distance} < $points->[$climb->[1] - 1]->{distance} + 0.05) );

    # points up to the climb
    $i1 = $climb->[0] - 1;
    push @newPoints, @$points[$i0 .. $i1];

    # shift to the climb
    $i0 = $climb->[0];
    $i1 = $climb->[1];

    # we may need to create a copy of the first point of the climb
    if (($i0 > 0) && ($points->[$i0]->{distance} > $points->[$i0 - 1]->{distance} + 0.05)) {
      my %p = %{$points->[$i0]};
      push @newPoints, \%p;
    }

    # copy all of the points up to the final point in the climb
    my $s = $points->[$i1]->{segment};
    for my $i ( $i0 .. $i1 ) {
      if ( ( $i == $i0 ) || ($points->[$i]->{distance} > $points->[$i - 1]->{distance} + 0.05) ) {
        push @newPoints, $points->[$i];
        $points->[$i]->{segment} = $nS;
      }
    }

    # if the next point is not a pair with the last copied point, then duplicate the last point of the climb
    if ( ($i1 < $#$points) && ($points->[$i1 + 1]->{distance} > $points->[$i1]->{distance} + 0.05) ) {
      my %p = %{$points->[$i1]};
      $p{segment} = $s;
      push @newPoints, \%p;
    }

    # starting point for the next insertion
    $i0 = $i1 + 1;
  }

  # points following the last climb
  push @newPoints, @$points[$i0 .. $#$points];

  return \@newPoints;
}

#
# findClimbs
# a proc to return route portions which are climbs according to the algorithm
#
sub findClimbs {
  my %var = @_;
  my $points = $var{points};
  my $indices = $var{indices};
  my $simplifyPoints = $var{simplifyPoints} // 1;
  my $shiftCircuit = $var{shiftCircuit} // 1;
  my $courseDistance = $var{courseDistance};
  my $gradientPower = ($var{gradientPower} // 2);
  my $threshold = ($var{threshold} // 100);
  my $isLoop = $var{isLoop};
  my $sign = $var{sign} // 1; # sign: 1 for climbs, -1 for descents, 0 for both

  # minimum rating... units are meters ( @ 10% gradient)
  # this is normalized to 10% gradient,
  my $rating0 = $threshold;

  unless (defined $indices) {
    if ($simplifyPoints) {
      $indices = simplifyProfile($points, $gradientPower, $courseDistance, $isLoop);
    } else {
      $indices = [0 .. $#$points];
    }
  }

  # for circuits, we want to shift the points to the altitude minimum
  # no gradient signs will cross the altitude minimum on a loop
  if ($shiftCircuit) {
    # shift the points to the altitude minimum
    my $zMin = $points->[0]->{ele};
    my $izMin = 0;
    for my $i ( 1 .. $#$indices ) {
      if ($points->[$indices->[$i]]->{ele} < $zMin) {
        $zMin = $points->[$indices->[$i]]->{ele};
        $izMin = $i;
      }
    }
    if ($izMin > 0) {
      my @indices = @$indices[$izMin .. $#$indices];
      push @indices, @$indices[0 .. $izMin]; # repeat the first point
      $indices = \@indices;
    }
  }

  # find the segment of maximum Fiets
  my $rating = $rating0;
  my @range = ();
  for my $j ( 1 .. $#$indices ) {
    for my $i ( 0 .. $j - 1 ) {
      my $r = climbRating(
                          points=> [$points->[$indices->[$i]], $points->[$indices->[$j]]],
                          gradientPower=> $gradientPower,
                          courseDistance=> $courseDistance,
                          isLoop=> $isLoop
                         );
      if ($sign == 0) {
        $r = abs($r);
      } else {
        $r *= $sign;
      }
      if ($r > $rating) {
        @range = ($i, $j);
        $rating = $r;
      }
    }
  }

  my @climbs = ();
  if (@range) {
    push @climbs,
      findClimbs(
                 points => $points,
                 simplifyPoints=> 0,
                 courseDistance=> $courseDistance,
                 shiftCircuit=> 0,
                 gradientPower=> $gradientPower,
                 threshold=> $threshold,
                 isLoop=> $isLoop,
                 sign=> $sign,
                 indices=>  [ @$indices[0 .. $range[0]] ],
                )
      if ($range[0] > 0);

    my @climb = map { $indices->[$_] } @range;
    push @climbs, \@climb;

    push @climbs,
      findClimbs(
                 points => $points,
                 courseDistance=> $courseDistance,
                 simplifyPoints=> 0,
                 shiftCircuit=> 0,
                 gradientPower=> $gradientPower,
                 threshold=> $threshold,
                 isLoop=> $isLoop,
                 sign=> $sign,
                 indices=>  [ @$indices[$range[1] .. $#$indices] ],
                )
      if ($range[1] < $#$indices);
  }

  return @climbs;
}

#
# place gradient signs
# simplify profile, then find max Fiets segment, then recurse
#
sub placeGradientSigns {
  my %var = @_;
  my $points = $var{points};
  my $simplifyPoints = $var{simplifyPoints} // 1;
  my $shiftCircuit = $var{shiftCircuit} // 1;
  my $courseDistance = $var{courseDistance};
  my $gradientPower = ($var{gradientPower} // 2);
  my $threshold = ($var{threshold} // 100);
  my $isLoop = $var{isLoop};

  $courseDistance //= calcCourseDistance(isLoop=> $isLoop, points=> $points);

  note("placing gradient signs...\n");

  my @waypoints;

  my @climbs =
    findClimbs(
               points => $points,
               courseDistance=> $courseDistance,
               simplifyPoints=> $simplifyPoints,
               shiftCircuit=> $shiftCircuit,
               gradientPower=> $gradientPower,
               threshold=> $threshold,
               isLoop=> $isLoop,
               sign=> 0,
              );

  note("placeGradientSigns: number of climbs = ", scalar @climbs, "\n");

  my $nClimb = 0;
  for my $climb ( @climbs ) {
    $nClimb ++;
    my $ds = distanceDifference($points->[$climb->[0]], $points->[$climb->[1]], $courseDistance, $isLoop);
    my $dz = $points->[$climb->[1]]->{ele} - $points->[$climb->[0]]->{ele};
    my $g = $dz / $ds;
    my $text = sprintf("%.2f", 100 * $g) . "% for " . (($ds > 1000) ? sprintf("%.2f km", $ds / 1000) : sprintf("%d meters", $ds)) . " (" . sprintf("%.1f", $dz) . " m altitude)";
    note("gradient sign @ ", sprintf("%.2f", $points->[$climb->[0]]->{distance} / 1000), "km to ", sprintf("%.2f", $points->[$climb->[1]]->{distance} / 1000), " km: $text\n");

    push @waypoints,
      {
       lat   => $points->[$climb->[0]]->{lat},
       lon   => $points->[$climb->[0]]->{lon},
       ele   => $points->[$climb->[0]]->{ele},
       name  => "$text",
       cmt   => "$text",
       desc  => "$text",
       src   => "processGPX",
       sym   => "sign",
       type  => "sign",
       fix   => 'dgps',
      };
  }
  return \@waypoints;
}

#
# circle procs:
# fit a circle thru 3 points for replacing corners with circular sections
# this is designed for tracks like the Polo fields in San Francisco
#

# 3-point fit: takes (x, y) points and returns the center and the radius
# of a circle thru the points
sub circle3PointFit {
  my ($p1, $p2, $p3) = @_;

  # reference to first point
  my $x21 = $p2->[0] - $p1->[0];
  my $x31 = $p3->[0] - $p1->[0];
  my $y21 = $p2->[1] - $p1->[1];
  my $y31 = $p3->[1] - $p1->[1];

  # distances from first point
  my $rs21 = $x21 ** 2 + $y21 ** 2;
  my $rs31 = $x31 ** 2 + $y31 ** 2;
  my $denom = 2 * ($y21 * $x31 - $y31 * $x21);

  # linear
  return (undef, undef)
    if ($denom == 0);

  my $f = ( $rs31 * $x21 - $rs21 * $x31 ) / $denom;
  my $g = ( $rs21 * $y31 - $rs31 * $y21 ) / $denom;

  my $r = sqrt($f ** 2 + $g ** 2);
  my $x0 = $p1->[0] - $g;
  my $y0 = $p1->[1] - $f;

  my @p0;
  $p0[0] = $x0;
  $p0[1] = $y0;
  return(\@p0, $r);
}

#
# given a set of points, fit a circle to those points
# it does a 3-point fit thru the first and last points
# and the center point
#
sub fitCircle{
  my %var = @_;

  # points are (x, y, s)
  my $points = $var{points};

  my $p0 = $points->[0];
  my $pf = $points->[-1];
  my $s0 = $p0->[2];
  my $sf = $pf->[2];
  my $sMid = ($s0 + $sf) / 2;
  my $pMid;
  my $p1;
  for my $i ( 1 .. $#$points - 1 ) {
    $p1 = $points->[$i];
    last if ($points->[$i]->[2] > $sMid);
  }
  unless (defined $p1) {
    warn("insufficient points to fit circle!\n");
    return;
  }

  # fit analytic circle through points
  return circle3PointFit($p0, $p1, $pf);
}

sub processCircle {
  my %var = @_;

  my $points = $var{points};
  my $circle = $var{circle};
  my $circleStart = $var{circleStart};
  my $circleEnd = $var{circleEnd};
  my $isLoop = $var{isLoop} // 0;

  my @circles = ((defined $circle) ? @$circle : ());

  my @circleStarts = ();
  my @circleEnds = ();

  for (my $i = 0; $i < @circles;) {
    push @circleStarts, $circles[$i];
    $i ++;
    push @circleEnds, ( ($i < @circles) ? $circles[$i] : undef );
    $i ++;
  }

  my @a = (defined $circleStart) ? @$circleStart : ();
  my @b = (defined $circleEnd) ?  @$circleEnd : ();
  while (@a || @b) {
    push @circleStarts, shift @a;
    push @circleEnds, shift @b;
  }

  for my $iCircle ( 0 .. $#circleStarts ) {
    addDistanceField(points=> $points) unless (exists $points->[0]->{distance});

    note("fitting circle ", $iCircle + 1, " of ", scalar(@circleStarts), "\n");
    my $cStart = $circleStarts[$iCircle];
    my $cEnd = $circleEnds[$iCircle];
    next if (
             (! ( (defined $cStart) || (defined $cEnd) ) ) ||
             ((! $isLoop) && ($cStart >= $cEnd))
            );

    # get points to be replaced by circle
    my $iStart;
    if (defined $cStart) {
      my $i = 0;
      while ($points->[$i]->{distance} < $cStart) {
        $i ++;
        return if ($i > $#$points);
      }
      $iStart = $i;
    } else {
      $iStart = 0;
    }
    my $iEnd;
    if (defined $cEnd) {
      my $i = 0;
      while ($points->[$i + 1]->{distance} < $cEnd) {
        $i ++;
        return if ($i > $#$points);
      }
      $iEnd = $i;
    } else {
      $iEnd = $#$points;
    }

    # if we wrap around, then use a negative number for the start index
    $iStart -= @$points if ($iStart > $iEnd);

    # reference coordinates to first point
    my @xys = ( [0, 0, 0] );

    # offset distance
    my $d0 = $points->[$iStart]->{distance};

    for my $i ( $iStart + 1 .. $iEnd ) {

      # if we wrap around, adjust the distance offset
      $d0 -= $points->[-1]->{distance} if ($i == 0);

      my ($x, $y) = latlng2dxdy($points->[$iStart], $points->[$i]);
      push @xys, [$x, $y, $points->[$i]->{distance} - $d0];
    }

    # now we have a list of points and distances... create the circle
    my ($xyfit, $rCircle) = fitCircle(points=> \@xys);

    # check if we weren't able to fit circle (colinear points)
    die("ERROR fitting circle to points (check for colinearity)\n")
      unless ( (defined $xyfit) && (defined $rCircle) );

    # center is relative to first point.
    my $pCenter = addVectorToPoint($points->[$iStart], $xyfit);

    # for each point, adjust the radius to the center point to the fitted radius
    for my $i ( $iStart .. $iEnd ) {
      my $d = latlngDistance($points->[$i], $pCenter);
      my $f = $rCircle / $d;
      my ($dx, $dy) = latlng2dxdy($pCenter, $points->[$i]);
      my $pNew =  addVectorToPoint($pCenter, [$dx * $f, $dy * $f]);
      $points->[$i]->{lat} = $pNew->{lat};
      $points->[$i]->{lon} = $pNew->{lon};
      note("updating point $i ...\n");
    }
    # these fields are now invalid
    deleteField(points=> $points, field=> "distance");
    deleteField(points=> $points, field=> "heading") if (exists $points->[0]->{heading});
  }
}

#
# straighten points between indices
#
sub straightenPoints {
  my %var = @_;

  my $points = $var{points};
  my $iStart = $var{startIndex} // 0;
  my $iEnd   = $var{endIndex} // $#$points;
  my $isLoop = $var{isLoop} // 0;

  addDistanceField(points=> $points) unless (exists $points->[0]->{distance});

  return if (@$points < ($isLoop ? 4 : 3));

  # if we wrap around, then use a negative number for te start index
  $iStart -= @$points if ($iStart > $iEnd);

  # we need at least two intermediate points
  return if ($iEnd < $iStart + 2);

  # reference coordinates to first point
  my @xys = ( [0, 0, 0] );

  # offset distance
  my $d0 = $points->[$iStart]->{distance};

  my ($rx, $ry) = latlng2dxdy($points->[$iStart], $points->[$iEnd]);

  # if neither rx nor ry is nonzero, do nothing
  return if (($rx == 0) && ($ry == 0));
  my $r2 = $rx ** 2 + $ry ** 2;

  # for each point, find the projection of the point on the segment
  for my $i ( $iStart + 1 .. $iEnd - 1 ) {
    my ($dx, $dy) = latlng2dxdy($points->[$iStart], $points->[$i]);
    # find the projection onto the line
    # projection: r dot rLine / r
    my $f = ($dx * $rx + $dy * $ry) / $r2;
    my $pNew =  addVectorToPoint($points->[$iStart], [$rx * $f, $ry * $f]);
    $points->[$i]->{lat} = $pNew->{lat};
    $points->[$i]->{lon} = $pNew->{lon};
  }
}

#
# handle the straighten option, which is based on distances
#
sub processStraight {
  my %var = @_;

  my $points = $var{points};
  my $straight = $var{straight};
  my $straightStart = $var{straightStart};
  my $straightEnd = $var{straightEnd};
  my $isLoop = $var{isLoop} // 0;

  my @straights = ((defined $straight) ? @$straight : ());

  my @straightStarts = ();
  my @straightEnds = ();

  for (my $i = 0; $i < @straights;) {
    push @straightStarts, $straights[$i];
    $i ++;
    push @straightEnds, ( ($i < @straights) ? $straights[$i] : undef );
    $i ++;
  }

  my @a = (defined $straightStart) ? @$straightStart : ();
  my @b = (defined $straightEnd) ?  @$straightEnd : ();
  while (@a || @b) {
    push @straightStarts, shift @a;
    push @straightEnds, shift @b;
  }

  for my $iStraight ( 0 .. $#straightStarts ) {
    addDistanceField(points=> $points) unless (exists $points->[0]->{distance});

    note("fitting straight ", $iStraight + 1, " of ", scalar(@straightStarts), "\n");
    my $sStart = $straightStarts[$iStraight];
    my $sEnd = $straightEnds[$iStraight];
    next if (
             (! ( (defined $sStart) || (defined $sEnd) ) ) ||
             ((! $isLoop) && ($sStart >= $sEnd))
            );

    # get points to be replaced by straight
    my $iStart;
    if (defined $sStart) {
      my $i = 0;
      while ($points->[$i]->{distance} < $sStart) {
        $i ++;
        return if ($i > $#$points);
      }
      $iStart = $i;
    } else {
      $iStart = 0;
    }
    my $iEnd;
    if (defined $sEnd) {
      my $i = 0;
      while ($points->[$i + 1]->{distance} < $sEnd) {
        $i ++;
        return if ($i > $#$points);
      }
      $iEnd = $i;
    } else {
      $iEnd = $#$points;
    }

    straightenPoints( points=> $points, isLoop=> $isLoop, startIndex=> $iStart, endIndex=> $iEnd);
  }

  # these fields are now invalid
  deleteField(points=> $points, field=> "distance");
  deleteField(points=> $points, field=> "heading") if (exists $points->[0]->{heading});
}

#
# calculate deviation statistics for a range of points relative to connection of endpoints
#
sub calcDeviationStats {
  my ($points, $startIndex, $endIndex) = @_;

  my $max = 0;
  my $p1 = $points->[$startIndex % @$points];
  my $p2 = $points->[$endIndex % @$points];
  my $c = cos( ($p1->{lat} + $p2->{lat}) * $deg2rad / 2.0 );
  my $dx0 = ($p2->{lon} - $p1->{lon}) * $lat2y * $c;
  my $dy0 = ($p2->{lat} - $p1->{lat}) * $lat2y;
  my $L  = sqrt($dx0 ** 2 + $dy0 ** 2);
  return(0, 0, 0) if ((abs($L) < 0.001) || ($endIndex < $startIndex + 1));
  my $du0 = $dx0 / $L;
  my $dv0 = $dy0 / $L;
  my $sum = 0;
  my $sum2 = 0;
  for my $i ( $startIndex + 1 .. $endIndex - 1 ) {
    my $dx = ($points->[$i % @$points]->{lon} - $p1->{lon}) * $lat2y * $c;
    my $dy = ($points->[$i % @$points]->{lat} - $p1->{lat}) * $lat2y;
    # deviation to the right
    my $deviation = $dx * $dv0 - $dy * $du0;
    $sum += $deviation;
    $sum2 += $deviation ** 2;
    $max = abs($deviation) if (abs($deviation) > $max);
  }
  my $avg = $sum / ($endIndex - $startIndex - 1);
  my $rms = sqrt($sum2 / ($endIndex - $startIndex - 1));
  return ($avg, $max, $rms);
}

#
# automatically find segments to be straightened
# segments have a maximum deviation and also a check on
# the correlation of the deviations
# step through the route (perhaps with wrap-around for a loop)
# with first index at each point, a second index at the minimum
# length, keeping track of the maximum, rms, and average deviations
# if the minimum length meets the criteria, then extend the length
# until the criteria are broken, then jump to the endpoint
# and continue (straight segments cannot overlap)
#
sub autoStraighten {
  my %var = @_;

  my $points = $var{points};
  my $isLoop = $var{isLoop} // 0;
  my $minLength = $var{minLength};
  my $maxDeviation = $var{maxDeviation};
  my $courseDistance = $var{courseDistance} // calcCourseDistance(points=> $points, isLoop=> $isLoop);

  sub alignmentTest {
    my $points = shift;
    my $i = shift;
    my $j = shift;
    my $maxDeviation = shift;
    my ($avg, $max, $rms) = calcDeviationStats( $points, $i, $j );
    return (($max < $maxDeviation) && (abs($avg) < $maxDeviation / 4) && ($rms < $maxDeviation / 2));
  }

  my $j = 1;
  my $pointCount = 0;
 iLoop: for ( my $i = 0; $i <= $#$points; $i ++ ) {
    # keep point j ahead of i at min distance
    while ( ($j < $i + 2) || ($points->[$j]->{distance} + int($j / scalar(@$points)) * $courseDistance - $points->[$i]->{distance} < $minLength) ) {
      $j ++;

      # if we cannot get a segment long enough on point-to-point, we're too close to the finish
      last iLoop
        if (! ($isLoop || ($j <= $#$points)) );
    }

    # check if points meet the alignment test
    next iLoop unless (alignmentTest($points, $i, $j, $maxDeviation));

    # we've got a line: try to extend it
  kLoop: while (1) {
      my $k = $j + 1;
      last if ((! $isLoop) && ($k > $#$points));
      last kLoop unless (alignmentTest($points, $i, $k, $maxDeviation));
      $j = $k;
    }

    # see if we can improve the score by removing points from the ends
    # there's a tendency for the algorithm to extend the straight into turns, which affects
    # the direction of the straight, so try to back down on that
    my ($avg, $max, $rms) = calcDeviationStats( $points, $i, $j );
    my $L = latlngDistance($points->[$i % @$points], $points->[$j % @$points]);
  kLoop: while (1) {
      my $count = 0;
      my $k = $j - 1;
      last kLoop if ($k < $i + 2);
      if ((my $L2 = latlngDistance($points->[$i % @$points], $points->[$k % @$points])) > $minLength) {
        my ($avg2, $max2, $rms2) = calcDeviationStats( $points, $i, $k );
        if ($rms2 * $L < $rms * $L2) {
          $j = $k;
          $L = $L2;
          $avg = $avg2;
          $max = $max2;
          $rms = $rms2;
          $count ++;
        }
      }

      $k = $i + 1;
      last kLoop if ($k > $j - 2);
      if ((my $L2 = latlngDistance($points->[$k % @$points], $points->[$j % @$points])) > $minLength) {
        my ($avg2, $max2, $rms2) = calcDeviationStats( $points, $k, $j );
        if ($rms2 * $L < $rms * $L2) {
          $j = $k;
          $L = $L2;
          $avg = $avg2;
          $max = $max2;
          $rms = $rms2;
          $count ++;
        }
      }

      last kLoop if ($count == 0);
    }

    # we found a straight section!  Now straighten it, and start over with the last straightened point
    # this deletes the distance field
    straightenPoints( points=> $points, isLoop=> $isLoop, startIndex=> $i, endIndex=> $j);
    $pointCount += $j - $i - 2;

    # jump to end of straightened portion
    $i = $j;
  }

  # these fields are now invalid
  if ($pointCount > 0) {
    note("autoStraighten: total straightened points = $pointCount\n");
    deleteField(points=> $points, field=> "distance");
    deleteField(points=> $points, field=> "heading") if (exists $points->[0]->{heading});
  }
}


#
# circuitFromPosition:
# from the given point (distance from start)
#

sub circuitFromPosition {
  my %var = @_;

  my $points   = $var{points}   // [];
  my $position = $var{position} // 0;
  my $isLoop   = $var{isLoop} // 0;
  my $circuits = $var{circuits} // 0;
  $circuits = int($circuits);
  my $repeats  = $var{repeats} // 1;
  $repeats = int($repeats);

  if ($repeats <= 0) {
    warn("CircuitFromPosition called with non-poisitive repeats -- ignoring option.\n");
    return $points;
  }

  my $startIndex;
  ($points, $startIndex) = pointAtPosition( $position, $points, $isLoop );
  return $points unless (defined $startIndex);

  # search ahead for next point close to this point
  # search on invervals
  my $stopIndex = ($isLoop) ? $startIndex : $#$points;
  warn("startIndex = $startIndex; stopIndex = $stopIndex\n");

  my $p0 = $points->[$startIndex];

  my $flag = 0;
  my $count = 0;
  for (my $i = ($startIndex + 1) % @$points; $i != $stopIndex;) {
    my $p1 = $points->[$i];
    my $index = $i;

    $i = ($i + 1) % @$points;

    # for a circuit, we need to get at least a nominal distance from the first point
    unless ($flag) {
      next if (pointsAreClose($points->[$startIndex], $points->[$index], 25));
      $flag = 1;
    }

    my $p2 = $points->[$i];

    next if (pointsAreClose($p1, $p2));

    my $pMatch;
    if ( isPointOnRoad($p1, $p2, $p0) ) {
      # the start point falls ont he segment from p1 to p2, so the circuit ends at p1
      $count ++;
      if ($count >= $repeats) {
        # circuit identified with the required number of counts
        # circuit goes from startIndex to endIUndex inclusive
        my $endIndex = $index;
        my @pNew;
        push @pNew, @$points[0 .. $startIndex - 1] if ($endIndex > $startIndex);  # add points at start if not part of circuit
        for my $c ( 1 .. $circuits ) {
          for (my $j = $startIndex; $j != $endIndex; $j = ($j + 1) % @$points) {
            my $p;
            if ($c == 1) {
              $p = $points->[$j];
            } else {
              my %p = %{$points->[$j]};
              $p = \%p;
            }
            push @pNew, $p;
          }
        }
        push @pNew, @$points[$endIndex + 1 .. $#$points] if ($endIndex > $startIndex);  # add points at end if not part of circuit
        deleteDerivedFields(\@pNew);
        return \@pNew;
      }
    }
  }

  # nothing found: return original points
  warn("warning: no circuit found at position $position with $repeats point crossing", ($repeats > 1) ? "s" : "", ".\n");
  return $points;
}

#
#
# shiftCircuit: shift a circuit to start at a particular point
#
sub shiftCircuit {
  my $points = shift;
  my $startIndex = shift;
  my $copyPoint = pointsAreClose($points->[-1], $points->[0]) && ($points->[-1]->{segment} eq $points->[0]->{segment});
  my $lastPoint = $copyPoint ? $#$points - 1 : $#$points;
  my @newPoints = @$points[$startIndex .. $lastPoint];
  push @newPoints, @$points[0 .. $startIndex - 1];
  push @newPoints, \%{$newPoints[0]} if $copyPoint;

  return \@newPoints;
}

#
# simplify profile for placing gradient signs
# makes sure max, min points are included, as well as first, last points
# this takes a list of points and point indices,
#

sub simplifyProfile {
  my $points = shift;
  my $gradientPower = shift;
  my $courseDistance = shift;
  my $isLoop = shift;
  my $file = shift // "-";
  my $indices = shift // [0 .. $#$points];

  my @indicesNew = ( $indices->[0] );
  my @keypoints = (0);
  for my $i ( 1 .. $#$indices - 1 ) {
    if (
        ( $points->[$indices->[$i - 1]]->{ele} <=> $points->[$indices->[$i]]->{ele} ) !=
        ( $points->[$indices->[$i]]->{ele} <=> $points->[$indices->[$i + 1]]->{ele} )
      ) {
      push @keypoints, $i;

      # simplifying the monotonic profile: is guaranteed to return the last point, but may add intermediate points
      push @indicesNew, @{simplifyMonotonicProfile( $points, $courseDistance, $gradientPower, $isLoop, [ @$indices[$keypoints[-2] .. $keypoints[-1]]] )};
    }
  }
  push @indicesNew, @{simplifyMonotonicProfile( $points, $courseDistance, $gradientPower, $isLoop, [ @$indices[$keypoints[-1] .. $#$indices]] )};

  my $saveSimplifiedProfile  = 0;
  if ( $saveSimplifiedProfile ) {
    open my $fprofile,  ">/tmp/simplifiedProfile.csv";
    print $fprofile "n,index,lat,lng,s,z\n";
    for my $i ( 0 .. $#indicesNew ) {
      print $fprofile "$i,$indicesNew[$i],$points->[$indicesNew[$i]]->{lat},$points->[$indicesNew[$i]]->{lon},$points->[$indicesNew[$i]]->{distance},$points->[$indicesNew[$i]]->{ele}\n";
    }
    close $fprofile;
  }

  return \@indicesNew;
}

#
# add distance field to points
#
sub addDistanceField {
  my %var =@_;
  my $points = $var{points} // [];

  return unless (@$points);
  $points->[0]->{distance} = 0;
  for my $i ( 1 .. $#$points ) {
    $points->[$i]->{distance} = $points->[$i - 1]->{distance}  + latlngDistance($points->[$i - 1], $points->[$i]);
  }
}

#
# calculate a gradient from altitude
#
sub addGradientField {
  my %var = @_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop} // 0;
  return unless (@$points);
  addDistanceField(points=> $points) unless ((defined $points->[0]->{distance}) && (defined $points->[-1]->{distance}));
  my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);
  my $i = 0;
  my $iMax = $#$points;
  while ($i <= $iMax) {
    my $p1 = $points->[$i];
    my $j = ($i + 1) % @$points;
    my $di = $p1->{distance};
    $j = (($j + 1) % @$points)  while ( ($j != $i) && abs(distanceDifference($p1, $points->[$j], $courseDistance, $isLoop)) < 0.1 );
    last if ( ($j <= $i)  && (! $isLoop) );
    my $p2 = $points->[$j];
    $p1->{gradient} = ($p2->{ele} - $p1->{ele}) / distanceDifference($p1, $p2, $courseDistance, $isLoop);
    $i ++;
  }
  if ($i > 0) {
    while ($i <= $iMax) {
      $points->[$i]->{gradient} = $points->[$i - 1]->{gradient};
      $i ++;
    }
  }
}

#
# integrate gradient to get altitude
#
sub integrateGradientField {
  note("integrating gradient to update altitude...\n");
  my %var = @_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop} // 0;
  return unless (@$points && (defined $points->[0]->{gradient}));
  addDistanceField(points=> $points) unless ((defined $points->[0]->{distance}) && (defined $points->[-1]->{distance}));
  my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);
  my $i = 0;
  my $iMax = $#$points;
  $points->[0]->{ele} //= 0;       # default initial ele (this should never be necessary)
  my $zLast = $points->[$isLoop ? 0 : -1]->{ele};   # remember last altitude
  while ($i < $iMax) {
    my $p1 = $points->[$i];
    my $j = ($i + 1) % @$points;
    my $di = $p1->{distance};
    last if ( ($j <= $i)  && (! $isLoop) );
    my $p2 = $points->[$j];
    $p2->{ele} = $p1->{ele} + $p1->{gradient} * distanceDifference($p1, $p2, $courseDistance, $isLoop);
    $i ++;
  }
  # adjust altitude to match net climbing
  my $deltaZ = $zLast - ($points->[-1]->{ele} + ($isLoop ? $points->[-1]->{gradient} * ($courseDistance - $points->[-1]->{distance}) : 0));
  for my $p ( @$points ) {
    $p->{ele} += $deltaZ * $p->{distance} / $points->[-1]->{distance};
  }
}

#
# add direction field to points
#
sub addDirectionField {
  my %var =@_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop} // 0;
  return unless (@$points);
  my $u = ($isLoop ? $#$points : 0);
  my $v = 0;
  my $w = 1;
  my $dPrev;
  while ($v <= $#$points) {
    $u = $v;
    $w = $v;
    while (pointsAreClose($points->[$u], $points->[$v])) {
      if ($isLoop ? ((($u - 1) % @$points) != $w) : ($u > 0)) {
        $u = ($u - 1) % @$points;
      } else {
        $u = $v;
        last;
      }
    }
    while (pointsAreClose($points->[$w], $points->[$v])) {
      if ($isLoop ? ((($w + 1) % @$points) != $u) : ($w < $#$points)) {
        $w = ($w + 1) % @$points;
      } else {
        $w = $v;
        last;
      }
    }
    my $d = $dPrev // 0;
    if ($u == $v) {
      if ($v != $w) {
        $d = latlngDirection($points->[$v], $points->[$w]);
      }
    } else {
      if ($v == $w) {
        $d = latlngDirection($points->[$u], $points->[$v]);
      } else {
        $d = pointDirection($points->[$u], $points->[$v], $points->[$w]);
      }
    }
    $d = $dPrev + reduceAngle($d - $dPrev) if (defined $dPrev);
    $dPrev = $d;
    $points->[$v]->{heading} = $d;
    $v ++;
  }
}

#
# add curvature field to points
# curvature = rate of change of direction / distance
#
sub addCurvatureField {
  my %var =@_;
  my $points = $var{points} // [];
  return unless (@$points);
  my $isLoop = $var{isLoop} // 0;
  my $vMin = 0;
  my $vMax = $#$points;
  unless ($isLoop) {
    $points->[$vMin ++]->{curvature} = 0;
    $points->[$vMax --]->{curvature} = 0;
  }
  my $v = $vMin;
  my $dPrev;
  while ($v <= $vMax) {
    my $u = ($v - 1) % @$points;
    my $w = ($v + 1) % @$points;
    while (pointsAreClose($points->[$u], $points->[$v])) {
      if ($isLoop ? ((($u - 1) % @$points) != $w) : ($u > 0)) {
        $u = ($u - 1) % @$points;
      } else {
        $u = $v;
        last;
      }
    }
    while (pointsAreClose($points->[$w], $points->[$v])) {
      if ($isLoop ? ((($w + 1) % @$points) != $u) : ($w < $#$points)) {
        $w = ($w + 1) % @$points;
      } else {
        $w = $v;
        last;
      }
    }
    if (($u == $v) || ($u == $w)) {
      $points->[$v]->{curvature} = 0;
      next;
    }
    $dPrev //= latlngDirection($points->[$u], $points->[$v]);
    my $d = latlngDirection($points->[$v], $points->[$w]);
    $points->[$v]->{curvature} = 2 * deltaAngle($dPrev, $d) / (latlngDistance($points->[$u], $points->[$v]) + latlngDistance($points->[$v], $points->[$w]));
    $dPrev = $d;
    $v ++;
  }
}

#
# calculate the net course distance
# need to "wrap around" for lapped courses
#
sub calcCourseDistance {
  my %var = @_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop};
  return 0 unless @$points;
  addDistanceField(points=> $points)
    unless (defined $points->[-1]->{distance});
  my $distance = $points->[-1]->{distance};
  $distance += latlngDistance($points->[-1], $points->[0])
    if ($isLoop && @$points > 1);
  return $distance;
}

#
# delete a field from the points
#
sub deleteField {
  my %var = @_;
  my $field = $var{field};
  my $points = $var{points} // [];
  return unless (defined $field);
  for my $p ( @$points ) {
    delete $p->{$field} if (exists $p->{$field});
  }
}

#
# delete an extension field
#
sub deleteExtensionField {
  my %var = @_;
  my $field = $var{field};
  my $points = $var{points} // [];
  return unless (defined $field);
  for my $p ( @$points ) {
    delete $p->{extensions}->{$field} if ((ref $p->{extensions} eq "HASH") && (exists $p->{extensions}->{$field}));
  }
}

#
# delete field/or and any extension
#
sub deleteField2 {
  my %var = @_;
  my $field = $var{field};
  my $points = $var{points} // [];
  deleteField(field=> $field, points=> $points);
  deleteExtensionField(field=> $field, points=> $points);
}

#
# strip fields which are derived: needed if route has been changed by processing
#
sub deleteDerivedFields {
  my $points = shift;
  my $fields = shift // ["curvature", "distance", "gradient", "heading"];
  for my $f ( @$fields ) {
    deleteField2(points=> $points, field=> $f);
  }
}

#
# reverse points and adjust distance, direction, curvature and laneshift fields, if present
#
sub reversePoints {
  for my $points ( @_ ) {
    @$points = reverse @$points;
    next unless (@$points);
    if (exists $points->[0]->{distance}) {
      my $dLast = $points->[-1]->{distance};
      for my $p ( @$points ) {
        $p->{distance} = $dLast - $p->{distance};
      }
    }
    foreach my $f ( "heading", "curvature", "laneShift" ) {
      if (exists $points->[0]->{$f}) {
        for my $p ( @$points ) {
          $p->{$f} = -$p->{$f};
        }
      }
    }
  }
}

#
# crop points
#
sub cropPoints {
  my %vars = @_;
  my $points = $vars{points} // die;
  my $cropMin = $vars{min};
  my $cropMax = $vars{max};
  my $deleteRange = $vars{deleteRange} // [];
  my $isLoop = $vars{isLoop} // 0;

  my @ranges = ();

  my $courseDistance = calcCourseDistance(points=>$points, isLoop=> $isLoop);

  # if cropMin and cropMax are reversed, treat them as a delete range
  if ((defined $cropMin) && (defined $cropMax) && ($cropMax < $cropMin)) {
    push @ranges, [$cropMax, $cropMin];
    undef $cropMin;
    undef $cropMax;
  }

  for (my $i = 0; $i < $#$deleteRange;) {
    my $r1 = $deleteRange->[$i ++];
    my $r2 = $deleteRange->[$i ++];

    # points reversed: acts like cropMin, cropMax
    if ((! (defined $r1)) || (! (defined $r2)) || ($r2 < $r1)) {
      $cropMax = $r1 if ((defined $r1) && ((! defined $cropMax) || ($r1 < $cropMax)));
      $cropMin = $r2 if ((defined $r2) && ((! defined $cropMin) || ($r2 > $cropMin)));
    } else {
      # check to see if range overlaps beginning or end of the course
      my $s1 = $points->[0]->{distance};
      $s1 = $cropMin if ((defined $cropMin) && ($cropMin > $s1));
      my $s2 = $courseDistance;
      $s2 = $cropMax if ((defined $cropMax) && ($cropMax < $s2));

      # skip if range outside of course
      next if ((($r1 < $s1) && ($r2 < $s1)) || (($r1 > $s2) && ($r2 > $s2)));

      # adjust crop limits if range overlaps edge of course
      my $overlap = 0;
      if ($r1 < $s1) {
        $cropMin = $r2;
        $overlap ++;
      }
      if ($r2 > $s2) {
        $cropMax = $r1;
        $overlap ++;
      }
      next if ($overlap);

      # check if existing points overlap any ranges so far
    doOverlaps: while(1) {
        for my $j ( 0 .. $#ranges ) {
          my $r = $ranges[$j];
          my $r3 = $r->[0];
          my $r4 = $r->[1];

          my $overlap = 0;
          # new range straddles beginning of old range: extend start of old range
          if (($r1 < $r3) && ($r2 > $r3)) {
            # new range overlaps first point in existing range
            $overlap ++;
            # possibly extend existing range
            $r2 = $r4 if ($r4 > $r2);
          } elsif (($r2 < $r4) && ($r2 > $r4)) {
            # extend existing range
            $r1 = $r3;
            $overlap ++;
          }
          # if overlap, then delete the existing range
          if ($overlap) {
            splice(@ranges, $j, 1);
            next doOverlaps;
          }
        }
        last doOverlaps;
      }
      push @ranges, [$r1, $r2];
    }
  }
  note("cropping ", (defined $cropMin) ? "from $cropMin " : "", (defined $cropMax) ? "to $cropMax " : "", "meters...\n")
    if ((defined $cropMin) || (defined $cropMax));

  for my $r ( @ranges ) {
    note("deleting range from $r->[0] meters to $r->[1] meters.\n");
  }

  # interpolate needed points
  # if this is cropMin, this may be followed by including the point
  # if this is cropMax, then the point will be excluded
  my @interpolatePoints;
  for my $s ( $cropMin, $cropMax ) {
    push @interpolatePoints, $s if (defined $s);
  }
  for my $r ( @ranges ) {
    for my $j ( 0, 1 ) {
      push @interpolatePoints, $r->[$j] if (defined $r->[$j]);
    }
  }

  my @pNew = ();
  my $s;
 pointLoop: for my $i ( 0 .. $#$points ) {
    my $p = $points->[$i];
    my $sPrev = $s;
    $s = $p->{distance};

    for my $s0 ( @interpolatePoints ) {
      if ( ($i > 0) && ($s0 > 0) && ($s > $s0) && ($sPrev < $s0) ) {
        my $ds = $s - $sPrev;
        my $f = ($s0 - $sPrev) / $ds;
        my $d1 = $f * $ds;
        my $d2 = (1 - $f) * $ds;
        if (($d1 > 0.01) && ($d2 > 0.01)) {
          push @pNew, interpolatePoint($points->[$i - 1], $p, $f);
        }
      }
    }

    next pointLoop if ((defined $cropMin) && ($s < $cropMin));
    next pointLoop if ((defined $cropMax) && ($s > $cropMax));
    for my $r ( @ranges ) {
      next pointLoop if (($s > $r->[0]) && ($s < $r->[1]));
    }

    push @pNew, $p;
  }

  deleteDerivedFields(\@pNew);
  return \@pNew;
}

#
# UTurnCheck
# check whether p1->p2 and p3->p4 are in the opposite cirection
#

sub UTurnCheck {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $p4 = shift;
  my $dotMax = shift // -0.98;
  my $d = latlngDotProduct($p1, $p2, $p3, $p4);
  return ((defined $d) && ($d < $dotMax));
}

#
# make a loop of turn radius R from specified point in direction d with appropriate shift
# shift is the amount the point has been moved left or right
# if a second point is provided, then use that to calculate the shift, and optionally direction
#
# loop consists of semi-circles of appropriate radius
# 1. opening semi-circle
# 2. main semi-circle
# 3. closing semi-circle
#

sub makeLoop {
  my %var = @_;
  my $points = $var{points};
  my $direction = $var{direction};
  my $sign = $var{defaultSign} // 1;
  my $radius = $var{radius} // 4;
  my $segmentName = $var{segmentNames} // {};

  # if radius is negative, swap the direction
  if ($radius < 0) {
    $radius = -$radius;
    $sign = -$sign;
  }

  die("makeLoop requires a reference to a list of two points.\n")
    unless ((defined $points) && ((ref $points) eq "ARRAY") && (@$points > 1));
  die("makeLoop requires a direction parameter\n")
    unless (defined $direction);
  my $cdir = cos($direction);
  my $sdir = sin($direction);

  my ($point1, $point2) = @$points;

  # loop points
  my @pLoop = ();

  # loop eventually goes from point1 to point2
  # but this may require a shear

  #
  # calculate distance of the two paths,where a left turn is positive,
  # a right turn is negative.  This is twice the "laneShift", for example
  #
  my ($dx, $dy) = latlng2dxdy($point1, $point2);
  my $ds = sqrt($dx ** 2 + $dy ** 2);
  my $d = 0;
  if ($ds > 0.01) {
    # the original route is along direction dir (c, s)
    # so I need the end point along the orthogonal direction (-s, c)
    # it's along the direction perpendicular, but proportional to dot product
    $d = (-$sdir * $dx + $cdir * $dy);
    # check this... (all pass)
    # if c = 1, s = 0, dy = R, dx = 0 : d = R
    # if c = 1, s = 0, dx = R, dy = 0 : d = 0
    # if s = 1, c = 0, dy = R, dx = 0 : d = 0
    # if s = 1, c = 0, dx = R, dy = 0 : d = -R
  }

  #
  # make loop from point to reverse direction with specified shift
  #
  my $lat0 = ( $point1->{lat} + $point2->{lat} ) / 2;
  my $lng0 = ( $point1->{lon} + $point2->{lon} ) / 2;
  my $delta = abs($d / 2);
  $sign = ($d <=> 0) if ($delta > 0.1); # override sign if the points are separate (L or R turn)

  # generate points.... rotated coordinates
  my (@xs, @ys);
  my $cosTheta = ($radius + $delta) / (2 * $radius);

  # if cos theta > 1, then we'll generate a circle, but stretch it later
  my $theta;
  my $stretch;
  if ($cosTheta > 1) {
    $theta = 0;
    $stretch = $delta / $radius;
  } else {
    $theta = atan2(sqrt(1 - $cosTheta ** 2), $cosTheta);
    $stretch = 1;
  }

  my $dThetaMax = $twopi / (16 * (1 +sqrt( abs($radius / 4) )));

  # arc going into the circle
  # first point (delta, 0)
  # last point  (-delta, 0)
  my $nPoints = 1 + floor($theta / $dThetaMax);
  for my $i ( 1 .. $nPoints ) {
    my $t = $theta * $i / $nPoints;
    my $x = $radius + $delta - $radius * cos($t);
    my $y = $radius * sin($t);
    push @xs, $x;
    push @ys, $y;
  }

  # semi-circle
  my $theta2 = $theta + $pi / 2;
  $nPoints = 1 + floor($stretch ** (2/3) * $theta2 / $dThetaMax);
  for my $i ( 1 .. $nPoints ) {
    my $t = ($nPoints - $i) * $theta2 / $nPoints;
    my $x = $radius * sin($t);
    my $y = 2 * $radius * sin($theta) + $radius * cos($t);
    push @xs, $x;
    push @ys, $y;
  }

  # stretch points if separation exxceeds target turn radius
  for my $i ( 1 .. $#xs ) {
    $xs[$i] *= $stretch;
  }

  # swap x points if we're "driving on the left"
  if ( $sign < 0 ) {
    for my $i ( 0 .. $#xs ) {
      $xs[$i] = -$xs[$i];
    }
  }

  # finish route
  for (my $i = $#xs - 1; $i >= 0; $i -- ) {
    push @xs, -$xs[$i];
    push @ys, $ys[$i];
  }

  # shear to align
  # point1 => point2 : dx, dy
  # point1 => origin:: -s, +c
  my $u = ($delta == 0) ? 0 : ($dx / (2 * $delta)) ** 2 + ($dy / (2 * $delta)) ** 2 - 1;
  my $shear = ($delta == 0) ? 0 : ($u > 0) ? sqrt($u) : 0;
  $shear *= -$sign * (($cdir * $dx + $sdir * $dy) <=> 0);

  # transform to direction, adding shear transformation first
  # original road is aligned in direction dir
  # this is aligned in direction 90 degrees
  # need to rotate by dir - 90 deg
  # also calculate distance
  for my $i ( 0 .. $#xs ) {
    $ys[$i] += $shear * $xs[$i];
    my $x = $ sdir * $xs[$i] + $cdir * $ys[$i];
    my $y = -$cdir * $xs[$i] + $sdir * $ys[$i];
    $xs[$i] = $x;
    $ys[$i] = $y;
  }

  # convert to lat, lng
  my $c = cos($deg2rad * $lat0);
  for my $i ( 0 .. $#xs ) {
    my %h = %$point1;
    $h{lon} = $lng0 + $xs[$i] / ($lat2y * $c);
    $h{lat} = $lat0 + $ys[$i] / $lat2y;
    push @pLoop, \%h;
  }

  # may need to set segment
  if ( $point1->{segment} != $point2->{segment} ) {
    if ( defined $segmentName->{$point1->{segment}} ) {
      my $s = (defined $segmentName->{$point2->{segment}}) ? 0 : $point2->{segment};
      my %p = %$point1;
      unshift @pLoop, \%p;

      for my $p ( @pLoop ) {
        $p->{segment} = $s;
      }
    }

    if ($pLoop[-1]->{segment} != $point2->{segment}) {
      my %p = %$point2;
      $p{segment} = $pLoop[-1]->{segment};
      push @pLoop, \%p;
    }
  }

  # create a distance field
  my @ss = ( latlngDistance($point1, $pLoop[0]) );
  for my $i ( 0 .. $#pLoop - 1 ) {
    push @ss, $ss[-1] + latlngDistance($pLoop[$i], $pLoop[$i + 1]);
  }
  my $sLoop = $ss[-1] + latlngDistance($pLoop[-1], $point2);

  # interpolate elevation
  for my $i ( 0 .. $#pLoop ) {
    $pLoop[$i]->{ele} = ($point1->{ele} * ($sLoop - $ss[$i]) + $point2->{ele} * $ss[$i]) / $sLoop;
  }

  return \@pLoop;
}

#
# split route into parts separated by points
# allocate space for start and finish
# each split
# only points within the coursedistance are counted
#
sub splitPoints {
  my %var = @_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop} // 0;
  my $courseDistance = $var{courseDistance} // calcCourseDistance(points=> $points, isLoop=> $isLoop);
  my $startZone = $var{startZone} // 0;
  my $finishZone = $var{finishZone} // 0;
  my $splitDistance = $var{splitDistance} // [];
  my $minSplitLength = $var{minSplitLength} // 10;
  my $splitNumber = $var{splitNumber} // 0;

  # filter out split pairs which are too close to each other

  # we start with the first point in the loop, but we allow wrap-around on loop courses
  my @sp = (0);
  for my $s ( sort {$a <=> $b} grep { ($_ > $minSplitLength) && ($isLoop || ($_ < $courseDistance - $minSplitLength)) } @$splitDistance ) {
    push @sp, $s if ($s > $sp[-1] + $startZone + $finishZone + $minSplitLength);
  }

  # last point is end of GPX on a point-to-point, or to complete the loop on a circuit
  push @sp, $courseDistance + ($isLoop ? $startZone + $finishZone : 0);

  # if multi-lap is supported
  $sp[-1] += $courseDistance * ceil(($sp[-2] - $sp[-1]) / $courseDistance)
    if ($isLoop && (@sp > 1) && ($sp[-1] < $sp[-2]));

  addDistanceField(points=> $points, isLoop=> $isLoop);

  my @splits = ();
  for (my $i = 0; $i < $#sp;) {
    my $s1 = $sp[$i] - $startZone;
    $i ++;
    next if ((defined $splitNumber) && ($splitNumber > 0) && ($i != $splitNumber));
    my $s2 = $sp[$i] + $finishZone;
    my $i1;
    my $i2;
    if ($s1 <= $points->[0]->{distance}) {
      $i1 = 0;
    } else {
      my $nLap = floor($s1 / $courseDistance);
      ($points, $i1) = pointAtPosition($s1 - $courseDistance * $nLap, $points, $isLoop);
      die("ERROR: unable to interpolate point at position $s1\n") unless (defined $i1);
    }
    if ($s2 >= $points->[-1]->{distance}) {
      if ($isLoop) {
        # if it's a loop, then wrap around
        my $nLap = floor($s2 / $courseDistance);
        ($points, $i2) = pointAtPosition($s2 - $courseDistance * $nLap, $points, $isLoop);
        $i2 += scalar(@$points) * $nLap;
      } else {
        $i2 = $#$points;
      }
    } else {
      ($points, $i2) = pointAtPosition($s2, $points, $isLoop);
      die("ERROR: unable to interpolate point at position $s1\n") unless (defined $i2);
    }

    # accumulate points... may wrap around
    my @ps = ();
    for my $i ( $i1 .. $i2 ) {
      # create a new field to avoid multiple splits referring to same data
      my %p = %{$points->[$i % @$points]};
      delete $p{distance};
      push @ps, \%p;
    }
    push @splits, \@ps;
  }

  # distance field is invalid now: curvature, etc, are still fine
  foreach my $s ( @splits ) {
    deleteField2(field=> "distance", points=> $s);
  }

  return \@splits;
}

#
# calcSmoothingSigma: calculate a smoothing sigma for auto-smoothing of altitude (somewhat deprecated)
#
sub calcSmoothingSigma {
  my %var = @_;
  my $points = $var{points} // [];
  my $sigmaFactor = $var{sigmaFactor} // 1;
  my $isLoop = $var{isLoop};

  return unless (@$points);

  # specify the window over which gradient variance is calculated
  my $sigmaAvg = 200;
  my $twoSigmaAvg2 = 2 * $sigmaAvg ** 2;
  my $avgRange = 3 * $sigmaAvg;

  # calculate a gradient field (also adds distance)
  note("calculating gradient field...\n");
  addGradientField(points=> $points, isLoop=> $isLoop);
  my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);

  my @gVars;                    # gradient variances
  my @densities;                # point densities
  my $i1 = 1; # starting point for gradient variance: note we don't calculate for i=0 unless it's a loop
  my $i2 = 0; # ending point for gradient variance (can exceed number of points)

  if ($isLoop) {
    $i1 -- while ( ($i1 > -scalar(@$points)) && (distanceDifference($points->[$i1], $points->[0], $courseDistance, $isLoop) < $avgRange) );
  }

  for my $i ( 0 .. $#$points ) {
    # move i1 to just outside averaging range
    $i1 ++ while ( ($i1 < $i) && (distanceDifference($points->[$i1 + 1], $points->[$i], $courseDistance, $isLoop) > $avgRange) );
    # move i1 to just outside averaging range
    $i2 ++ while ( ($isLoop ? ($i2 < $i + @$points) : ($i2 < $#$points - 1)) && (distanceDifference($points->[$i], $points->[$i2 % @$points], $courseDistance, $isLoop) < $avgRange) );
    my $sum0 = 0;
    my $sum1 = 0;
    for my $j ( $i1 .. $i2 ) {
      # gradient for each point is the forward gradient
      # so compare gradient of the previous point to gradient of this point
      my $w = exp(-(distanceDifference($points->[$i], $points->[$j % @$points],$courseDistance, $isLoop)) ** 2 / $twoSigmaAvg2);
      $sum0 += $w;
      # note for point to point, the last gradient is invalid, and there's no difference for the first point
      my $g1 = $points->[$j % @$points]->{gradient};
      my $g2 = $points->[($j - 1) % @$points]->{gradient};
      $sum1 += $w * ($g1 - $g2) ** 2 / sqrt( 1e-4 + $g1 ** 2 + $g2 ** 2 ); # this weights steep grade fluctuations more, but not too much more
    }
    if ($sum0 > 0) {
      my $gVar = $sum1 / $sum0; # variance of gradient differences
      my $d = $sum0 / ($sigmaAvg * $sqrt2pi); # density of points
      my $sigma = $sigmaFactor * sqrt($gVar) * 50 / $d;
      $points->[$i]->{sigma} = $sigma;
    } else {
      $points->[$i]->{sigma} = 0;
    }
  }
}

#
# simplify monotonic profile
# simplify a route based only on altitude and distance
# the only preferred point is the final point:
#
sub simplifyMonotonicProfile {
  my $points = shift;
  my $courseDistance = shift;
  my $gradientPower = shift // 2;
  my $isLoop = shift // 0;
  my $indices = shift // [0 .. $#$points];

  addDistanceField(points=> $points) unless (defined $points->[0]->{distance});
  $courseDistance //= calcCourseDistance(points=> $points, isLoop=> $isLoop);

  # create a distance field of the index list
  my @distance = (0);
  for my $i ( 1 .. $#$indices ) {
    push @distance, $distance[-1] + distanceDifference( $points->[$indices->[$i - 1]], $points->[$indices->[$i]], $courseDistance, $isLoop );
  }

  my $dz = $points->[$indices->[-1]]->{ele} - $points->[$indices->[0]]->{ele};
  my $sign = ($dz <=> 0);
  my $ds = $distance[-1] - $distance[0];

  return [$indices->[-1]] if ( (@$indices <= 2) || (abs($dz) < 1) || ($ds < 50) );


  # find maximum grade
  my $gAvg = $dz / $ds;
  my $gMax = 1.1 * $gAvg;
  my $igMax;
  for my $i ( 0 .. $#$indices - 1 ) {
    my $ds = $distance[$i + 1] - $distance[$i];

    if ($ds > 0) {
      my $dz = $points->[$indices->[$i + 1]]->{ele} - $points->[$indices->[$i]]->{ele};
      my $gAvg = $dz / $ds;

      # look for maximum gradient within the interval, but if the interval is mostly constant,
      # just live with endpoints
      my $g = ($points->[$indices->[$i + 1]]->{ele} - $points->[$indices->[$i]]->{ele}) / $ds;
      if ($g * $sign > $gMax * $sign) {
        $gMax = $g;
        $igMax = $i;
      }
    }
  }
  my @newIndices;

  if (defined $igMax) {
    my $i1 = $igMax;
    my $i2 = $i1 + 1;

    # extend segment around the point
    # the segment of maximum rating within this profile will be included in the simplified profile
  loop: while ( ($i1 > 0) || ($i2 < $#$indices) ) {
      my $rating = $sign * climbRating(points=> [$points->[$indices->[$i1]], $points->[$indices->[$i2]]], gradientPower=> $gradientPower, courseDistance=> $courseDistance, isLoop=> $isLoop);

      my $r1 = ($i1 > 0) ? $sign * climbRating(points=> [$points->[$indices->[$i1 - 1]], $points->[$indices->[$i2]]], gradientPower=> $gradientPower, courseDistance=> $courseDistance, isLoop=> $isLoop) : 0;
      my $r2 = ($i2 < $#$indices) ? $sign * climbRating(points=> [$points->[$indices->[$i1]], $points->[$indices->[$i2 + 1]]], gradientPower=> $gradientPower, courseDistance=> $courseDistance, isLoop=> $isLoop) : 0;
      if (($r1 > $rating) && ($r1 > $r2)) {
        $i1 --;
      } elsif (($r2 > $rating) && ($r2 > $r1)) {
        $i2 ++;
      } else {
        last loop;
      }
    }

    # the segment between i1 and i2 has maximal rating, so we don't need to simplify that further.
    # there may be interesting segments before and after
    # this will add point i1, plus perhaps more
    push @newIndices, @{simplifyMonotonicProfile( $points, $courseDistance, $gradientPower, $isLoop, [ @$indices[0 .. $i1] ]  )}
      if ($i1 > 0);
    push @newIndices, $indices->[$i2];
    # this will add the final point,plus perhaps more
    push @newIndices, @{simplifyMonotonicProfile( $points, $courseDistance, $gradientPower, $isLoop, [ @$indices[$i2 .. $#$indices] ] )}
      if ($i2 < $#$points);
  } else {
    push @newIndices, $indices->[-1];
  }
  return \@newIndices;
}

#
# calculate a quality metric for the route
#

sub calcQualityScore {
  my %var = @_;
  my $points = $var{points};
  my $isLoop = $var{isLoop};
  my @sines;
  my @ddirs;
  note("calculating altitude quality score..\n");
  my $courseDistance = 0;
  my $s2sum = 0;
  for my $i ( 0 .. $#$points ) {
    last if ((! $isLoop) && ($i == $#$points));
    # distance, altitude change to next point
    my $ds = latlngDistance($points->[$i], $points->[($i + 1) % @$points]);
    next if ($ds < 0.01);
    $courseDistance += $ds;
    my $dz = $points->[($i + 1) % @$points]->{ele} - $points->[$i]->{ele};
    next if ((abs($ds) < 0.1) && abs($dz < 0.01)); # skip duplicate points
    # sine of inclination angle to next point
    my $s = $dz / sqrt($dz ** 2 + $ds ** 2);
    push @sines, $s;
    $s2sum += $ds * ($s ** 2 + 1e-4);

    push @ddirs,
      (((! $isLoop) && ($i == 0)) ?
       0 :
       latlngAngle(
                   $points->[($i - 1) % @$points],
                   $points->[$i],
                   $points->[($i + 1) % @$points]
                  )
      );
    unless ( (defined $ddirs[-1]) && (defined $sines[-1])) {
      pop @sines;
      pop @ddirs;
    }
  }

  my $sum2 = 0;
  for my $i ( 0 .. $#sines ) {
    last if ((! $isLoop) && ($i == $#sines));
    # these are sine grades, not tangents, to avoid zero denominators
    my $s1 = $sines[$i];
    my $s2 = $sines[($i + 1) % @sines];
    $sum2 += ($s2 - $s1) ** 2;
  }

  my $scoreZ = ($courseDistance == 0) ? 0 : 10 * $sum2 / $s2sum;

  $sum2 = 0;
  for my $i ( 0 .. $#ddirs ) {
    $sum2 += $ddirs[$i] ** 2;
  }
  my $scoreD = ($courseDistance == 0) ? 0 : 100 * $sum2 / $courseDistance;

  my $score = $scoreZ + $scoreD;

  return ($score, $scoreD, $scoreZ);
}

# fields used in this code need to be converted into extensions for
# legal GPX export
sub addPointExtensions {
  my %var =@_;
  my @extensionFields =
    qw(
        heading
        curvature
        distance
        gradient
        shift
        sigma
     );
  my $points = $var{points} // [];

  for my $p ( @$points ) {
    for my $e ( @extensionFields ) {
      if (exists $p->{$e}) {
        $p->{extensions}->{$e} = $p->{$e};
        delete $p->{$e};
      }
    }
    # get rid of extensions if there are none defined
    delete $p->{extensions}
      if ((ref $p->{extensions} ne "HASH") || (scalar(keys %{$p->{extensions}}) == 0));
  }
  return $points;
}

# selected fields stored in point extensions get promoted to primary fields
sub flattenPointExtensions {
  my %var =@_;
  my @extensionFields =
    qw(
        curvature
        direction
        distance
        gradient
        shift
        sigma
     );
  my $points = $var{points} // [];

  for my $p ( @$points ) {
    if ((exists $p->{extensions}) && (ref $p->{extensions} eq "HASH")) {
      for my $e ( @extensionFields ) {
        if (exists $p->{extensions}->{$e}) {
          $p->{$e} = $p->{extensions}->{$e};
          delete $p->{extensions}->{$e};
        }
      }
      if ( exists($p->{extensions}) && (scalar(keys(%{$p->{extensions}})) == 0)) {
        delete $p->{extensions};
      }
    }
  }
  return $points;
}


sub getExtensions {
  my $xml = shift;
  my $p = XML::Descent->new( { Input => $xml } );

  # Global handler - trigger anywhere an <options> tag is found
  my %extensions;
  $p->on( gpx => sub {
            $p->on( "extensions/rgt:parserOptions" => sub {
                      $p->on(
                             '*' => sub {
                               my ( $elem, $attr, $ctx ) = @_;
                               my $t = $p->text;
                               if ($t eq "") {
                                 $extensions{$elem} = 1;
                               } else {
                                 $extensions{$elem} = $t;
                               }
                             })->walk;
                    });
            my $nTrack = 0;
            $p->on( trk => sub {
                      $nTrack ++;
                      my $nSegment = 0;
                      $p->on( trkseg => sub {
                                $nSegment ++;
                                $p->on(extensions => sub {
                                         $p->on("rgt:namedSegment" => sub {
                                                  my $t = $p->text;
                                                  $extensions{segmentName}->{$nTrack}->{$nSegment} = $t;
                                                })->walk;
                                       })->walk;
                              })->walk;
                    })->walk;
          })->walk;
  return \%extensions;
}

sub addExtensions {
  my $xml = shift;
  my $extensions = shift;

  return $xml
    unless ( (defined $extensions) && (keys %$extensions) );

  my @lines = split("\n", $$xml);
  my @output = ();
  my $nTrack = 0;
  my $nSegment = 0;
  for my $l ( @lines ) {
    if ($l =~ /<\/trkseg.*>/) {
      my $name= $extensions->{segmentName}->{$nTrack}->{$nSegment} // "";
      # escape critical characters
      $name =~ s/&/&amp;/sg;
      $name =~ s/</&lt;/sg;
      $name =~ s/>/&gt;/sg;
      $name =~ s/"/&quot;/sg;
      if ($name ne "") {
        push @output, "<extensions><rgt:namedSegment>$name</rgt:namedSegment></extensions>";
      }
    }
    push @output, $l;
    if ( ($l =~ /<trkseg>/) || ($l =~ /<trkseg\s/) ) {
      $nSegment ++;
    }
    if ( ($l =~ /<trk>/) || ($l =~ /<trk\s/) ) {
      $nTrack ++;
      $nSegment = 0;
    }
  }
  my $xml2 = join("\n", @output);
  return \$xml2;
}


my $addCurvature = 0;       # whether to not add a curvature field
my $addDirection = 0;       # whether to not add a direction field
my $addDistance = 0;        # whether to not add a distance field
my $addGradient = 0;        # whether to not add a gradient field
my $addGradientSigns = 0;   # whether to create list of gradient signs
my $addSigma = 0;           # whether to create a sigma field when autosmoothing
my $anchorSF = 0;           # whether to anchor the S/F
my $append = 0;             # distance to append on finish (allows for a finish zone)
my $arcFitDegs;             # maximum degrees use if we use spline interpolation
my $arcFitEnd;              # where to end arc fitting
my $arcFitMaxDegs = 60;     # maximum turn angle for spline
my $arcFitStart;            # where to start arc fitting
my $autoLoop;               # whether to automatically determine if it's a lappable course
my $autoSegmentMargin = 400; # minimum distance between auto-segments or between segments and start or finish banners
my $autoSegmentFinishMargin = 20; # the margin forward to the finish line for auto segments
my $autoSegmentStartMargin = 340; # the margin back to the start line for auto segments
my $autoSegmentDefaultPower = 0.5; # default for gradient power in auto segments
my $autoSegmentStretch = 0.05; # fractional amount to stretch auto-segments to hit peaks or valleys
my $autoSegmentNames = ""; # comma separated list of names for the auto-segments
my $autoSpacing;           # whether to do auto-spacing
my $autoSplits = 0; # number of splits to put into the road based on distance
my $autoStraightenDeviation;  # maximum deviation for auto-straightening
my $autoStraightenLength;  # minimum length for auto-straightening
my $author;         # author, for GPX
my $copyPoint = 0; # whether to make sure first point and last point in data coincide
my $copyright;     # copyright field, for GPX
my $cornerCrop;    # amount to "crop" from sharp corners before point interpolation
my $cornerCropStart;  # where to begin corner cropping
my $cornerCropEnd ;  # when to stop corner cropping
my $cornerEffect = 1; # corner effect for smoothing
my $cropMax; # maximum distance of retained data (distance calculated in original coordinates
my $cropMin; # minimum distance of retained data (distance calculated in original coordinates)
my $crossingAngle;    # crossings need to cross by at least this angle
my $crossingHeight = 2; # crossing should have same altitude, or at least this height
my $crossingTransition; # transition length for crossings
my $csv = 0;            # whether to use CSV instead of GPX
my $description;        # description, for GPX metadata
my $extend = 0;                  # apply to both append and prepend
my $extendBack;              # amount to extend the route with a loop.
my $finishCircuits  = 0;     # number of finish circuits
my $finishCircuitDistance = -1; # km of finish circuit
my $fixCrossings;            # whether to flatten crossings
my $gAutoSmooth = 0;            # auto-smoothing based on gradient
my $gradientPower = 2; # power to raise gradient in evaluating segments for gradient signs
my $gradientThreshold = 100; # minimum climb @ 10% grade to get a gradient sign
my $gSmooth = 0;          # smoothing applied additionally to gradient
my $isLoop = 0;    # whether to apply periodic boundary conditions (smooth around the Loop)
my $lAutoSmooth = 0;            # auto-smoothing based on position
my $lSmooth;    # general smoothing, applies to positions and all other fields
my $laneShift; # how much to shift lanes right (positive) or left (negative)
my $shiftTransition; # length over which to transition lane shift (to each side)
my $maxCornerCropDegs;   # maximum angle for corner cropping
my $maxSlope = 30; # maximum gradient, in percent (if <1, will be converted to %)
my $minCornerCropDegs;   # minimum angle for corner cropping
my $minRadius;     # a minimum radius for corners: correct with lane shift
my $minRadiusStart;  # where to begin applying minimum radius (meters)
my $minRadiusEnd;    # where to end applying minimum radius (meters)
my $namedSegments = "";         # named segments
my $needHelp = 0;               # print the pod
my $newKeywords = "";           # new keywords for the GPX file
my $noSave = 0;                 # skip saving the file
my $outFile = ""; # where to write the resulting GPX, unless -nosave is used
my $outAndBack = 0;  # shorthand for creating an out-and-back course
my $outAndBackLap = 0;  # shorthand for creating an out-and-back course with a loop to create a circuit
my $prepend = 0; # distance to pre-pend on start (60 meters allows room for start): only for point-to-point
my $prune;   # whether to prune points
my $pruneD = 1; # distance a point can deviate in meters to avoid pruning.  also much match X-product.
my $pruneX = 0.001;   # maximum cross product for pruning
my $prunedg = 0.0005; # maximum difference in grade for point pruning
my $quiet = 0;        # suppressed notes to standard error
my $rCrossings = 6;   # how much lenth to flatten crossings, each side
my $repeat = 0;       # number of copies of the course to add to the course
my $reverse = 0;      # whether to reverse the course
my $rLap;   # if the route is turned into an out-and-back, the radius of the return loop
my $rTurnaround; # if the route is turned into an out-and-back, the radius of the outer loop
my $rUTurn; # if the route is turned into an out-and-back, the radius of the two loops
my $saveCrossingsCSV;           # whether to save a CSV file with the crossings
my $saveSimplifiedCourse = 0;   # whether to save a CSV file of a simplfied course, if generated (debugging)
my $shiftEnd;      # where to end land shifting (define: don't end it)
my $shiftSFDefault = 0;
my $shiftSF = $shiftSFDefault; # amount to shift the S/F if a loop course:
my $shiftStart; # where to start lane shifting (default: don't start it)
my $simplifyPoints;    # whether to run simplification algorithm
my $simplifyD = 0.3;   # threshold distance for simplification
my $simplifyZ = 0.1;   # threshold altitude for simplification
my $smoothAngle; # angle at which direction changes trigger point interpolation
my $smoothStart; # where to start smoothing (default: beginning)
my $smoothEnd;   # where to finish smoothing (default: end)
my $snap;              # whether to check for near-coincident road segments, and make them exactly coincide: upward direction: 1 = up, 2 = down, 0 = none
my $snapAltitude = 1;  # how close altitude needs to be for snapping
my $snapDistance = 2;  # number of meters threshold for point snapping
my $snapTransition;    # whether to transition the altitude around snaps to match the source
my $spacing;           # target point spacing: linear interpolate between existing points
my $splineDegs;               # minimum degrees use if we use spline interpolation
my $splineEnd;                # where to stop spline fitting
my $splineMaxDegs = 60;       # maximum turn angle for spline
my $splineStart;              # where to start spline fitting
my $splitNumber;              # number of split to output (default: all)
my $startCircuits  = 0;       # number of start circuits
my $startCircuitDistance = -1;# km of start circuit
my $startTime;                # start time for activity
my $stripSegments; # eliminate all existing segment definitions on input files
my $title;         # title, for GPX file
my $selectedTrack = 0;    # which track to use
my $vFlag = 0;            # print version
my $xShift = 0;           # offset for altitude after scaling
my $yShift = 0;           # offset for altitude after scaling
my $zAutoSmooth = 0;      # auto-smoothing based on altitude
my $zOffset = 0;          # offset for altitude before scaling
my $zScale = 1;           # scale factor for altitude
my $zScaleRef = 0;        # reference altitude for altitude scaling
my $zShift = 0;           # offset for altitude after scaling
my $zShiftStart;          # where to start applying z shift
my $zShiftEnd;            # where to end applying z shift
my $zSmooth;              # smoothing applied additionally to altitude
my $loopLeft;             # specify looping to the left
my $loopRight;            # specify looping to the right

my @autoSegments;         # parameters for auto-segment generation
my @autoStraighten;       # parameters for auto-straightening
my @circle;               # points for circle substitution
my @circleEnd;            # ending point (meters) for a circular corner (one per run)
my @circleStart;          # starting point for a circular corner (one per run)
my @circuitFromPosition;  # find circuits starting at a given position
my @circuitToPosition;    # find circuits finish at a given position
my @deleteRange;          # pairs of positions for deleting points
my @flatten;              # points come in sets of 4: altitude, start point, finish point, lambda
my @join;                 # GPX file(s) to join to this one
my @selectiveLaneShift;   # allow lane shift to be specified in segments along the course
my @selectiveSmooth;      # alternative to specifying smoothing varying along the course
my @selectiveSmoothG;     # alternative to specifying gradient smoothing varying along the course
my @selectiveSmoothZ;     # alternative to specifying altitude smoothing varying along the course
my @splitDistance;        # locations for splitting route
my @straight;             # points for straight substitution
my @straightEnd;          # ending point (meters) for a circular corner (one per run)
my @straightStart;        # starting point for a circular corner (one per run)

# shortcut options:
my $auto = 0; # automatically set options based on the course (doesn't turn options off)

GetOptions (
            "addCurvature!" => \$addCurvature,
            "addDirection!" => \$addDirection,
            "addDistance!"  => \$addDistance,
            "addGradient!"  => \$addGradient,
            "addHeading!"   => \$addDirection,
            "addGradientSigns!" => \$addGradientSigns,
            "addSigma!"     => \$addSigma,
            "anchorSF!"     => \$anchorSF,
            "append=f"      => \$append,
            "arcFitDegs=f"  => \$arcFitDegs,
            "arcFitEnd=f"   => \$arcFitEnd,
            "arcFitMaxDegs=f" => \$arcFitMaxDegs,
            "arcFitStart=f" => \$arcFitStart,
            "author=s"      => \$author,
            "auto!"         => \$auto,
            "autoLap!"      => \$autoLoop,
            "autoLoop!"     => \$autoLoop,
            "autoSegments=f{1,2}" =>  \@autoSegments,
            "autoSegmentMargin=f" =>  \$autoSegmentMargin,
            "autoSegmentFinishMargin=f" =>  \$autoSegmentFinishMargin,
            "autoSegmentStartMargin=f" =>  \$autoSegmentStartMargin,
            "autoSegmentPower=f"   =>  \$autoSegmentDefaultPower,
            "autoSegmentStretch=f" =>  \$autoSegmentStretch,
            "autoSegmentNames=s"  =>  \$autoSegmentNames,
            "autoSmoothG=f" => \$gAutoSmooth,
            "autoSmoothL=f" => \$lAutoSmooth,
            "autoSmoothZ=f" => \$zAutoSmooth,
            "autoSpacing!"  => \$autoSpacing,
            "autoSplits=i"   => \$autoSplits,
            "autoStraighten=f{0,2}" =>  \@autoStraighten,
            "autoStraightenLength=f" =>  \$autoStraightenLength,
            "autoStraightenDeviation=f" =>  \$autoStraightenDeviation,
            "circleStart=f{1,1000}" => \@circleStart,
            "circleEnd=f{1,1000}" => \@circleEnd,
            "circleStop=f{1,1000}" => \@circleEnd,
            "circle=f{1,1000}" => \@circle,
            "circuitFromPosition=f{1,30}"  => \@circuitFromPosition,
            "circuitsFromPosition=f{1,30}" => \@circuitFromPosition,
            "circuitFromPoint=f{1,30}"     => \@circuitFromPosition,
            "circuitsFromPoint=f{1,30}"    => \@circuitFromPosition,
            "circuitToPosition=f{1,30}"    => \@circuitToPosition,
            "circuitsToPosition=f{1,3}"    => \@circuitToPosition,
            "circuitToPoint=f{1,30}"       => \@circuitToPosition,
            "circuitsToPoint=f{1,30}"      => \@circuitToPosition,
            "closed!"       => \$copyPoint,
            "copyPoint!"    => \$copyPoint,
            "copyright=s"   => \$copyright,
            "cornerCrop=f" => \$cornerCrop,
            "cornerCropEnd=f" => \$cornerCropEnd,
            "cornerCropStart=f" => \$cornerCropStart,
            "cornerEffect=f" => \$cornerEffect,
            "crop=f"        => \$cropMax,
            "cropEnd=f"     => \$cropMax,
            "cropMax=f"     => \$cropMax,
            "cropMin=f"     => \$cropMin,
            "cropCorners=f" => \$cornerCrop,
            "cropStart=f"    => \$cropMin,
            "cropStop=f"     => \$cropMax,
            "crossingAngle=f" => \$crossingAngle,
            "crossingHeight=f" => \$crossingHeight,
            "crossingTransition=f" => \$crossingTransition,
            "csv!"          => \$csv,
            "deleteRange=f{1,100}" => \@deleteRange,
            "description=s" => \$description,
            "extend=f"      => \$extend,
            "extendBack=f"  => \$extendBack,
            "finishCircuits=i"  => \$finishCircuits,
            "finishCircuitDistance=f" => \$finishCircuitDistance,
            "finishCircuitStart=f" => \$finishCircuitDistance,
            "fixCrossings!"     => \$fixCrossings,
            "flatten=f{1,1000}" => \@flatten,
            "gAutoSmooth=f" => \$gAutoSmooth,
            "gSmooth=f"     => \$gSmooth,
            "gSigma=f"      => \$gSmooth,
            "gradientPower=f"   => \$gradientPower,
            "gradientThreshold=f"  => \$gradientThreshold,
            "h"             => \$needHelp,
            "help!"         => \$needHelp,
            "join=s{1,100}" => \@join,
            "keywords=s"    => \$newKeywords,
            "interpolate=f" => \$spacing,
            "laneShift=f"   => \$laneShift,
            "laneShiftEnd=f"    => \$shiftEnd,
            "laneShiftSF=f"     => \$shiftSF,
            "laneShiftStart=f"  => \$shiftStart,
            "laneShiftTransition=f" => \$shiftTransition,
            "lap!"          => \$isLoop,
            "lAutoSmooth=f" => \$lAutoSmooth,
            "loop!"         => \$isLoop,
            "loopLeft!"     => \$loopLeft,
            "loopRight!"    => \$loopRight,
            "loopL!"        => \$loopLeft,
            "loopR!"        => \$loopRight,
            "maxCornerCropDegs=f" => \$maxCornerCropDegs,
            "maxSlope=f"    => \$maxSlope,
            "minCornerCropDegs=f" => \$minCornerCropDegs,
            "minRadius=f"   => \$minRadius,
            "minRadiusStart=f" => \$minRadiusStart,
            "minRadiusEnd=f"   => \$minRadiusEnd,
            "name=s"        => \$title,
            "noSave!"       => \$noSave,
	    "o=s"         => \$outFile,
            "out=s"         => \$outFile,
            "outAndBack!"   => \$outAndBack,
            "outAndBackLap!" => \$outAndBackLap,
            "outAndBackLoop!" => \$outAndBackLap,
            "prepend=f"     => \$prepend,
            "prune!"        => \$prune,
            "pruneD=f"      => \$pruneD,
            "pruneDistance=f" => \$pruneD,
            "pruneX=f"      => \$pruneX,
            "pruneSine=f"   => \$pruneX,
            "prunedg=f"     => \$prunedg,
            "pruneGradient=f"  => \$prunedg,
            "quiet!"        => \$quiet,
            "rCrossings=f"  => \$rCrossings,
            "repeat=i"      => \$repeat,
            "reverse!"      => \$reverse,
            "rLap=f"        => \$rLap,
            "rTurnaround=f" => \$rTurnaround,
            "rUTurn=f"      => \$rUTurn,
            "saveCrossingsCSV!" => \$saveCrossingsCSV,
            "saveSimplifiedCourse!" => \$saveSimplifiedCourse,
            "segment=s"     =>  \$namedSegments,
            "segments=s"    =>  \$namedSegments,
            "selectiveLaneShift=f{0,1000}" => \@selectiveLaneShift,
            "selectiveGSmooth=f{0,1000}" => \@selectiveSmoothG,
            "selectiveSmooth=f{0,1000}" => \@selectiveSmooth,
            "selectiveSmoothG=f{0,1000}" => \@selectiveSmoothG,
            "selectiveSmoothZ=f{0,1000}" => \@selectiveSmoothZ,
            "selectiveZSmooth=f{0,1000}" => \@selectiveSmoothZ,
            "shiftEnd=f"    => \$shiftEnd,
            "shiftSF=f"     => \$shiftSF,
            "shiftStart=f"  => \$shiftStart,
            "shiftTransition=f" => \$shiftTransition,
            "shiftX=f"      => \$xShift,
            "shiftY=f"      => \$yShift,
            "shiftZ=f"      => \$zShift,
            "shiftZEnd=f"   => \$zShiftEnd,
            "shiftZStart=f" => \$zShiftStart,
            "sigma=f"       => \$lSmooth,
            "sigmag=f"      => \$gSmooth,
            "sigmaz=f"      => \$zSmooth,
            "simplifyPoints!" => \$simplifyPoints,
            "simplify!"      => \$simplifyPoints,
            "simplifyAltitude=f" => \$simplifyZ,
            "simplifyD=f"   => \$simplifyD,
            "simplifyDistance=f" => \$simplifyD,
            "simplifyZ=f"   => \$simplifyZ,
            "smooth=f"      => \$lSmooth,
            "smoothAngle=f" => \$smoothAngle,
            "smoothEnd=f"   => \$smoothEnd,
            "smoothStart=f" => \$smoothStart,
            "smoothG=f"     => \$gSmooth,
            "smoothZ=f"     => \$zSmooth,
            "snap=i"        => \$snap,
            "snapDistance=f" => \$snapDistance,
            "snapTransition=f" => \$snapTransition,
            "snapAltitude=f" => \$snapAltitude,
            "snapZ=f"       => \$snapAltitude,
            "spacing=f"     => \$spacing,
            "splineDegs=f"  => \$splineDegs,
            "splineEnd=f"   => \$splineEnd,
            "splineMaxDegs=f" => \$splineMaxDegs,
            "splineStart=f"   => \$splineStart,
            "splitAt=f{1,100}" => \@splitDistance,
            "splitNumber=i" => \$splitNumber,
            "startCircuitDistance=f" => \$startCircuitDistance,
            "startCircuitEnd=f" => \$startCircuitDistance,
            "startCircuits=i"  => \$startCircuits,
            "startTime=s"   => \$startTime,
            "straight=f{1,1000}" => \@straight,
            "straightStart=f{1,1000}" => \@straightStart,
            "straightEnd=f{1,1000}" => \@straightEnd,
            "straightStop=f{1,1000}" => \@straightEnd,
            "stripSegments!" => \$stripSegments,
            "title=s"       => \$title,
            "track=i"       => \$selectedTrack,
            "version!"      => \$vFlag,
            "v"             => \$vFlag,
            "xShift=f"      => \$xShift,
            "yShift=f"      => \$yShift,
            "zAutoSmooth=f" => \$zAutoSmooth,
            "zOffset=f"     => \$zOffset,
            "zScaleRef=f"   => \$zScaleRef,
            "zScaleReference=f"  => \$zScaleRef,
            "zScale=f"      => \$zScale,
            "zShift=f"      => \$zShift,
            "zShiftEnd=f"   => \$zShiftEnd,
            "zShiftStart=f" => \$zShiftStart,
            "zSmooth=f"     => \$zSmooth,
            "zSigma=f"      => \$zSmooth,
           )
  or die("$0: ERROR processing command line options\n");


if ($needHelp) {
  pod2usage(-exitval=>0, -verbose=>2);
}

if ($vFlag ) {
  warn("$0: version $version\n");
  exit 0;
}

# make sure repeat is in range
die("-repeat limited to range 0 to 99\n")
  if ($repeat > 99);

# check loopLeft and loopRight
if ($loopLeft && $loopRight) {
  die("ERROR: you cannot specify both -loopLeft and -loopRight\n");
}

# short-cut for out-and-back
if ( $outAndBack || $outAndBackLap ) {
  if ($outAndBackLap) {
    $rLap //= 8;
  } else {
    $rLap //= 0;
  }
  $autoSpacing //= 1;
  $lSmooth //= 5;
  $laneShift //= (@selectiveLaneShift ? 0 : 6);
  $minRadius //= 6;
  $prune //= 1;
  $rTurnaround //= 8;
  $rUTurn //= 8;
  $spacing //= 10;
  $splineDegs //= 0;
}


# loop sign
my $loopSign = $loopLeft ? -1 : $loopRight ? 1 : ((defined $laneShift) && ($laneShift < 0)) ? -1 : 1;

# auto-straighten
$autoStraightenDeviation //= $autoStraighten[0] // 0;
$autoStraightenLength //= $autoStraighten[1] // 100;

# named segments
my @namedSegments    = split("[;]", $namedSegments);
my @autoSegmentNames = split("[,;]", $autoSegmentNames);

# convert max slope to percent
$maxSlope *= 100 if ($maxSlope < 1);

for my $s ( @autoSegmentNames ) {
  $s =~ s/^\s*(.*?)\s*$/$1/;
}

# proc to print user messages
# here so it can access $quiet as a global variable
sub note {
  warn(@_) unless ($quiet);
}

# if extendBack is specified, we need a turnaround loop... calculate crop
# later
$extendBack //= 0;
$rTurnaround //= 0;
$rTurnaround = 5
  if (($extendBack > 0) && ($rTurnaround <= 0));

die("Crop window minimum exceeds crop window maximum\n")
  if ((defined $cropMin) && (defined $cropMax) && ($cropMax > 0) && ($cropMin > $cropMax));

# csv option can be inferred from filename, if specified
if (defined $outFile) {
  $csv = 1 if ($outFile =~ /csv$/i);
  $csv = 0 if ($outFile =~ /gpx$/i);
}

# apply extend
$prepend += $extend;
$append  += $extend;

my @files = @ARGV;
@files = ("-") unless (@files);

die("output file name can be specified only if one input file is specified: either use default output file name, or run files one at a time.\n")
  if ((@files > 1) && ($outFile ne ""));

for my $file ( @files ) {
  # if file has track code appended, split that off
  my $trkIndex = ($selectedTrack > 0) ? $selectedTrack - 1 : 0;

  if (my ($f, $t) = ($file =~ /(.*)\:(\d+)$/)) {
    $file = $f;
    $trkIndex = ($t > 0) ? $t - 1: 0;
  }

  open my $fin, "<$file"
    or die("ERROR opening file $file");
  my $xml;
  {
    my $tmp = $/;
    $/ = undef;
    $xml = <$fin>;
    $/ = $tmp;
  }
  close $fin;

  die("ERROR: file $file is empty\n")
    unless (defined $xml);

  # Parse GPX from open file
  my $gpx = Geo::Gpx->new( xml => $xml );

  # get segment names indexed by track and segments for the target track
  my $extensions = getExtensions(\$xml);
  my $waypoints = $gpx->waypoints();
  my $tracks    = $gpx->tracks();

  # process tracks
  my $track = $tracks->[$trkIndex];
  die("ERROR: selected track ", $trkIndex + 1, " not found in file $file\n")
    unless (defined $track);
  my $nTrack = $trkIndex + 1;

  # list of segments in the present track
  my $segments = $track->{segments};

  # segments:
  # $segments: pointer to segments in the GPX data
  # @segmentPoints: list of segments
  # points->{segment}: ID of the segment associated with each point
  # initially the segment ID = segment index
  # this may change if segments are modified

  # add segment field to points
  my $points = [];

  my $nSegment = 0;
  my %segmentDefined;
  my %segmentName;              # names of each segment

  for my $segment ( @$segments ) {
    $nSegment ++;
    $segmentDefined{$nSegment} ++;

    my $segmentName = $extensions->{segmentName}->{$nTrack}->{$nSegment};
    $segmentName{$nSegment} = $segmentName;
    note("processing segment $nSegment ...\n");
    note("segment name = $segmentName\n") if ( (defined $segmentName) && ($segmentName ne "") );

    for my $p ( @{$segment->{points}} ) {
      $p->{segment} = ($stripSegments ? 0 : $nSegment);
      push @$points, $p;
    }
    flattenPointExtensions(points=> $points);
    note("total points after segment $nSegment = ", scalar(@$points), "\n");
  }
  note("points in original GPX track = ", scalar(@$points), "\n");
  my ($score, $scoreD, $scoreZ) = calcQualityScore(points=> $points, isLoop=> $isLoop);
  note("quality score of original course = ", sprintf("%.4f", $score), "\n");
  note("direction score of original course = ", sprintf("%.4f", $scoreD), "\n");
  note("altitude score of original course = ", sprintf("%.4f", $scoreZ), "\n");

  # eliminate duplicate x,y points
  $points = removeDuplicatePoints(points=> $points, isLoop=> $isLoop);

  # if repeat is specified, then create replicates
  if ( $repeat > 0 ) {
    deleteField2(points=> $points, field=> "distance");
    my @pNew = @$points;
    for my $i ( 1 .. $repeat ) {
      for my $p ( @$points ) {
        my %p2 = %$p;
        push @pNew, \%p2;
      }
    }
    $points = \@pNew;
  }

  # if join was specified, join points from a second file
  for my $join ( @join ) {

    my $nTrack    = 1;
    my $trkIndex2 = 0;

    if (my ($f, $t) = ($join =~ /(.*)\:(\d+)$/)) {
      $join = $f;
      $trkIndex2 = ($t > 0) ? $t - 1: 0;
      $nTrack = $t;
    }
    note("joining file $join to the end of tfile $file...\n");
    open my $fjoin, "<$join"
      or die("ERROR opening file $join");
    my $xml2;
    {
      my $tmp = $/;
      $/ = undef;
      $xml2 = <$fjoin>;
      $/ = $tmp;
    }
    close $fin;

    # Parse GPX from open file
    my $gpx2 = Geo::Gpx->new( xml => $xml2 );

    # get segment names indexed by track and segments
    my $extensions2 = getExtensions(\$xml2, $trkIndex2 + 1);

    # Parse GPX from open file
    my $waypoints2 = $gpx2->waypoints();
    my $tracks2    = $gpx2->tracks();

    my $track2 = $tracks2->[$trkIndex2];

    # segments for the joined file
    my $segments2  = $track2->{segments};

    my $points2 = [];

    my $nSegment0 = $nSegment;
    for my $segment ( @$segments2 ) {
      $nSegment ++;

      # make sure we have a new copy of all points
      for my $p ( @{$segment->{points}} ) {
        $p->{segment} = ($stripSegments ? 0 : $nSegment);
        push @$points2, $p;
      }
      flattenPointExtensions(points=> $points2);
    }

    # add in segment extensions to the main extensions
    if ((! $stripSegments) && (defined $extensions2) && (defined $extensions2->{segmentName}->{$nTrack})) {
      for my $s ( keys %{$extensions2->{segmentName}->{$nTrack}} ) {
        my $nS = $nSegment0 + $s;
        $segmentName{$nS} = $extensions2->{segmentName}->{$nTrack}->{$s};
        $segmentDefined{$nS} ++;
      }
    }

    push @$points, @$points2;
    note("points after joining with $join = ", scalar(@$points), "\n");
  }

  # unnamed segments get converted to 0 so they can be merged if contiguius
  for my $p ( @$points ) {
    unless (defined $segmentName{$p->{segment}}) {
      $segmentDefined{$p->{segment}} = 0;
      $p->{segment} = 0;
    }
  }

  #
  # crop ranges if specified
  # this is done before auto-options since it may change whether the course is a loop, for example
  #
  $points = cropPoints(points=> $points, isLoop=> $isLoop, deleteRange=> \@deleteRange);


  #
  # autoLoop: automatically detrmine if -loop should be invoked
  #
  $autoLoop //= $auto;
  if ( $autoLoop ) {
    if (
        (! $isLoop) &&
        (! defined $cropMin) &&
        (! defined $cropMax) &&
        (latlngDistance($points->[0], $points->[-1]) < 150) &&
        (@$points > 3) &&
        (latlngDotProduct($points->[-2], $points->[-1], $points->[0], $points->[1]) > -0.1)
       ) {
      $isLoop = 1;
      $copyPoint = 0;
      note("setting -loop\n");
    }
  }

  #
  # auto: auto option will turn on options based on the course
  #
  if ( $auto ) {
    note("auto-setting options...\n");

    my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);

    # calculate position interpolation
    if ( ! defined $spacing ) {
      $spacing = 3 * (1 + $courseDistance / 250) ** (1/4);
      note("setting spacing to ", sprintf("%.3f", $spacing), " meters (distance = ", sprintf("%.3f", $courseDistance / 1000), " km)\n");
    }

    # smoothing
    if ( ! defined $lSmooth ) {
      $lSmooth = 5;
      note("setting smoothing to $lSmooth meters\n");
    }

    # other options
    if (! defined $autoSpacing) {
      note("setting -autoSpacing...\n");
      $autoSpacing = 1;
    }

    if (! defined $smoothAngle) {
      $smoothAngle = 10;
      note("setting -smoothAngle $smoothAngle ...\n");
    }

    if (! defined $minRadius) {
      $minRadius = 6;
      note("setting minimum corner radius to $minRadius ...\n");
    }
    if (! defined $prune) {
      note("setting -prune ...\n");
      $prune = 1;
    }

    if (! defined $zSmooth) {
      $zSmooth = 15;
      note("setting altitude smoothing to $zSmooth meters\n");
    }

    if (! defined $fixCrossings) {
      note("setting -fixCrossings ...\n");
      $fixCrossings = 1;
    }

    if (! defined  $rUTurn) {
      $rUTurn = 6;
      note("setting -RUTurn $rUTurn (meters) ...\n");
    }

    if (! defined $snap) {
      $snap = 1;
      note("setting -snap 1 ...\n");

    }
    if (! defined $snapTransition) {
      $snapTransition = 10;
      note("setting -snapTransition $snapTransition meters...\n");
    }

    if (! defined $cornerCrop) {
      $cornerCrop = 6;
      note("setting -cornerCrop $cornerCrop meters...\n");
    }
  }

  $fixCrossings //= 0;
  $laneShift //= 0;
  $minRadius //= 0;
  $prune //= 0;
  $rLap //= 0;
  $spacing //= 0;
  $zSmooth //= 0;

  $snap //= 0;
  $snapTransition //= 0;
  $lSmooth //= 0;
  warn("WARNING: if snapping distance ($snapDistance) is more than smoothing distance ($lSmooth), then abrupt transitions between snapped and unsnapped points may occur\n")
    if (($snap > 0) && ($snapDistance > $lSmooth));

  if ($isLoop && ($rTurnaround > 0)) {
    warn("WARNING: ignoring -lap or -loop option when rTurnaround > 0\n");
    $isLoop = 0;
  }

  # autospacing triggered if max angle specified
  my $smoothRadians;
  if ((defined $smoothAngle) && ($smoothAngle <= 0)) {
    $smoothAngle = 10;
    $autoSpacing //= 1;
  }
  if ($autoSpacing) {
    $smoothAngle //= 15;
  }

  $splineDegs //= 0;
  my $splineRadians = $splineDegs * $deg2rad;
  my $splineMaxRadians = $splineMaxDegs * $deg2rad;

  $arcFitDegs //= 0;
  my $arcFitRadians = $arcFitDegs * $deg2rad;
  my $arcFitMaxRadians = $arcFitMaxDegs * $deg2rad;

  #
  # check if loop specified for apparent point-to-point
  #

  if ($isLoop) {
    my $d =latlngDistance($points->[0], $points->[-1]);
    warn("WARNING: -loop or -lap specified, with large ($d meter) distance between first and last point: are you sure you wanted -loop or -lap?\n")
      if ($d > 150);
  }

  # if shiftSF is specified but not loop, that's an error
  die("ERROR: -shiftSF is only compatible with the -lap (or -loop) option.\n")
    unless ( ($shiftSF == $shiftSFDefault) || $isLoop );

  # look for zig-zags
  $points = fixZigZags(points=> $points, isLoop=> $isLoop);

  # look for loops
  findLoops($points, $isLoop);

  # adjust positions if requested
  if ( ((defined $xShift) && ($xShift != 0)) || ((defined $yShift) && ($yShift != 0)) ) {
    my $dLat = $yShift / $lat2y;
    note("shifting points by distance $xShift, $yShift: will cause distortion near poles.\n");
    for my $p ( @$points ) {
      $p->{lat} += $dLat;
      my $c = cos($deg2rad * $p->{lat});
      $p->{lon} += $xShift / ($c * $lat2y) if ($c > 0);
    }
  }

  # adjust altitudes if requested
  if ( ((defined $zShift) && ($zShift != 0)) || ((defined $zScale) && ($zScale != 1)) ) {
    # transition set to change gradient by up to 5%
    note("applying z shift = $zShift, and z scale = $zScale\n");
    note("zShift start = $zShiftStart\n") if (defined $zShiftStart);
    note("zShift end = $zShiftEnd\n") if (defined $zShiftEnd);
    my $zShiftDistance = 20 * (1 + abs($zShift));
    for my $p ( @$points ) {
      my $s = $p->{distance};
      my $dz = ($p->{ele} + $zOffset - $zScaleRef) * $zScale + $zShift + $zScaleRef - $p->{ele};
      if ( (defined $zShiftStart) && (defined $zShiftEnd) && ($zShiftEnd < $zShiftStart) ) {
        $dz *= (transition(($zShiftStart - $s) / $zShiftDistance) * transition(($s - $zShiftEnd) / $zShiftDistance));
      } else {
        $dz *= transition(($zShiftStart - $s) / $zShiftDistance) if (defined $zShiftStart);
        $dz *= transition(($s - $zShiftEnd) / $zShiftDistance)   if (defined $zShiftEnd);
      }
      $p->{ele} += $dz;
    }
  }

  # reverse the points of the original course
  # points reference segments so segments order is also reversed
  if ($reverse) {
    note("reversing course direction..\n");
    reversePoints($points);
  }


  # corner cropping
  $cornerCrop //= 0;
  $minCornerCropDegs //= 75;
  unless (defined $maxCornerCropDegs) {
    if ($minCornerCropDegs < 90) {
      $maxCornerCropDegs = 135;
    } else {
      $maxCornerCropDegs = $minCornerCropDegs + 45;
    }
  }
  if ($cornerCrop > 0) {
    note("cropping corners by $cornerCrop meters ...\n");
    $points =
      cropCorners(
                  points     => $points,
                  cornerCrop => $cornerCrop,
                  minRadians => $minCornerCropDegs * $deg2rad,
                  maxRadians => $maxCornerCropDegs * $deg2rad,
                  start      => $cornerCropStart,
                  end        => $cornerCropEnd,
                  isLoop     => $isLoop
                 );
  }

  # auto-straighten
  if ($autoStraightenDeviation > 0) {
    note("auto-Straightening...\n");
    autoStraighten(
                   points=> $points,
                   isLoop=> $isLoop,
                   minLength=> $autoStraightenLength,
                   maxDeviation=> $autoStraightenDeviation,
                  );
  }

  # circuits at position
  my $i = 0;
  my @a = @circuitFromPosition;
  while (@a) {
    my $pos = shift @a;
    my $circuits = shift @a // 1;
    my $repeats = shift @a  // 1;
    note("processing circuitFromPosition $pos...\n");
    $points = circuitFromPosition(points=> $points, position=> $pos, circuits=> $circuits, repeats=> $repeats, isLoop=> $isLoop);
  }

  # circuits from position
  if (@circuitToPosition) {
    reversePoints($points);
    deleteField2(points=> $points, field=> "distance");
    my @a = @circuitToPosition;
    while (@a) {
      my $pos = shift @a;
      my $circuits = shift @a // 1;
      my $repeats = shift  @a // 1;
      note("processing circuitToPosition $pos...\n");
      $points = circuitFromPosition(points=> $points, position=> $pos, circuits=> $circuits, repeats=> $repeats, isLoop=> $isLoop);
    }
    reversePoints($points);
  }

  # start and finish circuits
  # note this could create segment fragments
  my $circuitsAdded = 0;
  if ( ($startCircuits > 0) && ($startCircuitDistance >= 0) ) {
    note("adding $startCircuits start circuits...\n");
    # get start circuit points
    my @circuitPoints = ();
    addDistanceField(points=> $points) unless ( defined $points->[0]->{distance} );
    my $i = 0;
    while ($i <= $#$points) {
      if ($points->[$i]->{distance} <= $startCircuitDistance) {
        note("adding point to circuit list...\n");
        push @circuitPoints, \%{$points->[$i]};
        $i ++;
      } else {
        last;
      }
    }
    if (@circuitPoints) {
      my @newPoints;
      for my $i (1 .. $startCircuits) {
        push @newPoints, @circuitPoints;
        note("adding circuit point...\n");
        $circuitsAdded ++;
      }
      push @newPoints, @$points;
      $points = \@newPoints;
    }
  }
  if ( ($finishCircuits > 0) && ($finishCircuitDistance >= 0) ) {
    note("adding $finishCircuits finishing circuits...\n");
    addDistanceField(points=> $points) unless ( defined $points->[0]->{distance} );
    my @circuitPoints = ();
    my $i = 0;
    for my $p ( @$points ) {
      if ($p->{distance} < $finishCircuitDistance) {
        next;
      }
      push @circuitPoints, \%$p;
    }
    if (@circuitPoints) {
      for my $i (1 .. $finishCircuits) {
        push @$points, @circuitPoints;
        $circuitsAdded ++;
      }
    }
  }
  deleteField2(points=> $points, field=> "distance") if ($circuitsAdded > 0);

  # check for snapping
  if ( ($snap > 0) && ($snapDistance >= 0) ) {
    note("snapping repeated points (pass 1)...\n");
    $points =
      snapPoints(
                 points=> $points,
                 snap=> $points,
                 snapDistance=> $snapDistance,
                 snapAltitude=> $snapAltitude,
                 snapTransition=> $snapTransition,
                 spacing=> $spacing,
                );

  }

  # spline of corners
  if ( $splineRadians > 0 ) {
    note("corner splines, pre-smoothing...\n");
    $points = addSplines(points=> $points, minRadians=> $splineRadians, maxRadians=> $splineMaxRadians, isLoop=> $isLoop, splineType=> "spline", start=> $splineStart, end=> $splineEnd);
  }

  # arc fit of corners
  if ( $arcFitRadians > 0 ) {
    note("corner arcFits, pre-smoothing...\n");
    $points = addSplines(points=> $points, minRadians=> $arcFitRadians, maxRadians=> $arcFitMaxRadians, isLoop=> $isLoop, splineType=> "arcFit", start=> $arcFitStart, end=> $arcFitEnd);
  }

  # add distance field
  addDistanceField(points=> $points);
  my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);

  # automatic interpolation at corners
  if ( $autoSpacing && (($lSmooth > 0) || ($minRadius > 0)) ) {
    $points =
      doAutoSpacing(
                    points=> $points,
                    isLoop=> $isLoop,
                    lSmooth=> $lSmooth,
                    smoothAngle=> $smoothAngle,
                    minRadius=> $minRadius,
                   )
    }


  # interpolation if requested
  if ( @$points && ($spacing > 0) ) {
    $points =
      doPointInterpolation(
                           points=> $points,
                           isLoop=> $isLoop,
                           spacing=> $spacing,
                          );
  }

  # straight processing
  # if circular fits are required, those should be done before smoothing, so smoothing can
  # reduce the anomalies.
  if (@straight || (@straightStart) || (@straightEnd)) {
    note("processing straight fit(s)...\n");
    processStraight(points=> $points, straight=> \@straight, straightStart=> \@straightStart, straightEnd=> \@straightEnd, isLoop=> $isLoop);
  }

  # straight processing
  # if circular fits are required, those should be done before smoothing, so smoothing can
  # reduce the anomalies.
  if (@circle || (@circleStart) || (@circleEnd)) {
    note("processing circular fit(s)\n");
    processCircle(points=> $points, circle=> \@circle, circleStart=> \@circleStart, circleEnd=> \@circleEnd, isLoop=> $isLoop);
  }

  # check for snapping
  # this is done after point interpolation as well as before
  # since widely spaced points may not show a match
  if ( ($snap > 0) && ($snapDistance >= 0) ) {
    note("snapping repeated points (pass 2)...\n");
    $points =
      snapPoints(
                 points=> $points,
                 snap=> $points,
                 snapDistance=> $snapDistance,
                 snapAltitude=> $snapAltitude,
                 snapTransition=> $snapTransition,
                 spacing=> $spacing,
                );

  }

  # various smoothing passes:
  # 1  : position
  # 2  : altitude
  # 3  : position auto-smoothing (not yet implemented)
  # 4  : altitude auto-smoothing
  #
  # smoothing parameter with auto-smoothing is normalized,
  # so tuned for smoothing = 1 being reasonable choice
  #
  # this is an update on prior smoothing code
  # this code creates a smooth field if either selective smoothing, or a start/finish
  # to smoothing is chosen.  Only if uniform smoothing is being applied is a single
  # sigma value sent to the smoothing code

  addDistanceField(points=> $points)
    if (
        ($lSmooth > 0)     ||
        ($zSmooth > 0)     ||
        ($lAutoSmooth > 0) ||
        ($zAutoSmooth > 0) ||
        @selectiveSmooth   ||
        @selectiveSmoothZ  ||
        @selectiveSmoothG
       );

  # keep track of the first and last points, if anchoring is happening
  my @endPoints  = ($points->[0], $points->[-1]);

  for my $smoothLoop ( 0, 1, 2, 4 ) {
    my %fsigma;
    my $smooth;
    my $autoSmooth;
    $smooth = $lSmooth     if ($smoothLoop == 0);
    $smooth = $zSmooth     if ($smoothLoop == 1);
    $smooth = $gSmooth     if ($smoothLoop == 2);
    $smooth = $lAutoSmooth if ($smoothLoop == 3);
    $smooth = $zAutoSmooth if ($smoothLoop == 4);
    $smooth = $gAutoSmooth if ($smoothLoop == 5);

    # selective smoothing
    my $sSmooth =
      ($smoothLoop == 0) ? \@selectiveSmooth :
      ($smoothLoop == 1) ? \@selectiveSmoothZ :
      ($smoothLoop == 2) ? \@selectiveSmoothG :
      [];

    next unless ( ($smooth > 0) || @$sSmooth );

    my $sigma0;
    if ($smoothLoop == 3) {
      # smooth field is generated from data
      note("calculating auto sigma\n");
      calcSmoothingSigma( points=> $points, sigmaFactor=> $smooth );
      $sigma0 = 0;
    } else {
    # parse and check the selective smoothing parameters
      my $i = 0;
      my $sPrev;
      my @smoothSigmas;
      my @smoothPositions;
      my $positiveSigmaFound = ($smooth > 0);
      while ($i < @$sSmooth) {
        my $sigma = $sSmooth->[$i]; # value
        die("negative sigma value found in selective smoothing list: @$smooth\n")
          if ($sigma < 0);
        $positiveSigmaFound ||= ($sigma > 0);
        push @smoothSigmas, $sigma;
        $i ++;
        last if ($i >= @$sSmooth);
        my $s = $sSmooth->[$i]; # position
        die("position values in selective smoothing list must be in non-decreasing order\n")
          if ( (defined $sPrev) && ($s < $sPrev) );
        push @smoothPositions, $s;
        $sPrev = $s;
        $i ++;
      }

      if ( $positiveSigmaFound ) {
        note("smoothing...",
             ($smoothLoop==0) ? "position" :
             ($smoothLoop==1) ? "altitude" :
             ($smoothLoop==2) ? "gradient" :
             ($smoothLoop==3) ? "position(auto)" :
             ($smoothLoop==4) ? "altitude(auto)" :
             ($smoothLoop==5) ? "gradient(auto)" :
             "other",
             "\n");

        $sigma0 = $smooth;      # constant component of smoothing

        # convert constant smoothing to a smoothing field if there's a smoothStart and/or smoothEnd
        if ( (defined $smoothStart) || (defined $smoothEnd) ) {
          $positiveSigmaFound = 0;
          my $lambda = 10 + 4 * $sigma0;
          for my $i ( 0 .. $#$points ) {
            my $s = $points->[$i]->{distance};
            my $sigma;
            if ( (defined $smoothStart) && (defined $smoothEnd) && ($smoothEnd < $smoothStart) ) {
              $sigma = $sigma0 * (transition(($smoothStart - $s) / $lambda) * transition(($s - $smoothEnd) / $lambda));
            } else {
              $sigma = $sigma0;
              $sigma *= transition(($smoothStart - $s) / $lambda) if (defined $smoothStart);
              $sigma *= transition(($s - $smoothEnd) / $lambda)   if (defined $smoothEnd);
            }
            $points->[$i]->{sigma} = ($sigma < 0.01) ? 0 : $sigma; # ignore small values of sigma
            $positiveSigmaFound ||= ($points->[$i]->{sigma} > 0);
          }
          $sigma0 = 0;
          deleteField2(points=> $points, field=> "sigma") unless ($positiveSigmaFound);
        }

        if (@smoothSigmas) {
          if (@smoothPositions) {
            # construct sigma field from selective smoothin
            addDistanceField(points=> $points)
              unless (defined $points->[0]->{distance});
            my $positiveSigmaFound = 0;
            my @sigmas = ();
            for my $i ( 0 .. $#smoothSigmas ) {
              my $sigma = $smoothSigmas[$i];
              my $start = $smoothPositions[$i - 1] if ($i > 0);
              my $end   = $smoothPositions[$i] if ($i < @smoothPositions);
              my $lambda1 = 10;
              my $lambda2 = 10;
              $lambda1 += 4 * abs($sigma - $smoothSigmas[$i - 1]) if ($i > 0);
              $lambda2 += 4 * abs($sigma - $smoothSigmas[$i + 1]) if ($i < $#smoothSigmas);

              for my $j ( 0 .. $#$points ) {
                my $s = $points->[$j]->{distance};
                die("undefined distance found for point $j\n") unless defined $s;
                my $sigmaEff;
                if ( (defined $start) && (defined $end) ) {
                  $sigmaEff = $sigma * (transition(($start - $s) / $lambda1) * transition(($s - $end) / $lambda2));
                } else {
                  $sigmaEff = $sigma;
                  $sigmaEff *= transition(($start - $s) / $lambda1) if (defined $start);
                  $sigmaEff *= transition(($s - $end) / $lambda2)   if (defined $end);
                }
                $sigmas[$j] //= 0;
                $sigmas[$j] += $sigmaEff if ($sigmaEff > 0.01);
              }
            }
            for my $i ( 0 .. $#sigmas ) {
              $points->[$i]->{sigma} =
                (
                 ((defined $points->[$i]->{sigma}) && ($points->[$i]->{sigma} > 0)) ?
                 sqrt($points->[$i]->{sigma} ** 2 + $sigmas[$i] ** 2) :
                 $sigmas[$i]
                );
            }
          } else {
            # if only a sigma value was provided in selective smoothing, then add it to any sigma0
            $sigma0 = sqrt($sigma0 ** 2 + $smoothSigmas[0] ** 2);
          }
        }
      }
    }

    my @keys;
    my $useCornerEffect;
    if ( $smoothLoop % 3 == 0 ) {
      @keys = ("ele",  "latlon");
      $useCornerEffect = 0;
    } elsif ( $smoothLoop % 3 == 1 ) {
      @keys = ("ele");
      $useCornerEffect = 0;
    } elsif ( $smoothLoop % 3 == 2 ) {
      @keys = ("gradient");
      $useCornerEffect = 1;
    }

    addGradientField(points=> $points, isLoop=> $isLoop)
      if ($smoothLoop % 3 == 2);

    for my $key ( @keys ) {
      $points =
        smoothing(
                  sigmaField=>  (defined $points->[0]->{sigma}) ? "sigma" : "",
                  isLoop=>      $isLoop,
                  points=>      $points,
                  sigma=>       $sigma0,
                  cornerEffect=> ($useCornerEffect ? $cornerEffect : 0),
                  fields=>      (($key eq "latlon") ? ["lat", "lon"] : [$key]),
                 );
    }

    integrateGradientField(points=> $points, isLoop => $isLoop)
      if ($smoothLoop % 3 == 2);

  }

  # anchoring: return start point and, if not a loop, finish point to original values
  # if anchoring requested
  if ( $anchorSF && (! $isLoop) ) {
    addDistanceField(points=> $points) unless (exists $points->[0]->{distance});

    for my $d ( 1, -1 ) {
      my %sigma = (
                   ele => sqrt($lSmooth ** 2 + $zSmooth ** 2),
                   lat => $lSmooth,
                   lon => $lSmooth,
                  );

      # the point to anchor
      my $i0 = ($d == 1) ? 0 : -1;

      # if autosmoothing is used, then add that in
      $sigma{ele} = sqrt($sigma{ele} ** 2 + ($points->[$i0]->{sigma} * $zAutoSmooth) ** 2)
        if ( (defined $points->[$i0]->{sigma}) && ($zAutoSmooth > 0) );

      # this is from BEFORE smoothing since we've not updated the distance field: this is important
      my $courseDistance = $points->[-1]->{distance} - $points->[0]->{distance};

      for my $key ( keys %sigma ) {
        if ($sigma{$key} > 0) {
          my $dy0 = $points->[$i0]->{$key} - $endPoints[$i0]->{$key};

          # step thru points
          my $i = $i0 % @$points;

          my $dsMax = 6 * $sigma{$key};
          while ( ($i <= $#$points) && ($i >= 0) ) {

            # distance: using values calculated from the original course, not
            # distorted by smoothing, since smoothing can collapse points,
            # and point of anchoring is to reduce collapse
            my $s = abs(distanceDifference($points->[$i], $points->[$i0], $courseDistance, $isLoop));
            last if ($s > $dsMax );

            my $u = $s / $sigma{$key};
            my $w = exp(-$u ** 2 / 2) * (1 - $s / $courseDistance);
            $points->[$i]->{$key} -= $w * $dy0;

            $i += $d;
          }
        }
      }
    }
  }
  deleteField2(points=> $points, field=> "sigma") unless ($addSigma);

  # spline again post-smoothing, if requested
  if ( ($splineRadians > 0) && (($lSmooth > 1) || ($zSmooth > 0)) ) {
    note("corner splines, post-smoothing...\n");
    my $points = addSplines(points=> $points, minRadians=> $splineRadians, maxRadians=> $splineMaxRadians, isLoop=> $isLoop, splineType=> "spline", start=> $splineStart, end=> $splineEnd);
  }

  if ( ($arcFitRadians > 0) && (($lSmooth > 1) || ($zSmooth > 0)) ) {
    note("corner arcFit, post-smoothing...\n");
    $points = addSplines(points=> $points, minRadians=> $arcFitRadians, maxRadians=> $arcFitMaxRadians, isLoop=> $isLoop, splineType => "arcFit", start=> $arcFitStart, end=> $arcFitEnd);
  }

  #
  # flatten selected sections
  # points come in sets of 4: start point, altitude, finish point, altitude, lambda
  #
  if (@flatten) {
    note("flattening...\n");
    addDistanceField(points=> $points);
    for (my $nf = 0; $nf < @flatten; $nf += 5) {
      my $flattenStart = $flatten[$nf];
      my $zFlatten1    = $flatten[$nf + 1] if ($nf < $#flatten);
      my $flattenStop  = $flatten[$nf + 2] if ($nf + 1 < $#flatten);
      my $zFlatten2    = $flatten[$nf + 3] if ($nf + 2 < $#flatten);
      my $lambda       = $flatten[$nf + 4] if ($nf + 3 < $#flatten);
      $lambda //= 10 + sqrt($zSmooth ** 2 + $lSmooth ** 2);
      $flattenStop //= ($points->[-1]->{distance} + 1000 * $lambda + 1000);
      $zFlatten2   //= $zFlatten1;
      note("flattening course from $flattenStart ($zFlatten1 meters) to $flattenStop ($zFlatten2 meters)\n");
      for my $i ( 0 .. $#$points ) {
        my $s = $points->[$i]->{distance};
        my $z = $points->[$i]->{ele};
        if ($s >= $flattenStart) {
          my $zFlatten = ( $zFlatten1 * ($flattenStop - $s) + $zFlatten2 * ($s - $flattenStart) ) / ($flattenStop - $flattenStart);
          if ($flattenStop >= $s) {
            $points->[$i]->{ele} = $zFlatten;
            note("point $i: flattened to $points->[$i]->{ele}\n");
          } elsif ($s < $flattenStop + $lambda) {
            my $f = (1 + cos($pi * ($s - $flattenStop) / $lambda)) / 2;
            $points->[$i]->{ele} = $f * $zFlatten + (1 - $f) * $z;
          }
        } elsif ($s > $flattenStart - $lambda) {
          my $zFlatten = ( $zFlatten1 * ($flattenStop - $s) + $zFlatten2 * ($s - $flattenStart) ) / ($flattenStop - $flattenStart);
          my $f = (1 + cos($pi * ($flattenStart - $s) / $lambda)) / 2;
          $points->[$i]->{ele} = $f * $zFlatten + (1 - $f) * $z;
        }
      }
    }
  }

  #
  # flatten intersections
  # if roads cross and one or both of them are sloped, this creates ugly intersections
  # in RGT, where one of the directions tends to float in the air.  This flattens
  # roads proximate to intersections
  #
  if ( $fixCrossings ) {
    note("fixing crossings...\n");

    # calculate a crossingX: minimum crossing X-product
    my $crossingX = ((defined $crossingAngle) && ($crossingAngle >= 0)) ? abs(sin($crossingAngle * $deg2rad)) : sin($pi / 16);

    #
    # create a distance field
    #
    addDistanceField(points=> $points);

    #
    # create simplified version of profile
    # monitor the direction and when the direction changes enough, add a point
    #
    my @simplified = (0, 1);
    die("course lacks at least two points... quitting\n") unless (@$points > 1);
    my $simplifiedAngle = $pi / 24;
    for my $i ( 2 .. $#$points ) {
      my $angle = latlngAngle($points->[$i], $points->[$simplified[-1]], $points->[$simplified[-2]]);
      # add points which cause an angle change
      if (
          (defined $angle) &&
          (abs($angle) > $simplifiedAngle) &&
          (($isLoop || ($i < $#$points)))
         ) {
        my $a1 = latlngAngle($points->[($i + 1) % @$points], $points->[$i], $points->[$simplified[-1]]);
        my $a2 = latlngAngle($points->[($i + 1) % @$points], $points->[$i], $points->[$i - 1]);
        if (
            ((defined $a1) && (abs($a1) > $simplifiedAngle)) ||
            ((defined $a2) && (abs($a2) > $simplifiedAngle))
           ) {
          push @simplified, $i;
        }
      }
    }
    if ( $isLoop ) {
      push @simplified, 0
        unless (pointsAreClose($points->[0], $points->[$simplified[-1]]));
    } else {
      push @simplified, $#$points unless ( ($simplified[-1] == $#$points) || pointsAreClose($points->[-1], $points->[$simplified[-1]]) );
    }

    # search for crossings on simplified route
    my @crossings;

    for my $j ( 1 .. $#simplified - 1 ) {
      for my $i ( 0 .. $j - 1 ) {
        if ((my @fs = segmentIntercept( [$points->[$simplified[$i]], $points->[$simplified[$i + 1]]], [$points->[$simplified[$j]], $points->[$simplified[$j + 1]]] )) == 2) {
          # note("intercept found between simplified segments $i and $j: @fs\n");

          # there is a crossing between simplified segments i and j
          # but the actual intersection might be from adjacent segments... so check those if the intersection was close to the edge
          my $u1 =  (($fs[0] < 0.5) && ($i > 0)) ? $simplified[$i - 1] : $simplified[$i];
          my $u2 =  ((($fs[0] > 0.5) && ($i < $#simplified - 1)) ? $simplified[$i + 2] : $simplified[$i + 1]) - 1;
          my $v1 =  (($fs[1] < 0.5) && ($j > 0)) ? $simplified[$j - 1] : $simplified[$j];
          my $v2 =  ((($fs[1] > 0.5) && ($j < $#simplified - 1)) ? $simplified[$j + 2] : $simplified[$j + 1]) - 1;

          # find the specific segments and positions where the crossings occur
          my $crossingsFound = 0;
          for my $u ( $u1 .. $u2 ) {
            for my $v ( $v1 .. $v2 ) {
              if ( (my @gs =
                    segmentIntercept(
                                     [$points->[$u], $points->[($u + 1) % @$points]],
                                     [$points->[$v], $points->[($v + 1) % @$points]]
                                    )
                   ) == 2
                 ) {
                my $up1 = ($u + 1) % @$points;
                my $vp1 = ($v + 1) % @$points;
                my @cNew;
                push @cNew, interpolatePoint($points->[$u], $points->[$up1], $gs[0]);
                my $z1 = $cNew[-1]->{ele};
                push @cNew, interpolatePoint($points->[$v], $points->[$vp1], $gs[1]);
                my $z2 = $cNew[-1]->{ele};
                my $zAvg = ($z1 + $z2) / 2;

                # adjust the altitude of the crossing points
                if (abs(latlngCrossProduct($points->[$u], $points->[$up1], $points->[$v], $points->[$vp1])) > $crossingX) {
                  if (abs($z1 - $z2) < $crossingHeight / 2) {
                    note("crossing @ $cNew[-2]->{distance} m and $cNew[-1]->{distance} m: setting level crossing altitude to $zAvg\n");
                    $cNew[-2]->{ele} = $zAvg;
                    $cNew[-1]->{ele} = $zAvg;
                  } elsif (abs($z1 - $z2) < $crossingHeight) {
                    $cNew[-2]->{ele} = $zAvg + ($z1 <=> $zAvg) * $crossingHeight / 2;
                    $cNew[-1]->{ele} = $zAvg + ($z2 <=> $zAvg) * $crossingHeight / 2;
                    note("crossing @ $cNew[-2]->{distance} m and $cNew[-1]->{distance} m: setting overpass altitudes to $cNew[-2]->{ele} and $cNew[-1]->{ele}\n");
                  }
                  push @crossings, @cNew;
                  $crossingsFound ++;
                }
              }
            }
          }
        }
      }
    }
    note("total crossings = ", scalar(@crossings), "\n");

    $saveCrossingsCSV  //= 0;
    if ($saveCrossingsCSV) {
      if (defined ( my $fName = setFileNameSuffix($file, "_crossings.csv"))) {
        open my $fcrossings, ">$fName";
        print $fcrossings  "lon,lat,ele,distance\n";
        for my $p ( @crossings ) {
          print $fcrossings "$p->{lon},$p->{lat},$p->{ele},$p->{distance}\n";
        }
        close $fcrossings;
      }
    }

    # crossing parameters
    my $r1 = $rCrossings;
    my $r2 = $crossingTransition // 3 * $rCrossings;
    my $dr = $r2 - $r1;
    my $r3 = ($r1 + $r2) / 2;
    my $r4 = (3 * $r1 + $r2) / 4;

    # sort crossings
    # create interpolated point list
    my @si;
    for my $c ( @crossings ) {
      my $s = $c->{distance};
      push @si, ($s - $r2, $s - $r3, $s - $r4, $s - $r1, $s, $s + $r1, $s + $r4, $s + $r3, $s + $r2);
    }

    @si = sort { $a <=> $b } @si;

    if (@si) {
      my @siNew = ( $si[0] );
      for my $j ( 1 .. $#si ) {
        push @siNew, $si[$j] if (abs($si[$j] - $siNew[-1]) > 0.5);
      }

      @si = @siNew;
    }

    # report simplified route
    if ( $saveSimplifiedCourse && (defined ( my $fName = setFileNameSuffix($file, "_simplifiedCourse.csv" )))) {
      open my $fsimplified, ">$fName";
      print $fsimplified  "lon,lat\n";
      for my $i ( 0 .. $#simplified ) {
        print $fsimplified "$points->[$simplified[$i]]->{lon},$points->[$simplified[$i]]->{lat}\n";
      }
      close $fsimplified;
    }

    # interpolate points
    # si: position of point to be interpolated
    # i : index to the existing points
    # s1: distance to point i
    # s2: distance to point 1 + 1
    # j : index into interpolated point array
    if ( @si) {
      note("adding additional points at crossings...\n");
      my @newPoints = $points->[0];
      my $j = 0;
      for my $i ( 0 .. $#$points - 1) {
        my $s1 = $points->[$i]->{distance};
        my $s2 = $points->[$i + 1]->{distance};
        $j ++ while ( ($j <= $#si) && ($si[$j] <= $s1) );
        while (($j < @si) && ($s2 > $si[$j])) {
          if ( (abs($si[$j] - $s1) > 0.5) && (abs($si[$j] - $s2) > 0.5) ) {
            my $f = ($si[$j] - $s1) / ($s2 - $s1);
            push @newPoints, interpolatePoint($points->[$i], $points->[$i + 1], $f);
          }
          $j ++;
        }
        push @newPoints, $points->[$i + 1]
      }
      $points = \@newPoints;
    }

    #
    # smooth altitude at crossings
    #
    # width of road is 4 meters
    # flatten road for at least this distance

    my $k = $pi / $dr;

    for my $p ( @$points ) {
      my $sp = $p->{distance};
      for my $c ( @crossings ) {
        my $sc = $c->{distance};
        my $ds = abs($sp - $sc);
        if ($ds < $r2) {
          if ($ds < $r1) {
            $p->{ele} = $c->{ele};
          } else {
            my $f = (1 + cos($k * ($ds - $r1))) / 2;
            $p->{ele} = $f * $c->{ele} + (1 - $f) * $p->{ele};
          }
        }
      }
    }
  }

  #
  # create named segments

  note("number of named segments = ", scalar(@namedSegments), "\n");
  addDistanceField(points=> $points)
    if ( @namedSegments );

  for my $s ( @namedSegments ) {
    chomp($s);

    my ($start, $end, $name) = split(",", $s);
    for my $a ($start, $end, $name) {
      $a =~ s/^\s*(.*?)\s*$/$1/;
    }
    if ((! defined $start) || ($start eq "") || ($start eq "start")) {
      $start = 0;
    }
    if ((! defined $end) || ($end eq "") || ($end eq "end")) {
      $end = $points->[-1]->{distance};
    }
    note("defining segment \"$name\" from $start meters to $end meters ...\n");
    my ($pStart, $pEnd);
    ($points, $pStart) = pointAtPosition($start, $points, $isLoop);
    die("ERROR: unable to find the segment start point at positon $start.\n") unless (defined $pStart);
    ($points, $pEnd)   = pointAtPosition($end, $points, $isLoop);
    die("ERROR unable to find the segment end point at positon $end.\n") unless (defined $pEnd);

    # find a segment number
    my $nS = 1;
    $nS ++ while ($segmentDefined{$nS});
    my @pNew = ();
    for my $i ( 0 .. $pStart ) {
      push @pNew, $points->[$i];
    }
    for my $i ( $pStart .. $pEnd ) {
      my %p = %{$points->[$i]};
      $p{segment} = $nS;
      push @pNew, \%p;
    }
    for my $i ( $pEnd .. $#$points ) {
      push @pNew, $points->[$i];
    }
    $points = \@pNew;
    $segmentName{$nS} = $name;
    $segmentDefined{$nS} ++;
    note("defined segment $name from point number $pStart to point number $pEnd of ", scalar(@$points), "\n");
  }

  #
  # cropping: shorten distance of original GPX
  # note distance is calculated here... can change from lane shifts
  #

  # if crops may have been specified with negative append or prepend...
  if ((! $isLoop) && (((! (defined $cropMax)) || ($cropMax <= 0)) && ($append < 0))) {
    $cropMax = calcCourseDistance(points=> $points, isLoop=> $isLoop) + $append;
    $cropMax -= $prepend if ($prepend > 0);  # adjust for prepend since cropping done after prepend
  }
  if ((! defined $cropMin) || ($cropMin <= 0) && ($prepend < 0)) {
    $cropMin = -$prepend;
  }

  if ( ((defined $cropMin) && ($cropMin > 0)) || ((defined $cropMax) && ($cropMax > 0)) ) {
    $points = cropPoints(points=> $points, isLoop=> $isLoop, min=> $cropMin, max=> $cropMax);
    note("points remaining after cropping = ", scalar(@$points), "\n");
  }

  #
  # pruning: remove colinear points
  # out-and-back route generation requires identical paths, so follows this
  #

  if ( $prune ) {
    # prune in each direction
    for my $n ( 0, 1 ) {
      my $pruneCount = 0;
      my @pNew = ( $points->[0] );
      for my $i ( 1 .. $#$points - 1 ) {
        my $p1 = $pNew[-1];
        my $p2 = $points->[$i + 1];
        my $p3 = $points->[$i];
        if ( isPointPrunable( points=> [$p1, $p2, $p3], distance=> $pruneD, X=> $pruneX, dg=> $prunedg)  ) {
          $pruneCount ++;
        } else {
          push @pNew, $p3;
        }
      }
      push @pNew, $points->[-1];
      @pNew = reverse @pNew;
      $points = \@pNew;
      deleteDerivedFields($points);
      note("prune loop $n: pruned $pruneCount points.\n");
    }
  }


  #
  # calculate a lane shift field, if we're doing lane shifts
  # shiftStart < shiftEnd: shifting between shiftStart and shiftEnd
  # shiftStart > shiftEnd: shifting up to shiftEnd, then after shiftStart
  #
  if ( ($laneShift != 0) || (@selectiveLaneShift > 0) ) {
    note("lane shift...\n");
    addDistanceField(points=> $points) unless (defined $points->[0]->{distance});
    # process lane shift
    if ( $laneShift != 0 ) {
      my $shiftDistance = $shiftTransition // 20 * abs($laneShift) ** (2/3);
      for my $p ( @$points ) {
        my $s = $p->{distance};
        my $shift = $laneShift;
        if ( (defined $shiftStart) && (defined $shiftEnd) && ($shiftEnd < $shiftStart) ) {
          $shift *= (transition(($shiftStart - $s) / $shiftDistance) * transition(($s - $shiftEnd) / $shiftDistance));
        } else {
          $shift *= transition(($shiftStart - $s) / $shiftDistance) if (defined $shiftStart);
          $shift *= transition(($s - $shiftEnd) / $shiftDistance)   if (defined $shiftEnd);
        }
        $p->{shift} = $shift;
      }
    } else {
      for my $p ( @$points ) {
        $p->{shift} = 0;
      }
    }

    # process selective lane shift
    if (@selectiveLaneShift > 0) {
      my $i = 0;
      my @shifts;
      my @positions;
      my $sPrev;
      while ($i < @selectiveLaneShift) {
        my $shift = $selectiveLaneShift[$i];  # value
        push @shifts, $shift;
        $i ++;
        last if ($i >= @selectiveLaneShift);
        my $s = $selectiveLaneShift[$i]; # position
        die("position values in selective smoothing list must be in non-decreasing order\n")
          if ( (defined $sPrev) && ($s < $sPrev) );
        push @positions, $s;
        $sPrev = $s;
        $i ++;
      }

      # if it's a loop, we may need to add a transition at the wrap-around point
      my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop)
        if ($isLoop);

      # shift transition length.... use a fixed value for selective shift
      my $shiftDistance = $shiftTransition // 20;

      # build the course segment by segment
      my $firstShift;
      my $lastShift;
      for ( my $i = 0; $i < @shifts; $i ++ ) {
        if ($shifts[$i] != 0) {
          for my $p ( @$points ) {
            my $s = $p->{distance};
            my $f = 1;

            # segment start
            my $s1;
            $s1 = $positions[$i - 1] if ($i > 0);
            $s1 //= 0 if ($isLoop);
            $s1 = 0 if ($isLoop && ($s1 < 0));
            $firstShift = $shifts[$i] if ($isLoop && ($s1 == 0));

            # segment end
            my $s2;
            $s2 = $positions[$i] if ($i < @positions);
            $s1 //= $courseDistance if ($isLoop);
            $s2 = $courseDistance if ($isLoop && ($s2 > $courseDistance));
            $lastShift //= $shifts[$i] if ($isLoop && ($s2 == $courseDistance));

            last if ($s2 <= $s1);

            $f *= transition(($s1 - $s) / $shiftDistance) if (defined $s1);
            $f *= transition(($s - $s2) / $shiftDistance) if (defined $s2);

            $p->{shift} += $shifts[$i] * $f;
          }
        }
      }

      # handle wrap-around
      # this assumes the only shift within transition distance is the last one (may not be true)
      if ($isLoop && (defined $firstShift) && ($firstShift != 0)) {
        for my $p ( reverse @$points ) {
          last if ($courseDistance - $p->{distance} > $shiftDistance);
          $p->{shift} += $firstShift * transition(($courseDistance - $p->{distance}) / $shiftDistance);
        }
      }
      if ($isLoop && (defined $lastShift) && ($lastShift != 0)) {
        for my $p ( @$points ) {
          $p->{shift} += $lastShift * transition($p->{distance} / $shiftDistance);
        }
      }
    }
  }

  #
  # if an out-and-back is to be generated, then generate the return points
  # (these will be added to the main points list later)
  # however, make copies of each invidual hash, don't just copy hash pointers,
  # or data will get clobbered
  #
  my $rPoints = [];
  if ( (defined $rTurnaround) && ($rTurnaround > 0) ) {
    note("out-and-back...\n");
    for my $p (reverse @$points) {
      my %h = %$p;
      push @$rPoints, \%h;
    }
    deleteDerivedFields($rPoints);
  }

  #
  # lane shift:
  # shift lanes to the right (positive) or left (negative)
  #
  if ( ($laneShift != 0) || (@selectiveLaneShift > 0) ) {
    $points  = applyLaneShift(points=> $points, isLoop=> $isLoop);
    deleteField2(points=> $points, field=> "shift");
    deleteDerivedFields($points);
    if (@$rPoints) {
      $rPoints = applyLaneShift(points=> $rPoints, isLoop=> $isLoop);
      deleteField2(points=> $rPoints, field=> "shift");
    }
  }

  # for extendback, we calculate the crop crop position here: the loop counts as part
  # of the extension distance
  my $cropBack = 0;
  if ($extendBack > 0) {
    $cropBack = calcCourseDistance(points=> $points) + $extendBack;
    note("calculating cropping position for extendBack = $cropBack\n");
  }

  #
  # generate turn-around loops, if requested
  # last two points of outward leg, first two points of return leg, determine direction
  #
 pathLoop: for my $nPath ( 0, 1 ) {
    my $R = ($nPath == 0) ? $rTurnaround : $rLap;
    next pathLoop unless ((defined $R) && ($R > 0));

    my $ps1 = ($nPath == 0) ? $points : $rPoints;
    my $ps2 = ($nPath == 0) ? $rPoints : $points;
    next pathLoop unless ((@$ps1 > 1) && (@$ps2 > 1));

    # find average direction of the two legs
    my ($dx1, $dy1) = latlng2dxdy($ps1->[-2], $ps1->[-1]);
    my $dir1 = atan2($dy1, $dx1);
    my ($dx2, $dy2) = latlng2dxdy($ps2->[1], $ps2->[0]);
    my $dir2 = atan2($dy2, $dx2);
    my $dir = averageAngles($dir1, $dir2);

    # create the loop
    note("creating turn-around loop...\n");
    my $loop = makeLoop(points=> [$ps1->[-1], $ps2->[0]], direction=> $dir, radius=> $R, defaultSign=> $loopSign, segmentNames=> \%segmentName);
    push @$ps1, @$loop;
  }

  # if we made alap turnaround, then this is now a loop course
  $isLoop = 1
    if ((defined $rLap) && ($rLap > 0));


  # eliminate temporary fields (for now)
  for my $k ( "distance", "shift" ) {
    for my $ps ( $points, $rPoints ) {
      deleteField2(points=> $ps, field=> $k);
    }
  }

  #
  # store points in the hash
  #
  if (@$rPoints) {
    note("points on outbound = ", scalar(@$points), "\n");
    note("points on inbound = ", scalar(@$rPoints), "\n");
    push @$points, @$rPoints;
  }

  # for -extendBack, crop it here:
  $points = cropPoints(points=> $points, isLoop=> $isLoop, max=> $cropBack)
    if ($cropBack > 0);

  #
  # turn-around loops within the course, if requested
  #
  if ( (defined $rUTurn) && (abs($rUTurn) > 1) ) {
    note("checking for U-turn loops...\n");

    # get rid of duplicate point at end
    my $pointPopped = pointsAreClose($points->[0], $points->[-1]);
    pop @$points if ($pointPopped);

    # two sweeps: one for 3-point turns, the next for 4-point turns.
    for my $turnType (3, 4) {
      my @pNew = ();
      my $i = 0;
      push @pNew, $points->[$i++]
        if (! $isLoop);
      while ($i <= $#$points) {
        push @pNew, $points->[$i];

        if (pointsAreClose($points->[$i], $points->[($i + 1) % @$points])) {
          $i ++;
          next;
        }

        # select points: check for duplicate points
        my $h = ($i - 1) % @$points;
        $h = ($h - 1) % @$points if (($h != $i) && pointsAreClose($points->[$h], $points->[$i]));
        my $j = ($i + 1) % @$points;
        my $k = ($j + 1) % @$points;
        if (($j != $i) && pointsAreClose($points->[$j], $points->[$i])) {
          $j = ($j + 1) % @$points;
          $k = ($k + 1) % @$points;
        }
        $k = ($k + 1) % @$points if (($k != $i) && pointsAreClose($points->[$j], $points->[$k]));

        if (
            ($turnType == 3) &&
            ($isLoop || ($i < $#$points)) &&
            UTurnCheck($points->[$h], $points->[$i], $points->[$i], $points->[$j])
           ) {
          my $d1 = latlngDirection($points->[$h], $points->[$i]);
          my $d2 = latlngDirection($points->[$j], $points->[$i]);
          note("3-point U-turn detected @\n",
               "   1: point ", $h + 1, " of ", scalar(@$points), " ($points->[$h]->{lon}, $points->[$h]->{lat})\n",
               "   2: point ", $i + 1, " of ", scalar(@$points), " ($points->[$i]->{lon}, $points->[$i]->{lat})\n",
               "   3: point ", $j + 1, " of ", scalar(@$points), " ($points->[$j]->{lon}, $points->[$j]->{lat})\n",
               "   directions = ", $d1 / $deg2rad, ", ", $d2 / $deg2rad, "\n");
          my $dir = averageAngles($d1, $d2);
          my $loop = makeLoop(points=> [$points->[$i], $points->[$i]], direction=> $dir, radius=> $rUTurn, defaultSign=> $loopSign, segmentNames=> \%segmentName);
          push @pNew, @$loop;
          push @pNew, \%{$points->[$i]}; # put a copy of the turn-around point here
        } elsif (
                 ($turnType == 4) &&
                 ($isLoop || (($i > 0) && ($i < $#$points - 1))) &&
                 UTurnCheck($points->[$h], $points->[$i], $points->[$j], $points->[$k]) &&
                 (latlngDistance($points->[$i], $points->[$j]) < 20)
                 # (latlngDotProduct($points->[$h], $points->[$i], $points->[$i], $points->[$j]) < 0.9) &&
                 # (latlngDotProduct($points->[$i], $points->[$j], $points->[$j], $points->[$k]) < 0.9) &&
                ) {
          my $d1 = latlngDirection($points->[$h], $points->[$i]);
          my $d2 = latlngDirection($points->[$k], $points->[$j]);
          note("4-point U-turn detected @\n",
               "   1: point ", $h + 1, " of ", scalar(@$points), " ($points->[$h]->{lon}, $points->[$h]->{lat})\n",
               "   2: point ", $i + 1, " of ", scalar(@$points), " ($points->[$i]->{lon}, $points->[$i]->{lat})\n",
               "   3: point ", $j + 1, " of ", scalar(@$points), " ($points->[$j]->{lon}, $points->[$j]->{lat})\n",
               "   4: point ", $k + 1, " of ", scalar(@$points), " ($points->[$k]->{lon}, $points->[$k]->{lat})\n",
               "   directions = ", $d1 / $deg2rad, ", ", $d2 / $deg2rad, "\n");
          my $dir = averageAngles($d1, $d2);
          my $loop = makeLoop(points=> [$points->[$i], $points->[$j]], direction=> $dir, radius=> $rUTurn, defaultSign=> $loopSign, segmentNames=> \%segmentName);
          push @pNew, @$loop;
        }
        $i ++;
      }
      push @pNew, $points->[$i++] while ($i < $#$points);
      $points = \@pNew;
    }

    push @$points, \%{$points->[0]} if ($pointPopped);
  }


  #
  # set maximum curvature
  # note this needs to happen AFTER turn-around loops
  #
  if ( (defined $minRadius) && ($minRadius > 0) ) {
    note("setting minimum radius to $minRadius...\n");
    addCurvatureField(points=> $points, isLoop=> $isLoop);
    addDistanceField(points=> $points);
    my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);

    # calculate a lane shift field
    my $maxCurvature = 1 / $minRadius;
    my $count = 0;
    my @posShifts = map { 0 } @$points;
    my @negShifts = map { 0 } @$points;
    my $lambda = 16 * sqrt($minRadius);

    for my $u ( 0 .. $#$points ) {
      my $p = $points->[$u];
      if (
          (
           ( (! defined $minRadiusStart) || ($p->{distance} >= $minRadiusStart) ) +
           ( (! defined $minRadiusEnd) || ($p->{distance} <= $minRadiusEnd) ) +
           ((defined $minRadiusEnd) && (defined $minRadiusStart) && ($minRadiusEnd < $minRadiusStart))
           == 2
          ) &&
          ( abs($p->{curvature}) > $maxCurvature )
         ) {
        my $s = $minRadius - abs(1 / $p->{curvature});
        my $a = ( $p->{curvature} > 0 ) ? \@posShifts : \@negShifts;
        $a->[$u] = $s if ($a->[$u] < $s);
        $count ++;
      }
    }

    if ($count > 0) {
      note("found $count points tighter than minimum radius $minRadius meters...\n");
      for $a ( \@posShifts, \@negShifts ) {
        my $u1 = 0;
        my $u2 = 0;

        if ( $isLoop ) {
          $u1 --
            while (
                   ($u1 > -$#$points) &&
                   (distanceDifference($points->[$u1 - 1], $points->[0], $courseDistance, $isLoop) < $lambda)
                  );
        }

        my @newShifts = @$a;
        for my $u0 ( 0 .. $#$points ) {
          next if ($a->[$u0] == 0);

          # u1 ... u0 ... u2
          $u1 ++
            while (
                   ($u1 < $u0) &&
                   (distanceDifference($points->[$u1], $points->[$u0], $courseDistance, $isLoop) > $lambda)
                  );
          $u2 = $u0 if ($u2 < $u0);
          $u2 = ($u2 + 1) % @$points
            while (
                   ($isLoop ? ((($u2 + 1) % @$points) != $u1) : $u2 < $#$points) &&
                   (distanceDifference($points->[$u0], $points->[($u2 + 1) % @$points], $courseDistance, $isLoop) < $lambda)
                  );
          for my $u ( $u1 .. $u2 ) {
            # the u0 point has already been set...
            next
              if ($u == $u0);
            my $f = ( (1 + cos($pi * pointSeparation($points->[$u], $points->[$u0], $courseDistance, $isLoop) / $lambda)) / 2 ) ** 2;
            my $shift = $a->[$u0] * $f;

            # if there's an existing shift, then combine with that:
            # $newShifts[$u] = ($shift ** 4 + $newShifts[$u] ** 4) ** (1/4);
            $newShifts[$u] = $shift if ($shift > $newShifts[$u]);
          }
        }
        @$a = @newShifts;
      }

      # fill in shifts... sum of positive and negative shifts.
      for my $u ( 0 .. $#$points ) {
        $points->[$u]->{shift} += $posShifts[$u] - $negShifts[$u];
      }
      $points = applyLaneShift(points=> $points, isLoop=> $isLoop);
      # apply smoothing after shift: shifting can cause some noise
      $points =
        smoothing(
                  sigmaField=>  "shift",
                  sigmaFactor=> 0.2,
                  isLoop=>      $isLoop,
                  points=>      $points,
                  fields=>      ["lat", "lon", "ele"],
                 );

      deleteField2(points=> $points, field=> "shift");
    }
  }

  #
  # shift starting line
  #
  if ( $isLoop && ($shiftSF != 0) && (@$points > 1) ) {
    my $direction = ($shiftSF <=> 0);

    # trim off the last point if it equals the first point
    pop @$points
      if ( pointsAreClose($points->[-1], $points->[0]) );

    my $s = 0;
    while (1) {
      my $sPrev = $s;
      $s += latlngDistance($points->[0], $points->[$direction]);
      if ( $direction > 0 ) {
        push @$points, shift @$points;
      }
      if ( $s > abs($shiftSF) ) {
        my $f = (abs($shiftSF) - $sPrev) / ($s - $sPrev);
        # add in this point to the start... may need to remove the existing start point if it's too close
        # direction = 1 : interpolation between point -1 => point 0
        # direction = -1 : interpolation between point 1 => point 0

        my $pNew = interpolatePoint($points->[-1], $points->[0], ($direction > 0) ? $f : (1 - $f));
        shift @$points
          if (pointsAreClose($points->[0], $pNew));
        pop @$points
          if (pointsAreClose($points->[-1], $pNew));
        unshift @$points, $pNew;
        last;
      }
      if ( $direction < 0 ) {
        unshift @$points, pop @$points;
      }
    }
  }

  #
  # add points to beginning or end
  # this provides space for the S or F in a point-to-point
  # RGT can automatically close courses with undesired results if
  # points are too close
  #
  if ( (! $isLoop) && ($prepend > 0) && (($rTurnaround <= 0) || ($rLap <= 0)) ) {
    my $p1 = $points->[0];
    my $i = 1;
    my $d;
    $i ++
      while ((($d = latlngDistance($p1, $points->[$i])) < 10) && ($i < $#{$points}));
    my $p2 = $points->[$i];

    # figure out if we want to curve the road to split this from the return road
    if ( ($prepend == $append) && ($rTurnaround > 0) ) {
      my $p3 = interpolatePoint($p1, $p2, -0.5 * $prepend / $d);
      $p3->{ele} = $p1->{ele};
      $p3->{segment} = (defined $segmentName{$p1->{segment}}) ? 0 : $p1->{segment};

      # turn appropriate direction
      my $sign = ($laneShift < 0) ? -1 : 1;
      note("adding turn to prepend: ", (($sign > 0) ? "right" : "left"), "\n");

      my ($dx, $dy) = latlng2dxdy($p1, $p3);
      my $c = cos($deg2rad * $p3->{lat});

      # right turn: x -> y, y -> -x
      # left turn: x -> -y, y-> x

      my $dx2 = -$sign * $dy;
      my $dy2 = $sign * $dx;

      # switch back to lon, lat
      my $p4;
      %$p4 = %$p3;
      $p4->{lon} = $p3->{lon} + $dx2 / ($c * $lat2y);
      $p4->{lat} = $p3->{lat} + $dy2 / $lat2y;
      $p4->{segment} = $p3->{segment};

      unshift @{$points}, $p4, $p3;
    } else {
      my $p3 = interpolatePoint($p1, $p2, -$prepend / $d);
      $p3->{ele} = $p1->{ele};
      unshift @{$points}, $p3;
    }
  }
  if ( (! $isLoop) && ($append > 0) && (($rTurnaround <= 0) || ($rLap <= 0)) ) {
    my $p1 = $points->[-1];
    my $i = $#$points - 1;;
    my $d;
    $i --
      while ((($d = latlngDistance($p1, $points->[$i])) < 10) && ($i > 0));
    my $p2 = $points->[$i];

    # figure out if we want to curve the road to split this from the return road
    if ( ($prepend == $append) && ($rTurnaround > 0) ) {
      my $p3 = interpolatePoint($p1, $p2, -0.5 * $prepend / $d);
      $p3->{ele} = $p1->{ele};
      $p3->{segment} = (defined $segmentName{$p1->{segment}}) ? 0 : $p1->{segment};

      # turn appropriate direction
      my $sign = ($laneShift < 0) ? -1 : 1;
      note("adding turn to append: ", (($sign > 0) ? "right" : "left"), "\n");

      my ($dx, $dy) = latlng2dxdy($p1, $p3);
      my $c = cos($deg2rad * $p3->{lat});

      # left turn: x -> y, y -> -x
      # right turn: x -> -y, y-> x

      my $dx2 = $sign * $dy;
      my $dy2 = -$sign * $dx;

      # switch back to lon, lat
      my $p4;
      %$p4 = %$p3;
      $p4->{lon} = $p3->{lon} + $dx2 / ($c * $lat2y);
      $p4->{lat} = $p3->{lat} + $dy2 / $lat2y;
      $p4->{segment} = $p3->{segment};
      if ( $p3->{segment} != $points->[-1]->{segment} ) {
        my %p = %{$points->[-1]};
        $p{segment} = $p3->{segment};
        push @$points, \%p;
      }
      push @$points, $p3, $p4;
    } else {
      my $p3 = interpolatePoint($p1, $p2, -$append / $d);
      $p3->{ele} = $p1->{ele};
      $p3->{segment} = (defined $segmentName{$p1->{segment}}) ? 0 : $p1->{segment};
      if ( $p3->{segment} != $points->[-1]->{segment} ) {
        my %p = %{$points->[-1]};
        $p{segment} = $p3->{segment};
        push @$points, \%p;
      }
      push @$points, $p3;
    }
  }

  # copy the first point to the last point if specified
  if (
      $copyPoint &&
      (
       ($points->[0]->{lat} != $points->[-1]->{lat}) ||
       ($points->[0]->{lon} != $points->[-1]->{lon}) ||
       ($points->[0]->{ele} != $points->[-1]->{ele})
      )
     ) {
    my %p = %{$points->[0]};
    $p{segment} = $points->[-1]->{segment};
    $p{distance} = $points->[-1]->{distance} + latlngDistance($points->[-1], $points->[0]) if (defined $points->[-1]->{distance});
    note("copying point first point to end of the loop...\n");
    push @$points, \%p;
  }

  # split a route.
  # split a route at particular distance points, or into an equal number of pieces
  my $splits;
  if ( @splitDistance || ($autoSplits > 1) ) {
    my $courseDistance = calcCourseDistance( points=> $points, isLoop=> $isLoop );
    my $startZone = 0;     # allow for overlap (was important for RGT)
    my $finishZone = 0;    # allow for a overlap (was important for RGT)
    my $overlap = $startZone + $finishZone;
    my $dTot = $courseDistance - $overlap;
    if ($dTot > 0) {
      for my $i ( 1 .. $autoSplits - 1 ) {
        push @splitDistance, $startZone + $i * $dTot / $autoSplits;
      }
    } else {
      warn("course distance ($courseDistance) is smaller than overlap ($overlap): unable to generate segments\n");
    }
    if (@splitDistance) {
      $splits =
        splitPoints(
                    points=> $points,
                    isLoop=> $isLoop,
                    courseDistance=> $courseDistance,
                    splitDistance=> \@splitDistance,
                    startZone=> $startZone,
                    finishZone=> $finishZone,
                    splitNumber => $splitNumber,
                  );
    }

    # turn off looping: split broke up loop
    $isLoop = 0;
  } else {
    $splits = [ $points ];
  }

  #
  # the selected track is split within each file.  Any other tracks are kept as-is, copied to each file
  #
  for my $nSplit ( 0 .. $#$splits ) {
    my $points = $splits->[$nSplit];


    #
    # automatic segment definition using climb detection
    #
    my ($autoSegmentThreshold, $autoSegmentPower) = @autoSegments;
    if ((defined $autoSegmentThreshold) && ($autoSegmentThreshold > 0)) {
      # default segment power: a 100 meter climb @ 10% = a 140 meter climb @ 5%
      # so if I have 1 km @ 10%, then 1.8 km @ 2.2%, it's ambiguous whether to include
      # the second part in the segment
      $autoSegmentPower //= $autoSegmentDefaultPower // 0.5;

      # automatic segment generation
      $points =
        addAutoSegments(
                        gradientPower=> $autoSegmentPower,
                        isLoop=> $isLoop,
                        margin=> $autoSegmentMargin,
                        finishMargin=> $autoSegmentFinishMargin,
                        startMargin=> $autoSegmentStartMargin,
                        names=> \@autoSegmentNames,
                        points=> $points,
                        segmentDefined=> \%segmentDefined,
                        segmentNames => \%segmentName,
                        stretch=> $autoSegmentStretch,
                        threshold=> $autoSegmentThreshold,
                       );
    }


    #
    # create a distance field
    #
    addDistanceField(points=> $points);

    # add times from bike speed model, if requested
    if ((defined $startTime) && ($startTime ne "")) {
      note("adding time...\n");
      my $tStart = str2time($startTime);
      if ($tStart > 0) {
        note("start time found: $tStart\n");
        my @ts = (0);
        my @gs = (0);
        for my $i ( 0 .. $#$points - 1 ) {
          my $dd = $points->[$i + 1]->{distance} - $points->[$i]->{distance};
          push @gs, ($dd == 0) ? $gs[-1] : (($points->[$i + 1]->{ele} - $points->[$i]->{ele}) / $dd);
          push @ts, $ts[-1] + ($points->[$i + 1]->{distance} - $points->[$i]->{distance}) / bikeSpeedModel(g=> $gs[-1]);
        }
        for my $i ( 0 .. $#$points ) {
          $points->[$i]->{time} = $tStart + $ts[$i];
          $points->[$i]->{duration} = $ts[$i];
        }
      }
    }

    my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);
    note("final number of points = ", scalar(@$points), "\n");
    note("course distance = ", sprintf("%.4f", $courseDistance / 1000), " kilometers\n");
    my ($score, $scoreD, $scoreZ) = calcQualityScore(points=> $points, isLoop=> $isLoop);
    note("quality score of final course = ", sprintf("%.4f", $score), "\n");
    note("direction score of final course = ", sprintf("%.4f", $scoreD), "\n");
    note("altitude score of final course = ", sprintf("%.4f", $scoreZ), "\n");

    note("distance from last point to first point = ", sprintf("%.3f", latlngDistance($points->[-1], $points->[0])), " meters\n");


    #
    # curvature
    #
    if ($addCurvature) {
      note("checking curvature\n");
      addCurvatureField(points=> $points, isLoop=> $isLoop);
    } else {
      deleteField2(points=> $points, field=> "curvature");
    }

    #
    # generate gradient signs
    #
    if ( $addGradientSigns ) {
      # calculate course distance
      $waypoints //= [];
      push @$waypoints,
        @{placeGradientSigns(
                             points => $points,
                             shiftCircuit=> $isLoop,
                             courseDistance=> $courseDistance,
                             gradientPower=> $gradientPower,
                             threshold=> $gradientThreshold,
                             isLoop=> $isLoop
                            )
        };
    }


    #
    # finish up
    #
    if ($addGradient) {
      note("adding gradient field\n");
      addGradientField(points=> $points, isLoop=> $isLoop);
    } else {
      deleteField2(points=> $points, field=> "gradient")
    }

    deleteField2(points=> $points, field=> "distance")
      unless ( $addDistance );

    if ($addDirection) {
      addDirectionField(points=> $points, isLoop=> $isLoop);
      for my $p ( @$points ) {
        $p->{heading} /= $deg2rad;
      }
    } else {
      deleteField2(points=> $points, field=> "heading");
    }

    $gpx->waypoints($waypoints) if (defined $waypoints);

    # create segments for track
    # when a segment ID changes, that means to start a new segment

    # list of segments: segments must have at least one point
    my @segments = ();

    # reset the segment names field for this track
    $extensions->{segmentName}->{$nTrack} = {};

    my @segmentPoints;
    my $sPrev;
    for my $p ( @$points ) {
      my $s = $p->{segment} // 0;

      # new segment
      unless ((defined $sPrev) && ($s == $sPrev)) {
        if ( @segmentPoints ) {

          # copy the first point of the next segment on this segment
          # if there is a gap
          my $pPrev = $segmentPoints[-1];
          unless (pointsAreClose($p, $pPrev)) {
            my %p = %{$p};
            $p{segment} = $sPrev;
            push @segmentPoints, \%p;
          }

          # add the segment to the list of segments
          my %segment;
          $segment{points} = [ @segmentPoints ];
          push @segments, \%segment;

          # add segment name if defined
          my $nSegment = scalar @segments;
          my $segmentID = $segment{points}->[0]->{segment} // 0;
          $extensions->{segmentName}->{$nTrack}->{$nSegment} = $segmentName{$segmentID}
            if (defined $segmentName{$segmentID});

          # zero out the current segment
          @segmentPoints = ();
        }
        $sPrev = $s;
      }
      # add the current point to the current segment
      push @segmentPoints, $p;
    }

    # give preference to named segments
    if ( @segmentPoints && @segments && pointsAreClose($segments[-1]->{points}->[-1], $segmentPoints[0], 0.01) ) {
      # retain the point on the named segment
      my $s1 = $segments[-1]->{points}->[-1]->{segment};
      my $s2 = $segmentPoints[0]->{segment};
      if ( (defined $segmentName{$s1}) && (! defined $segmentName{$s2}) ) {
        shift @segmentPoints;
      } elsif ( (! defined $segmentName{$s1}) && (defined $segmentName{$s2}) ) {
        pop @{$segments[-1]->{points}};
      }
    }

    # simplify points, if requested
    if ( $simplifyPoints ) {
      my $pNew = simplifyPoints(points=> \@segmentPoints, z0=> $simplifyZ, r0=> $simplifyD);
      @segmentPoints = @$pNew;
    }

    # store the final segment
    # this just references the segment array rather than copying the data
    if ( @segmentPoints ) {
      my %segment;
      $segment{points} = \@segmentPoints;
      push @segments, \%segment;
    }

    # number of segments
    note("number of segments = ", scalar(@segments), "\n");
    my $n = 0;
    for my $s ( @segments ) {
      deleteField2(points=> $s->{points}, field=> "segment"); # delete the temporary segment field
      $n ++;
      note("segment $n : ", scalar(@{$s->{points}}), " points\n");
    }

    # replace original segments with smoothed segments
    $track->{segments} = \@segments;


    unless ( $noSave ) {
      my $nTrack = 0;
      if ($csv) {
        my $fNew = ($outFile eq "") ? setFileNameSuffix($file, "_processed.csv") : $outFile;
        $fNew = setFileNameSuffix($fNew, sprintf("_split%d.csv", $nSplit + 1)) // "-"
          if ( scalar(@$splits) > 1 );
        open my $fcsv, ">$fNew" or die( "ERROR opening file $fNew\n" );
        my @keys;
        my $nSegment = 0;
        for my $segment ( @{$track->{segments}} ) {
          $nSegment ++;
          my $points = $segment->{points};
          unless (@keys) {
            @keys = keys %{$points->[0]};
            print $fcsv join( ",", "track", "segment", @keys ), "\n";;
          }
          for my $p ( @$points ) {
            print $fcsv join( ",", $nTrack, $nSegment, @$p{@keys} ), "\n";
          }
        }
        close $fcsv;

      } else {
        my $k = "processGPX";
        my @newKeywords = split('\s*,\s*', $newKeywords);
        push @newKeywords, $k;
        my $keywords = $gpx->keywords();
        $keywords = [] unless (defined $keywords);
        for my $k ( @newKeywords ) {
          push @$keywords, $k
            unless ( grep { $_ eq $k} @$keywords );
        }
        $gpx->keywords( $keywords );

        $gpx->author($author)       if (defined $author);
        $gpx->name($title)          if (defined $title);
        $gpx->copyright($copyright) if (defined $copyright);
        $gpx->desc($description)    if (defined $description);
        $gpx->time(time());

        # create point extension fields
        for my $segment ( @{$track->{segments}} ) {
          addPointExtensions(points => $segment->{points});
        }

        my $fNew = ($outFile eq "") ? setFileNameSuffix($file, "_processed.gpx") : $outFile;
        $fNew = setFileNameSuffix($fNew, sprintf("_split%d.gpx", $nSplit + 1)) // "-"
          if (scalar(@$splits) > 1);
        note("saving processed data in file $fNew...\n");
        open my $fout, ">$fNew";

        my $xml = $gpx->xml("version" => "1.1", "extensions" => 1);

        # add extensions to the XML for the first track
        my $xml2 = addExtensions(\$xml, $extensions);

        print $fout $$xml2;
        print $fout "\n";
        close $fout unless ($fout eq "-");
      }
    }
  }
  note("done with file $file.\n");
}

__END__
=pod

=head1 NAME

processGPX

=head1 SYNOPSIS

B<C<processGPX>> [options] <input files>

=head1 VERSION

0.53

=head1 DESCRIPTION

processGPX is a series of algorithms to improve and create GPX files,
in particular for cycling emulation platforms like Biketerra.  It was
originally written for RGT.

At the time of this writing, BikeTerra allows for the creation of custom
routes whereby a GPX file can be submitted for conversion into
a virtual environment.  The GPX file can be initially generate by
on-line mapping tools, among which one excellent option is Strava
Route Editor, which exports GPX.  However, these tools tend to produce
GPX files with too low resolution in position, and small errors in
altitude, so that corners are not sufficiently round, and the gradient
between points can have anomalously large magnitude.

Additionally, BikeTerra requires the route to be specified
continuously from start to finish, rather than allowing arbitrary
navigation over a network of roads, and so sometimes the same section
of road needs to be repeated, either in the same or in the opposite
direction.  If you repeat sections of roadway, make sure there is no
overlap or road crossings, as as of this writing BikeTerra does not
produce good results with these.  Note point-to-point courses in
BikeTerra automatically feature turn-around loops at each end, so
there is no need to do anything to allow returning on a point-to-point
route.

These are just some examples of the sort of processing which can be
done to improve the quality and functionality of BikeTerra
and presumibly other cycling emulators as well.  There exist online
tools such as GPX Magic, which is excellent, but requires extensive
user interaction, and a command-line tool able to process an entire
file at once has benefit.  A nice approach is to general route editing
with GPXMagic, then use C<processGPX> to process the result.

The file takes GPX files on the command line, and generates a file
with a suffix "C<_processed>" for each, unless the C<-out> option is used,
in which case that is used as the output (this works for only one
input file).  So for example, if I type:

C<processGPX myFavoriteRoute.gpx>

the result will be a file:

F<myFavoriteRoute_processed.gpx>

This file will be essentially equivalent to the input file, in the
absence of any comment line options, although if there are any
"zig-zags" identified, those will be removed.  The file will also be
checked for "loops", where the direction spins around within 100 meters,
which might be from a poorly placed control point with mapping software.

If an alternate filename were desired for the output, that could be
specified with the C<-out> option:

C<processGPX myFavoriteRoute.gpx -out myFavoriteRouteCopy.gpx>

where the order of command line options does not matter, except that
the same option listed more than once will result in parameters specified
last being used.

Typically GPX file contain a single "track", each of which contains
multiple "segments", each of which contains multiple connected
"points". Segments are connected as well as points within
the segments.  However, GPX file may also contain multiple tracks.
processGPX is set up to process one track at a time within a GPX file.
By default, this is the first track, or track #1 counting 1, 2, 3 ...
If you want to specify a track other than 1, then use either the
C<-track> option (followed by a number 1, 2, 3...), or put the number
after a ":" at the end of a filename.  So for example, if I wanted
track #2 in a file file.gpx, I could specify either "C<-track 2>", or
"C<file.gpx:2>".  For the C<-join> option only the filename suffix works, so
"C<-join file.gpx:2>".

The program will calculate a quality of both the original GPX file,
and of the result of processing, which is based on how much the grade
changes point-to-point and also how much the direction changes
point-to-point.  The goal is to only have abrupt gradient changes
where they actually exist in the real-life course, and to smooth
corners so the direction does not abruptly change. This quality score
can provide guidance to if altitude smoothing and point density are
sufficient.

It also reports the length of the course, calculated treating the
earth as a sphere of a given radius.  The calculation in BikeTerra may
differ slightly, so distances may differ by a few meters.

There are a number of options, but a key one is C<-auto>.  It is
designed to generate a decent result in a large fraction of the cases.
If you only use this option, you should still be happy with results.
Other options, however, allow for fine-tuning of the amount of route
processing.  They can be used in conjunction with C<-auto> to
override those settings.

One important difference is how point-to-point routes and lappable
routes are treated.  You can specify a loop course as C<-lap>.  IF you
want the code to automatically determine whether a course is a
point-to-point or lappable, use C<-autoLap>.  This option is implied
with the C<-auto> option.

There are a number of options to create "out-and-back" routes.  These
were required by RGT.  However, BikeTerra automatically puts
turn-around loops at each end of a point-to-point course.  So you do
not need use these options with BikeTerra.  These options are thus
deprecated.

=head1 DEPENDENCIES

This code uses the following Perl modules, which must be installed,
for example with the "cpan" command-line tool:

 Getopt::Long : used for processing command-line options
 Geo::Gpx     : parsing and generating GPX files
 XML::Descent : processing XML (required by Geo::Gpx, as well)
 POSIX        : floor function
 Date::Parse  : for parsing time, with the -startTime option
 Pod::Usage   : for the -help option

=head1 OPTIONS

The program is generally invoked:

C<processGPX> [options] <inputfilename> ...

where multiple input file names may be specified, and zero or more
options may be specified.

Options are case-insensitive and come in three varieties:

=over

=item B<flags>: specifying the option by itself invokes the option.  For example,
  C<-splineFit> specifies that spline fitting is enabled.  Flag options
  can be negated with the same option but with "no" preceding, for example,
  C<-noSplineFit> disables spline fitting.

=item B<values>: the option specification is followed by a value.  This may
  simultaneously invoke an option.  For example, C<-spacing 10> sets the
  spacing for point interpolation to 10 meters, and additionally turns on
  point interpolation.

=item B<lists>: Some options allow for multiple values, for example C<-flatten>
  or C<-autoSegments>.  See details in the description of the specific option.

=back

The options are the following, excluding negations, which for flags are the option with C<no> preceding the keyword.

=over

=item B<C<-addCurvature>>

This option adds a "curvature" extension field (in inverse meters) to
the GPX file.  Curvature is calculated as the ratio of the rate of
change of angle with distance.  Note for a unit circle (radius = 1)
the rate of change of angle (in radians) with position (along the
perimeter) is 1.  In general this is the reciprical of the circle
radius.

=item B<C<-addDirection>>

This option adds an extensions "heading" field relative to east (in
degrees) to the GPX file.

examples:

=over

=item 0 degrees: east

=item 90 degrees: north

=item 180 degrees: west

=item 270 degrees south

=back

Note this is not "heading", as it is relative to east.

Direction is calculated for each point as the average of the
directions ahead and behind.  The direction of the first or last
points in a point-to-point course are calculated in only one
direction.  Directions for loop courses are calculated assuming the
loop.  The direction never changes by more than +/- 180 degrees from
one point to the next, so the direction has no limits: it can be
positive, negative, and outside the range from -360 to +360 degrees.
For example, if a route started east (0) then lapped around
counterclockwise 10 times, the final direction would be approximately
3600 degrees.

=item B<C<-addDistance>>

This option adds a "distance" extensions field (in meters) to the GPX
file.  Distance is calculated after all other operations, for example
cropping, extending, and shifting.  At present it's the horizontal
distance, so scaling a vertical cliff would count as zero.  Note
different programs may have different algorithms for determining
distance from coordinates: this program uses a very simple one.

=item B<C<-addGradient>>

This option adds a forward "gradient" extensions field, which is
calculated for each point as the ratio of the altitude change to the
horizontal distance to the next point.

=item B<C<-addGradientSigns>>

This flag is an I<experimental> option to calculate regions of
exceptional gradient and place "gradient signs" in the GPX as
waypoints.  There are no present plans for any program to support
this, so it is at present just a curiosity.

=item B<C<-addHeading>>

Alias for C<-addDirection>>.

=item B<C<-addSigma>>

This writes the autosmoothing "sigma" to the GPX file as an extensions
field, but only if C<-autosmoothingZ> is positive.  It is useful for
tuning the autosmoothing scale length.

=item B<C<-anchorSF>>

For point-to-point routes, this specifies that the start and finish
points should be anchored.  Smoothing would otherwise cause these
points to shift somewhat.

=item B<C<-append>> <meters>

A distance in meters which should be added to point-to-point
courses. In RGT, the finish line was typically placed 140 meters prior
to the end of a point-to-point course, so if for example you design a
course to be exactly 10 miles, (a typical UK time trial distance),
then to put the finish line at the end of those 10 miles, the option
"C<-append 140>" would add 140 meters.  This buffer was needed by RGT
because riders group along the road-side after crossing the finish.
Note the start line would also need to be extended, via C<-prepend>, by
60 meters, in the case of RGT.

Extended points will be set to the altitude of the final point.

Since BikeTerra tends to create loop courses when start and finish points are
close, the code may put a bend in the road it creates with this command,
if both C<-append> and C<-prepend> are specified (perhaps via C<-extend>).

Negative values crop the course by the negative distance.  So
"C<-append -100>" will move the finish line back 100 meters.  This was
useful for preventing RGT from connecting the finish and start points,
which has a 100 meter threshold, as this is written.

=item B<C<-arcFitDegs>> <degrees>

If arc fits are desired, specifying this will cause arc fit
interpolation to be done for corners turning at least this much, but
less than the C<-arcFitMaxDegs> option.  A typical value is 5 degrees.
This angle is the angle between interpolated course points

For a given 4 points I<a>, I<b>, I<c>, and I<d>, it interpolates between points I<b>
and I<c> by fitting a circle through points I<a>, I<b>, and I<c>, fitting a second
circle between points I<b>, I<c>, and I<d>, and then doing a weighted average
of these two fits based on the relative distance of the interpolated
point from points I<b> and I<c>.  If starting with points forming the
vertices of a polygon, for example, the resulting interpolation will
yield a circular course, which may or may not be what you want.


This algorithm tends to result in more sweeping corners than spline
interpolation, which may or may not reflect reality.  Also if there
are any anomalous points then there's the chance this algorithm will
exaggerate these anomalies.  It's recommended you very carefully check
the results of applying this option.  It's perhaps best for circuits
with sweeping corners rather than straights connected with tighter
turns.

See also C<-arcFitMaxDegs>.

=item B<C<-arcFitEnd>> <meters>

Where to end arc fitting, if any.  The default is to end any arc
fitting at the end of the course.

=item B<C<-arcFitMaxDegs>> <degrees>

If a C<-arcFitDegs> option is specified, specifying this limit the
maximum angle corner for which arc fit interpolation will be applied.
ArcFits are good for gradual, rounded corners but are not good for
sharp corners, so an upper bound in the 60 degree range (which is the
default) works generally well.  ArcFits have the advantage of rounding
corners without "blunting" them, but sometimes they create "S" shapes
where they are not wanted.  Make sure to check the results if using
arc fit interpolation: strange results can occur if the corner is too
sharp.

Arc fitting is a variation on spline fitting where corners are fit to
circles rather than splines.  If this option is set too large then there's
a risk of getting dramatically incorrect trajectories for sharp corners.
See also the notes in C<-arcFitDegs>.

=item B<C<-arcFitStart>> <meters>

Where to start arc fitting, if any.  The default is to start any arc
fitting at the start of the course.  This can be after C<-arcFitEnd>
and the region will wrap-around.

=item B<C<-author>> <string>

Provide the author of the GPX, as a string.  The default will
preserve the author of the source GPX.

=item B<C<-auto>>

This option automatically turns on options based on "best practices".
It will not turn anything off, so can be used in conjunction with other
options.

=item B<C<-autoLap>>

Synonym for C<-autoLoop>

=item B<C<-autoLoop>>

Automatically determine if the -loop option should be invoked based on
the relative position and orientation of the beginning and end of the
GPX track.

=item B<C<-autoSegments>> <threshold> <optional power>

Whether to automatically generate segments for the climb.  The threshold
is the vertical meters of a 10% gradient climb, where climbs at alternate
gradients are adjusted by a term (gradient / 10%)^power, where the default
power is 0.5.  The names can be set with "autoSegmentNames", with a generic
default.

This was designed for use in RGT and has no application in any present
program other than GPXMagic.

=item B<C<-autoSegmentFinishMargin>> <meters>

A minimum buffer between an auto-generated segment and the finish banner.
This defaults to 20 meters to allow room for riders to see a finish banner
after passing the segment banner.

This was designed for use in RGT and has no application in any present
program other than GPXMagic.

=item B<C<-autoSegmentMargin>> <meters>

A minimum buffer between auto-generated segments. The default is
400 meters, based on experiments with creating magic roads with different
gaps.

This was designed for use in RGT and has no application in any present
program other than GPXMagic.

=item B<C<-autoSegmentNames>> <list of names>

A list of names for automatically generated segments, separated by
commas or semicolons.  The default is "climb" followed by a number.
If there are more segments than names, the default will be used for
the additional climbs.

This was designed for use in RGT and has no application in any present
program other than GPXMagic.

=item B<C<-autoSegmentPower>> <number>

If the gradient power for autosegments is not provided in the
-autoSegments option as a second value, then use this value.  The
default is 0.5.  Decent numbers are from 0.25 to 3, depending on how
much focus you want to put on steepness in defining and rating climbs.

This was designed for use in RGT and has no application in any present
program other than GPXMagic.

=item B<C<-autoSegmentStartMargin>> <meters>

A minimum buffer between the start banner and the first segment.  This defaults
to 340 meters, based on experiments.  Note this results in a 400 meter distance
from the start of the GPX file.

This was designed for use in RGT and has no application in any present
program other than GPXMagic.

=item B<C<-autoSegmentStretch>> <relative amount>

The amount of distance increase one is willing to extend an
auto-segment to reach a true peak or valley.  This is applied to each
side, so a value of 0.05 will result in up to a 10% increase in the
total length of an automatically generated segment.  The increase will
not be applied if it would result in the loss of mandated margin (by
-autoSegmentMargin) to an adjacent segment, or too close to the start
(-autoSegmentStartMargin) or finish (-autoSegmentFinishMargin)

This was designed for use in RGT and has no application in any present
program other than GPXMagic.

=item B<C<-autoSmoothG>> <scale factor>

This invokes gradient autosmoothing selectively along the course,
using a similar syntax to C<-autoSmooth> and C<-autoSmoothZ>.  For
details on gradient smoothing, see the C<-smoothG> option.

=item B<C<-autoSmoothZ>> <scale factor>

This invokes an auto-smoothing algorithm whereby more altitude
smoothing is applied where gradient changes rapidly point-to-point,
less altitude smoothing where gradient changes slowly.  This is done
after the conventional position and altitude smoothing specified with
C<-smooth> and/or C<-smoothZ>.  So it allows the use of less of these
fixed smoothings, and apply an additional smoothing where it is most
needed.  An application of this would be a course where the altitude
is low quality on a subset of the total course, and one thus wants
more averaging averaging focused on that subset.

The scale factor controls how much smoothing is applied.  It is
roughly calibrated so "1" works well, but you can try reducing that to
0.5, for example, and see if the results are still satisfactory, or
increasing it to 2 if the gradient is still too spiky.

Consider using C<-smoothZ> instead unless you think there's a reason
the quality of the data is worse in some areas than in others: that
applies uniform smoothing over the whole course.  Or the two can be
combined.

=item B<C<-autoSpacing>>

Specify that points will be interpolated based on an algorithm.  The
key parameter is"smoothAngle", which determines where points are
placed.  This only makes sense if the a smoothing distance or a
minRadius is also provided, via the C<-smooth> or C<-minRadius> options.

This option is highly recommended (either explicitly or implicitly via
-auto or C<-outAndBack>): it greatly improves the smoothness of corners.

=item B<C<-autoSplits>> <number>

Number of files into which the original should be automatically splot.
So 1 here will do nothing.  2 would divide the original into two equal
length routes.

These splits are in addition to splits generated by the C<-splitAt>
option.  If you want to precisely place the split points, then the
-splitAt option is better.

If you specify an output file and do not specify a specific split
number with the C<-splitNumber> option, then the output files will
have a suffix of _split followed by a split number (1, 2, 3 ...).

=item B<C<-autoStraighten>> <max deviation> <min length>

This specifies the auto-straightening algorithm should be run.  It
looks for sections of road, at least the minimum length long, where
the road deviates laterally no more than the listed amount, each in
meters.  This is done before any other smoothing.

This may have mixed results. If a minimum deviation is too large,
you'll potentially lose details of the route. 2 meters is a decent
number. 4 meters is relatively aggressive.

This is in particular designed for routes generated from bike computer
data, where rider position will move back and forth across the road,
even for straight sections of road.  However, if the road doesn't have
long straight sections, then this will likely only decrease accuracy.

This option should likely be used in conjunction with some smoothing,
for example by additionally providing the C<-auto> option.

=item B<C<-autoStraightenDeviation>> <meters>

This is an alternative approach to specifying the maximum deviation
for auto-straightening.  See C<-autoStraighten> for details.  The
default is 0 (do not do auto-straightening).  Good options are 1 to 4
meters, from less aggressive to more aggressive.

=item B<C<-autoStraightenLength>> <meters>

The minimum length of a road section to be auto-straightened, in
meters.  This is an alternative to providing a second argument to an
C<-autoStraighten> option. It can be used in conjunction with
C<-autoStraightenDeviation> to request auto-straightening.

=item B<C<-circle>> <meters> ... (1 or more)

Provide segments to be fit with circles, alternating start distance
from start of GPX, and finish distance from start of GPX.  This is an
alternative to providing values via C<-circleStart> and/or
C<-circleEnd>.  IF both methods are used, these will be processed
first.  So for example, C<-circle> 400 500 100 200 will fit circles
for points between 400 and 500 meters from the start, then between 100
and 200 meters from the start.  Not the further points are listed
first so the fit of a circle to these points does not affect the
distance to the nearer points.  If an odd number of values are
specified, the end point of the final point will be the end of the
route.

=item B<C<-circleEnd>> <meters> (1 or more)

Set one or more distances for circle fitting.

See C<-circleStart>

=item B<C<-circleStart>> <meters> (1 or more)

Set one or more start distances for circle fitting.

This is an option which should be used with care.  For the special
case where a route includes circular sections, for example laps of the
San Francisco Polo Fields, you can move points to a circle which
passes thru the end-points of an interval, and a point approximately
mid-way between the end-points.  This should be followed up with a bit
of smoothing over the interval to clean up the transitions to and from
the circular arc.  Be careful in defining the endpoints so the
direction doesn't change suddenly.  For example, you don't want the
circular arc to overshoot, requiring the direction to correct in the
opposite direction.  Consider only fitting the circular arc to a
center portion of the curve.

The circular arc is fit between points starting at C<-circleStart> and
ending at C<-circleEnd> from the start.  If the C<-isLoop> option is
used, the start may come after the end in which case it wraps around.
The circular arc is generated after point interpolation but before
smoothing.

If you want to generate multiple circular arcs (for example, the Polo
fields have circular arcs at each end, separated by straight segments)
then specify the same number of values for C<-circleStart> and
C<-circleEnd>, for example two values each for an oval like the Polo
Fields.

If multiple values are listed, then multiple sections will be
replaced.  Distances will be updated after each circular segment
replacement.  So if you want to do multiple circular replacements,
list them from further to closer relative to the start to avoid the
distances for later fits being affected by earlier fits.

=item B<C<-circuitFromPoint>> <meters> <circuits> [<repeats>] [<meters> ..]

This is an alias for C<-circuitFromPosition>.

=item B<C<-circuitFromPosition>> <meters> <circuits> [<repeats>] [<meters> ..]

This option allows you to specify a circuit starting at a certain
distance from the start of the track.  The code will go to a point
that distance from the start. It will then search forward to where the
course returns to the specified point and define that as a circuit.

If the number of circuits is greater than 1, it will repeat thse
points to create multiple circuits.  If the number is zero, it will
delete the points.  If the number is one, then nothing will change.

An optional number of repeats may be specified if the circuit returns
to this point more than once, in which case it must return to the
original point the specified number of times.

=item B<C<-circuitToPoint>> <meters> <circuits> [<repeats>] [<meters> ..]

This is an alias for C<-circuitToPosition>.

=item B<C<-circuitToPosition>> <meters> <circuits> [<repeats>] [<meters> ..]

This is like circuitFromPosition, except the distance specified is
from the end of the course rather than the beginning, and the circuit
ends at the specified point rather than starts there.  So for example
specifying a distance of 0 would search for a circuit which ends at
the end of the track.

=item B<C<-closed>>

Alias for C<-copyPoint>

=item B<C<-copyPoint>>

For C<-loop> courses, copy the first point to the end of the list of
points, so the circuit is explicitly closed.

=item B<C<-copyright>> <string>

If you want to specify a copyright field in the GPX, list it here.
The default will preserve the copyright of the source GPX.

=item B<C<-cornerCrop>> <meters>

If there is a sharp corner, defined as an angle in the range between
C<-minCornerCropDegs>C< and -minCornerCropDegs>, then points are
placed before and after the corner and the corner point itself is
deleted, converting the sharp corner into a 2-part turn.  This results
in corner rounding after smoothing.  Corner cropping allows for a
reduction in smoothing and avoids C<-minAngle> causing corners to bow
outward.  This is only done if the straight segmenrs before and after
the corner have sufficient length for the interpolated points to be
placed.

=item B<C<-cornerCropEnd>> <meters>

Where to stop corner cropping

=item B<C<-cornerCropStart>> <meters>

Where to begin corner cropping

=item B<C<-cornerEffect>> <number>

This adjusts the corner effect on gradient smoothing, which maintains
the original gradient in corners.  The default is 1.  A nonpositive
number turns off the experimental algorithm.  A number between 0 and 1
makes is weaker.  A number greater than 1 makes it stronger.  In some
cases using a value of 2 may help pin down a corner leading into or
coming out of a steep climb, for example.  However, larger numbers may
lead to irregularities due to the rapid modification of smoothing.

This is not used in altitude or position smoothing.

=item B<C<-crop>> <meters>

This is a short-cut for the C<-cropMax> option.

=item B<C<-cropCorners>> <meters>

This is an alias for C<-cornerCrop>.

=item B<C<-cropMax>> <meters>

A point will be interpolated to this distance, if needed, and all
points following will be discarded.  Distances are calculated after
smoothing but before C<-append> or C<-prepend>.  It can be useful to
design a course beyond the desired length, smooth it, and then crop
it, since smoothing can have anomalous effects near the boundaries of
the data.  This is especially true for a route ending on a section of
road previously encountered in the route.

Since smoothing is affected by points ahead of and behind the given
point, it is good to extend the points a few smoothing lengths, then
crop it back to the desired endpoints.

=item B<C<-cropMin>> <meters>

Points prior to this will be stripped, and if needed, a point will be
interpolated to this position.  This shifts the start position of the
GPX route.  See C<-cropMax> for more discussion.

=item B<C<-cropStart>> <meters>

Alias for C<-cropMin>

=item B<C<-cropStop>> <meters>

Alias for C<-cropMax>

=item B<C<-crossingAngle>> <degees>

If set, then this is the minimum degrees by which segments need to
intercept to be treated as crossings.  If intercepting by less than
this absolute angle, they are treated as separate.  The default is
11.25.  This can be increased since the default on twisty out-and-back
sections might get marked as crossings otherwise.

=item B<C<-crossingHeight>> <meters>

If C<-fixCrossings> is invoked, then the code will attempt to identify
crossings and adjust the altitude at them.  Typically crossings will
be either level (same altitude each direction) or at some minimum
height.  That minumum height defaults to 2 meters, but can be adjusted
with this parameter.  If the GPX file has an altitude difference
between zero and this number, it will force whichever is closer, and
transition the altitude to either side, maintaining the same mean.

Altitude adjustment is handled by checking if the crossing elevations
are close.  If they are close, then they are averaged to make them
equal.  If they are not sufficiently close, they are stretched apart
if they are not close enough for a reasonable overpass.

=item B<C<-crossingTransition>> <meters>

If C<-fixCrossings> is invoked, then the altitude at crossings will be
flattened over a length rCrossings.  This flattening will be
transitioned back to the original altitude over a transition length
which defaults to 3 times rCrossing.  However, this may be too short,
resulting in excessive gradients.  This option allows explicitly
setting this transition length, specified in meters

=item B<C<-csv>>

Specifies the output will be CSV rather than GPX.  This is ignored if
an output file is specified with either a "csv" or "gpx" suffix (case
insensitive), in which case the suffix is used to determine the
format.  Other suffixes are ignored.

=item B<C<-deleteRange>> <meters> <meters> ...>

This allows the specification of position pairs marking ranges over
which points should be deleted.  If two points are provided, then the
route is deleted starting at the first position and ending at the
second position.  Additional pairs may be provided to provide
additional delete ranges.  This deleting, unlike the deleting
specified with C<-deleteMin> and/or C<-deleteMax>, is done before
point interpolation, but after file joining.  This is because it is
likely that smoothing will need to be done after the delete.
Additional clean-up with a GPX editor like GPXMagic may be useful.

This would be useful, for example, if a GPX file has an out-and-back
portion that you want to remove from the route.

If multiple segments are provided the distances are not adjusted
between deleting operations.  So for example, if C<-deleteMax 1000
2000 3000 4000> were specified, the section from 1000 meters to 2000
meters would be first deleted.  This would reduce the distance to the
point which was originally at 3000 meters.  However, the point at 3000
meters is determined using the distances calculating before any
deleting was done.  Delete segments should not overlap.  Distances
should be specified with extreme care, ideally to provide a small gap
between the end of what precedes the start of the delete, and what
follows the end of the delete, to allow a smooth transition.

If there is only a single position provided, or if there are an odd
number of positions, then the only or odd position will be considered
a minimum position for deleting.  So, for example, C<-deleteRange
10000> would delete the route starting at 10 km, where positions are
determined on the unprocessed GPX data.

If the second point of a range is less than the starting point of the
range, then the range wraps around, so points at the end of the route
(after the start point) and at the beginning of the route (before the
finish point) may be deleted.

Deleting ranges doesn't create gaps in the route, of course.  It
deletes the control points within a given distance range.  So the
points at either end of the range will be connected.  So for example,
suppose I have a straight-line course with points at 0 meters, 500
meters, and 1000 meters.  I then delete in the range 250 meters to 750
meters.  I will now have points at 0, 250 meters, 750 meters, and
1000 meters.  The points at 250 meters and 750 meters have been
interpolated to define the deletion range, and the point at 500 meters
has been deleted.

=item B<C<-description>> <string>

List a description for the GPX metadata.  Since the description will
likely contain spaces, remember to enclose the string in "quotes",
or however else your command-line shell delimits spaces.

=item B<C<-extend>> <meters>

This is a simultaneous specificiation of both C<-prepend> and C<-append>.

=item B<C<-extendBack>> <meters>

This option creates a turn-around loop at the end of a point-to-point
route and then truncates it so the extension in length is the specified
number of meters.  So, for example, C<-extendBack 200> will result in a route
200 meters longer, where the additional length is provided by a turn-around loop,
then added distance as needed backtracking along the main route.

This option was added for RGT, which used the final 140 meters of a point-to-point
route as a zone for riders to group after the finish.

This disables C<-loop> or C<-lap>: it's meaningless with a lap course

=item B<C<-finishCircuitDistance>> <meters>

Often races end with finishing circuits after a lead-in.  To accomodate
this, you can start with a GPX route which includes at least one lap
of the finishing circuit, and add finishing loops.  This option
allows specifying the start position where a lap of the finish circuit
begins.  The circuit is assumed to extend to the end of the GPX file.
The code will add a number of copies of these points specified by the
B<C<-finishCircuits>> option.

So if the course goes from A to B, then completes 3 circuits of the
loop B-C-D, then find the distance in meters to point B, then specify
that distance as C<-finishCircuitDistance>, and specify C<-finishCircuits> 2.
This will add two copies of the loop B-C-D to the end of the data.

If the desired finish of the GPX is not at the same point as the end
of the loop, then you'll need to specify a C<-cropMax> value to remove
some of the final circuit.

An alternative to this option is the newer C<-circuitToPosition> which
if specified with a position of 0 will generate finishing circuits
without having to identify the position where the circuits begin.  So
for example C<-circuitToPosition 0 3> would generate three finishing
circuits automatically.

=item B<C<-finishCircuits>> <count>

A finishing circuit starting at the position specified by the
B<C<-finishCircuitDistance>> option, in meters, will be appended
to the initial data this number of times.  A value of 1 here
implies adding one copy, which will result in two laps of the
circuit.

=item B<C<-finishCircuitStart>> <meters>

Synonym for C<-finishCircuitDistance>.

=item B<C<-fixCrossings>>

If a route contains crossings, for example a true figure 8, then it
will flatten the road on either side of the crossing, and create a
transition from the flattened profile back to the unaltered profile.
The side of the flattening is determined by the C<-rCrossing> option.
An issue with RGT is that if a sloped road crosses a flat road, for
example, on the upward side the sloped road will appear to rise above
the surface, while in reality the pavement would be leveled out to
allow for the crossing.  This creates that leveling.

=item B<C<-flatten>> <start-meters> <altitude-meters> <end-meters> <altitude-meters> <transition-meters> ...

This important option allows the route to be flattened over a
specified coordinate range, with a specified transition length.  This
has been used where there are overpasses in a route, where it is
important that the altitude difference between the upper and lower
roadway be maintained, even with altitude smoothing.

You sepecify a starting distance, then the altitude at that point,
then a finish distance, then (optionally) an altitude at the second
point (default is the same altitude as the first point), then
optionally a transition length (default is to calculate a reasonable
one).

The transition length is used to describe a distance over which a
cosine weighting term is used to transition between the fixed
altitude, and the prior altitude for those points.  This should be
made long enough to avoid excessive deviations in gradient, yet small
enough to limit the extent of the influence of the command.

Multiple sets of five numbers can be provided, in which case altitude
flattening is done over each of the specified segments.

Distances are calculated I<after> smoothing but before cropping or extension.

=item B<C<-gAutoSmooth>>

Synonym for C<-autoSmoothG>

=item B<C<-gSmooth>>

Synonym for C<-smoothG>

=item B<C<-gSigma>>

Synonym for C<-smoothG>

=item B<C<-gradientPower>>

For gradient signs, how much of a power to apply to gradient in
determining where signs go.  If 0, then all that matters is altitude:
put the signs between peaks and valleys.  If 1, then a climb which is
double the altitude but half the gradient scores the same.  The higher
this number, the more likely a gradient sign is to go on a short steep
pitch versus a longer, more gradual climb containing the short steep
pitch.

=item B<C<-gradientThreshold>>

This determines the threshold at which a gradient sign gets put in.
The units are meters: a 10% climb needs to gain this much altitude
to get a gradient sign.  How much altitude steeper or less
steep climbs need to be depends on gradientPower

=item B<C<-interpolate>> <meters>

Synonym for C<-spacing>

=item B<C<-join>> <filenames>

Add the points from the first track found in these files and append
them to the selected track in the original file.  The files must
reasonably match up end-to-end.  To specify alternate tracks than the
first, append the selected track after a colon (":").  For example,
C<-join file.gpx:2> would select the second track in file C<file.gpx>.

=item B<C<-keywords>> <meters>

Add keywords to the GPX output.  Multiple keywords can be separated
with commas.  If there are any spaces, make sure to enclose the string
in quotes, or however your command-line shell specified strings should
be delimited.

So for example, the following are allowed:

=over

=item C<-keywords test>

=item C<-keywords test1,test2,test3>

=item C<-keywords "test1, test2, test3">

=back

A "processGPX" keyword is automatically added.

=item B<C<-laneShift>> <meters>

This shifts the points of a road to the right (for a positive value)
or the left (for a negative value) This is used for out-and-back
sections, to provide separation between the outward and return legs of
the road, which are otherwise described with the same coordinates.  In
RGT Cycling, a 4 meter shift will cause the resulting inward and
outward roads to abut, assuring that even if cyclists use the full
road width, they will not visually collide.  A larger value may result
in a grass island between the two directions.  A smaller value may result
in the roadways overlapping.

Back in the day a 4 meter laneshift was sufficient.  But then RGT
added road-side assets to magic roads, so a 4-lane shift with abutting
roads will result in riding through tents, fences, etc, associated
with the opposite direction.  A 6 meter lane-shift is the minimum
recommended, or even more to avoid issues with the large tents.
Hopefully RGT will fix this problem.

=item B<C<-laneShiftEnd>> <meters>

This is an alias for C<-shiftEnd>.

=item B<C<-laneShiftStart>> <meters>

This is an alias for C<-shiftStart>.

=item B<C<-laneShiftTransition>> <meters>

This is an alias for C<-shiftTransition>.

=item B<C<-lap>>

Synonym for C<-loop>

=item B<C<-loop>>

The course is considered a loop course, or a circuit, and so smoothing and other operations
can take place between the beginning and end of the loop.

=item B<C<-loopLeft>>

Specify that turnaround loops should loop to the left (UK, for example).
The default is to base it on the C<-laneShift> (left for a negative
lane shift, else positive).

=item B<C<-loopRight>>

Specify that turnaround loops should loop to the right (US, for example).
The default is to base it on the C<-laneShift> (left for a negative
lane shift, else positive).

=item B<C<-maxCornerCropDegs>> <degrees>

The maximum angle at which corner cropping should be done, for example
120 degrees.

=item B<C<-maxSlope>> <%>

RGT supported a "maximum slope" option for magic roads.  This
option allows that to be changed from a default.  It is specified
in percent.  If you specify a number < 1, then that will be assumed
to not have been converted into percent, so the number will be
multiplied by 100.  With the closure of RGT it is unlikely this
has any remaining utility.

=item B<C<-minCornerCropDegs>> <degrees>

The minimum angle at which corner cropping should be done, for example
60 degrees.

=item B<C<-minRadius>> <meters>

The code will calculate an effective radius of turns, and if this is
less than this value, it will shift the road to increase the radius.
This is done prior to C<-laneShift>, which may thus result in tighter
turns. So if there is a tight switchback, for example, then applying
this option will tend to shift the road outward, increasing the turn
radius.  There is a transition for this lane shift, so for tight
S-turns, alternating left and right, or in very tight switchbacks,
where the road snakes up a hill, results may be unsatisfactory.  It
works best with an isolated corner.

=item B<C<-minRadiusEnd>> <meters>

If specified, where to stop applying minimum radius (-minRadius).
If both C<-minRadiusStart> and C<-minRadiusEnd> are specified, and if
the end is before the beginning, then the region between the points
is excluded, and it is applied to the region after the start and
the region before the end.  To apply multiple radii in different
regions of the course, this can be used for one region, but then the
code should be re-run on the resulting GPX file to apply a subsequent
region.

=item B<C<-minRadiusStart>> <meters>

If specified, where to start applying minimum radius (-minRadius).
If both C<-minRadiusStart> and C<-minRadiusEnd> are specified, and if
the end is before the beginning, then the region between the points
is excluded, and it is applied to the region after the start and
the region before the end.  To apply multiple radii in different
regions of the course, this can be used for one region, but then the
code should be re-run on the resulting GPX file to apply a subsequent
region.

=item B<C<-name>> <string>

Specify the name of the GPX route. The default is the name listed
in the source GPX.  This is synonymous with C<-title>.

=item B<C<-noSave>>

The C<-nosave> option suppressed generation of a GPX output file.  This
may be useful for debugging or for checking the distance of a file,
which is reported to standard error, and checking it for zig-zags
and loops..  This option has a double-negation which is C<-nonoSave>.

=item B<C<-o>> <filename>

Alias for C<-out> <filename>

=item B<C<-out>> <filename>

Instead of the default filename, which is the input file with
F<_processed.gpx>, use this filename instead.  Make sure to specify
the F<.gpx> suffix if that is what is wanted. A "C<->" implies standard
output.

=item B<C<-outAndBack>>

This is a short-cut for creating an out-and-back, with a loop at the
end of the magic road, then a return.  It defaults to shifting the
road to the right.  If you want the left (UK, for example) then
specify the C<-laneShift> option as well.  It should obviously not be
combined with C<-lap> unless you add C<-rLap>.

If you want a different lane shift, or a different loop radius, you
can specify these with C<-laneShift> and/or C<-rTurnaround>.  You probably
alao want to add some smoothing, so C<-auto> is a good option.

If you use this option, then the starting route should be just the
"out" section, not the "back".  The code will generate the turn-around
loop and the return road, which will be shifted by default for a 12
meter separation, which given the 8 meter road width, results in a
4-meter median between the out and back.

With the lane shift, you should make sure there's no sharp corners in
the out section, or these could become excessively sharp after the
lane shift.  As a result, this option specifies defaults for point
interpolation, spline fitting, point smoothing, and minimum radius.
These options can be over-ridden by explictly specifying the
appropriate options.

This option is generally not needed with BikeTerra which automatically
forms turn-around loops at each end of a point-to-point course.

=item B<C<-outAndBackLap>>

This is the same as C<-outAndBack>, except also adds a turn-around to
create a lappable course.  If you want the turnaround and lap loops to be
different than the default radius, then you can specify these separately with
-rTurnaround and/or C<-rLap>.

This option should not be used with BikeTerra which automatically
forms turn-around loops at each end of a point-to-point course.

=item B<C<-outAndBackLoop>>

An alias for C<-outAndBackLap>

=item B<C<-prepend>> <meters>

See the C<-append> option for details, except instead of adding roadway
to the end of a point-to-point course, this adds it to the beginning
of the course.  RGT in general puts the start line 60 meters after
the start of a GPX file, so this can provide for that distance,
although a better solution is to design in the 60 meter buffer from
the start, so it conforms to the actual roadway.

A negative number will crop the course at the beginning, so is
an alternative to C<-cropMin>.

=item B<C<-prune>>

This option says that colinear points (in all three dimensions) should
be removed, reducing the size of the output file.  There's no downside
to this, unless the file is being prepared for subsequent modification
with another tool, such as GPX Magic.

=item B<C<-pruneD>> <meters>

Given three points in sequence, A, B, and C, if the separation between
B and the segment connecting A and C is at least this distance, the
point B is not pruned.  The C<-prune> option must still be invoked to
get pruning.  There is a default value.

=item B<C<-prunedg>> <value>

Given three points in sequence, A, B, and C, if the difference in
gradient from A to B, and B to C, exceeds this value (not specified as
a percent, but as a raw value).  The default is 0.0005.

=item B<C<-pruneDistance>> <meters>

An alias for C<-pruneD>.

=item B<C<-pruneGradient>> <value>

An alias for C<-prunedg>

=item B<C<-pruneSine>> <value>

An alias for C<-pruneX>

=item B<C<-pruneX>> <value>

Given three points in sequence, A, B, and C, if the sine of the angle
A-B-C exceeds this value, the point B will not be removed.  There is a
default value.

=item B<C<-quiet>>

If specified, suppress all noncritical messages (to the standard error
stream).  Only warnings and error messages will go to the standard
error stream.  This will suppress things like the number of points,
the altitude smoothness score, and the course distance.

=item B<C<-rCrossings>> <meters>

If C<-fixCrossings> is invoked, then how far to each side of the
crossing the road should be leveled.  A transition of three times this
length will be used, over which the altitude will be restored to the
unaltered value.  The default is 6 meters, which works fairly well
with the RGT road width of 8 meters, althouugh if the intersection is
at a particularly acute value, or if the roads will be wider than the
RGT standard of 8 meters, a larger value may be better.  If the value
is too large, the transitions too and from the flat section may be too
steep, or the influence of crossings could overlap, which the
algorithm does not handle well.

=item B<C<-repeat>> <count>

Number of copies of the route to append to the end of the course.
This should naturally be applied to a route which is a lappable
course.  Normally lappable courses in RGT are modeled with only a
single lap, but there are several reasons one might want to
artificially create multiple laps by repeating the lap.  One might be
if one is going to add a lead-in or finishing leg to the course, for
example with the C<-join> option, which would be applied after this
command is executed.  Another might be if you wanted timed segments only
on selective laps, or overlapping the boundary between laps. But in most
cases multi-lap races are better modeled by specifying the number of laps
at event creation and using a magic road which covers only one of the
laps.

=item B<C<-reverse>>

This reverses a course immediately after loading the file.  So all
subsequent operations will be done on the reversed course rather than
the original course.  So for example, if I have an initial course
which goes from point A to point B, and I specify a turnaround with
-rTurnaround 5, instead of a route from A to B and back, it will
instead be from B to A and back.  If you want to reverse the final
product, then do a second run with just the C<-reverse> option after an
initial run on other options.

=item B<C<-rLap>> <meters>

For an out-and-back course, create a second loop at the finish,
reconnecting to the start, to create a circuit.  This allows the
out-and-back to be repeated an arbitrary number of laps.  This only
works if C<-rTurnaround> is also positive. See also C<-rUTurn>.

If you want to go from a single point-to-point course to get
an out-and-back loop course, consider the C<-outAndBackLap> option,
which specifes a range of options including this one.

=item B<C<-rTurnaround>> <meters>

Create an out-and-back course, with a turn of this radius generated at
the turn-around point.  This may be done in conjunction with
C<-laneShift> to have the return road shifted from the outward road.
If the distance is less than the laneShift value, then the loop will
have 3 parts: for example a right, then a left, then another right to
turn 180 degrees.

The default behavior is for the loop to be to the left if laneShift is
negative (UK, for example), otherwise positive (US, for example).  The
direction can alternately be specified with C<-loopLeft> or
C<-loopRight>.

The C<-outAndBack> option is an alternative, specifying other
smoothing options in addition to a lane shift and this option to
create an out-and-back course more simply.

This option should not be used with BikeTerra which automatically
forms turn-around loops at each end of a point-to-point course.

=item B<C<-rUTurn>> <meters>

If any 180-degree turns are identified in the course, loops
are added with this radius.

This is done late in the process, in particular after lane
shifting, so the U-turns can properly connect the land-shifted
roads (with the C<-laneShift> option).  It is done before
minRadius, however.

=item B<C<-saveCrossingsCSV>>

If crossing processing is done with C<-fixCrossings>, then this
option specifies a CSV file should be saved with a similar filename
with coordinates of detected crossings.  It's useful for debugging,
since the crossing detection algorithm is imperfect.

=item B<C<-saveSimplifiedCourse>>

This is an option for debugging.  C<-fix>_crossings, for example,
generates a simplified course, and if find in a complex course that
certain crossings aren't identified, then this may be useful
for debugging why.

=item B<C<-segment>> <start>,<end>,<name>; ...

Define one or more non-overlapping named segments for the route.
These are defined immediately before the C<-shiftSF> option is
applied.

Segments are specified with groups of 3 options separated by comma: a
first coordinate specifying the starting distance in meters or
"C<start>", a second ccoordinate specifying the ending distance in
meters or "C<end>", and a name.  The starting coordinate instead be
"C<start>" to begin at the course start, and the ending coordinate can
instead be "C<end>" to end at the course end.  It is not recommended
to use "C<start>" or "C<end>" with a loop course, since for loops, the
course will not start or finish at the GPX end.

RGT requires that segments start a sufficient distance from the
beginning of the route, and end a sufficient distance from the end of
the route, and also be separated by a sufficient distance.  However,
this code only checks that they not overlap.  There is no way to
define segments which overlap the S/F of a lapped course.

Segments already defined in the GPX file, for example from GPX Magic
or previous runs of this code, are honored, and so new segments may
not overlap previously defined segments.  Points are interpolated to
get an essentially exact match to the specified coordinates.  Consider
the C<-stripSegments> option to merge segments from the input file if
the input file has multiple segments and you wish to replace them.

If you want multiple named segments, then split them with semicolons
(";"), so for example C<-segments "1000,2000,segment
1;3000,4000,segment 2">

In many cases, the C<-autoSegments> option is a better option, since
this will automatically find segments by searching for climbs within a
track.

=item B<C<-selectiveGSmooth>> <meters> ...

This is an alias for C<-selectiveSmoothG>, which provides for
selective gradient smoothing.

=item B<C<-selectiveLaneShift>> <meters> ...

This allows for a lane shift which is varied throughout the course.
The first number is the lane shift for the first part of the course.
The next number is a position where the lane shift changes to the next
smoothing number.  A third number is the lane shift beyond the second
number.  This can continue.  You alternate lane shift numbers and
positions marking the transition between these shifted numbers.  So
there should be an odd number of numbers following.  If there's an
even number, a last number of zero is assumed (no shift after the
listed distance).

For example, suppose I want to use 7 meter shift up to 2 km, then
change to 2 meter shift from 2 km to 3 km, then back to 7 meters
past 3 km.

C<-selectiveLaneShift 7 2000 2 3000 7>

the lane shift will be smoothly varied between values at the boundaries
 using a cosine transition.

If this is a lapped course, and there are multiple lane shift values,
then there will be an implicit transition at the S/F of the lap unless
the last number matches the first.

If you specify lane shift as well as selective lane shift, then both
are applied simultaneously (distances refer to positions before lane
shifting is applied).

=item B<C<-selectiveSmooth>> <meters> ...

This allows for smoothing to be varied throughout the course.  The
first number is the smoothing distance for the first part of the
course.  The next number is a position where the smoothing changes to
the next smoothing number.  A third number is the smoothing beyond the
second number.  This can continue.  You alternate smoothing numbers
and positions marking the transition between these smoothing numbers.
So there should be an odd number of numbers following.  If there's an
even number, a last number of zero is assumed (no smoothing after the
listed distance).

For example, suppose I want to use 7 meter smoothing up to 2 km, then
change to 20 meter smoothing from 2 km to 3 km, then back to 7 meters
past 3 km.

C<-selectiveSmooth 7 2000 20 3000 7>

=item B<C<-selectiveSmoothG>> <meters> ...

This is similar to C<-selectiveSmooth> except it is applied only
to gradient smoothing.

=item B<C<-selectiveSmoothZ>> <meters> ...

This is similar to C<-selectiveSmooth> except it is applied to
altitude only.  This is particularly useful with Strava Route
Editor output, where the quality of the altiude data often varies.

For example, suppose I want to use 15 meter smoothing everywhere
except between km 4 and km 5, where I will use 50 meter smoothing,
knowiing perhaps from bike computer data that the gradient in that
interval is much more uniform than is reflected in the Strava Route
Editor data:

C<-selectiveSmoothZ 15 4000 50 5000 15>

=item B<C<-selectiveZSmooth>> <meters> ...

an alias for -selectiveSmoothZ

=item B<C<-shiftEnd>> <meters>

The position at which lane shifting should end. This is useful in case
you have an isolated out-and-back section and want to be able to shift
lanes over only a portion of a course, or for example for an
out-and-back where there will be little risk of head-on collisions
sufficiently far from the turn-around.  A transition zone between
shifting and non-shifting is created.  The distance is calculated
prior to lane shifting, not self-consistently (lane shifting will
subtly change distances), so to determine precise distance, run once
without lane shifting, get the distance, then do lane shifting with
that precise distance.

A reason for limiting lane shifting is that lane shifting creates a
deviation in the route from the real-world coordinates, unless the
road is sufficiently wide, and also because it can cause a decrease in
radius of tight turns to too small value.  Lane shifting should thus
be combined with a sufficient degree of position smoothing to avoid
tight corners, or else restrict the lane shifting from a portion of
the course with tight corners.

If shiftStart < shiftEnd, then the shift occurs between shiftStart and
shiftEnd.

if shiftStart > shiftEnd, then the shift occurs up to shiftEnd, then
begins again at shiftStart.  This is useful for a "lollipop" course,
where you go out on a road, then do a loop, then return along the
original road.  So put shiftEnd at the end of the outward leg, then
shiftStart at the beginning of the return leg, and leave the loop part
unshifted.  Place the transitions slightly past where the directions
diverge, so the transition regaions do not cause the lanes to come
together at the beginning of the return leg (end of the outward leg).

The C<-laneShift> option still needs to be specified.

=item B<C<-shiftStart>> <meters>

The position on the course where lane shifting starts.  See C<-shiftEnd>
for details, except this marks the start of the lane shift zone.

The C<-laneShift> option still needs to be specified.

=item B<C<-shiftTransition>> <meters>

The distance to each side of lane shift transition points to taper the
lane shift.  Defaults are normally fine for this, so this option may
never need to be specified.  For C<-shiftStart> and C<-shiftEnd>,
which are applied to C<-laneShift>, the transition is calculated based
on the lane shift magnitude.  For C<-selectedLaneShift>C, the default
is 20 meters.

=item B<C<-shiftSF>> <meters>

For C<-loop> courses, the amount to shift the start/finish forwards
(positive) or backwards (negative).

The default is C<-shiftSF 0>. which retains the original GPX start.

This was needed with RGT courses to accomidate the 60 meter start
zone.  However, BikeTerra puts the S/F at the starting point for the
GPX track, so no shift is needed.

=item B<C<-shiftX>> <meters>

This is an alias for C<-xShift>.

=item B<C<-shiftY>> <meters>

This is an alias for C<-yShift>.

=item B<C<-shiftZ>> <meters>

This is an alias for C<-zShift>.

=item B<C<-shiftZEnd>> <meters>

This is an alias for C<-zShiftStart>.

=item B<C<-shiftZStart>> <meters>

This is an alias for C<-zShiftEnd>.

=item B<C<-sigma>> <meters>

Synonym for C<-smooth>

=item B<C<-sigmag>> <meters>

Synonym for C<-smoothG>

=item B<C<-sigmaz>> <meters>

Synonym for C<-smoothZ>

=item B<C<-simplify>>

Synonym for B<C<-simplifyPoints>>.

=item B<C<-simplifyAltitude>> <meters>

Synopnym for B<C<-simplifyZ>>

=item B<C<-simplifyD>> <meters>

The maximum deviation of a point from a straight line for simplification.
So simplifying a segment would result in a point deviating further
from this in x, y coordinates, then the point will be retained.

=item B<C<-simplifyDistance>> <meters>

Synopnym for B<C<-simplifyD>>

=item B<C<-simplifyPoints>>

This uses a Ramera-Douglas-Peucker algorithm to recursively simplify
the points.  It results in more aggressive point removal than just
-prune.  If point count is at a premium, this is a good option in
addition to pruning.

It is suitable for BikeTerra which does spline
interpolation of points, in contrast to RGT, which linearly
interpolated points and thus required more points to create smooth
corners.

=item B<C<-simplifyZ>> <meters>

The maximum deviation of a point's altitude from a uniform gradient
for simplification.  So simplifying a segment would result in a point at
least this amount higher or lower than for a course without the point
present, then the point will be retained.

=item B<C<-smooth>> <meters>

Provide a Gaussian sigma value for smoothing of position and altitude.
The result will sharp corners will be rounded to corners with
approximately this radius, and grade fluctuations over less distance
than this will be lost.  Typically altitude needs more smoothing than
position, so additional altitude smoothing is required.

Synonym for C<-smoothZ>

=item B<C<-smoothAngle>> <degrees>

For C<-autoSpacing>, determines how dense to place points such that
the maximum angle between points is no more than approximately this angle.

=item B<C<-smoothEnd>> <meters>

See C<-smoothStart>.  The default is to continue smoothing to the end of
the GPX data.

=item B<C<-smoothG>> <meters>

Additional smoothing to be applied to gradient, after smoothing
applied to position and/or altitude.  Gradient smoothing is very
similar to altitude smoothing it smooths the gradient, then calculates
altitude from the new gradient numbers, adjusting slightly to restore
net altitude change for the route.

There's a few differences from altitude smoothing.  One is that
altitude smoothing, on point-to-point courses, tends to flatten out
the beginning and end of the route, while gradient smoothing tends to
maintain the gradient at the beginning and end.  A second difference
is that gradient smoothing automatically reduces smoothing in corners
with the philosophy that on real roads the gradient in corners may
differ from the gradient on the straight road either before or after,
and preserving that detail is more realistic.  Altitude smoothing
smooths corners and straight sections the same.

The corner effect term can be adjusted with the C<-cornerEffect> option.

Altitude smoothing is better at preserving altitudes, while gradient
smoothing is more focused on gradients, although since the two are
related by a derivative, the difference is extremely subtle.

This is a more experimental algorithm than altitude smoothing,
due in part to the error correction at the end, but more for the
consideration of cornering radius.

=item B<C<-smoothStart>> <meters>

If specified, smoothing will be phased in starting at this position in
the course.  Note 0 has an effect, as it will phase in smoothing
starting at 0, as opposed to the default, which is to apply the same
smoothing to all points. This applies to all smoothing, so consider
running processGPX multiple times if you want different limits on
different smoothing components.  For example, you might want to
exclude position smoothing from critical corners, but maintain
altitude smoothing.  If the start is after the finish, then the region
between the two is not smoothed, rather than smoothed.

=item B<C<-smoothZ>> <meters>

Additional smoothing to be applied to altitude, on top of the
smoothing applied with C<-smooth>.  So this number, if specified, will
typically be greater than the C<-smooth> number or there is little
effect.  Grade changes which occur over less than this distace will
tend to be averaged out.  So for example, if I am designing an urban
course, and there is a turn onto a sharp climb, then less smoothing
can be tolerated.  On the other hand, if I am designing a course with
a steady grade up winding switchbacks on a steep hillside, then more
smoothing be needed.  On roads along steep hillsides, altitude
accuracy is more challenging than it is on roads which take the direct
route oup more gradual hillsides.

=item B<C<-snap>> <option>

With snapping, the code will search for sections of road which repeat,
either in the forward or reverse directions, and "snap" one pass to
the points of the other pass, guaranteeing that the two are perfectly
aligned.  So for example, if a route covers 1.5 laps of a course,
something not presently supported by the RGT multi-lap option (which
handles only complete laps), then snapping will make the final
half-lap the same as the first half-lap, up to within close to the end
of the route (since smoothing is affected by proximity to an end of
the route).  Similarly if a route has an out-and-back section, this
will help make sure there's no altitude or position differences
between the two.

B<option 1>: later passes are "snapped" to earlier passes.

B<option 2>: earlier passes are "snapped" to later passes.

Sometimes one or the other will work better in a particular case,
depending on whether an earlier or latter pass over a section of road
has better definition.

If there are existing segments, snapping will try to map segments from
the old points to the new points, but it's more precise to define
segments after snapping.  If you define segments within the same run
of processGPS, they will be done after possible snapping.

Snapping is done both before and after point interpolation.  The
reason is it's potentially very efficient with a smaller number
of points, but sometimes more widely spaced points make it more
challenging for the algorithm to determine that a section of road
is being repeated.  In the past, when snapping was done only once,
it was a regular practice to run processGPX twice in an effort
to more effectively snap points.

The snapping algorithm does not work at the very start or end of the
GPX.  So if your route ends on a repeated section and you want it to
be snapped, then it's a good practice to extend the route further,
then crop it back with C<-cropMin> and/or C<-cropMax>.

=item B<C<-snapAltitude>> <meters>

Normally for snapping to identify two sections of road as being a
repetition, they need to be within 1 meter altitude, to avoid
"snapping" on very tight switchbacks, for example, where roads may be
close on a map but at different elevations.  But in cases where map
data have elevation errors, this may prevent legitimate snapping.
This parameter allows for the altitude tolerance to be increased from
the default, relatively tight, 1 meter limit.  Note there's an
additional tolerance for the separation, using a 30% gradient, which
is not adjustable.

=item B<C<-snapDistance>> <meters>

The distance in meters a road segment can deviate from another and
still be "snapped" (see the C<-snap> option).  This example can be important:
if snapDistance is too small, instead of the repeated road being replaced
in one piece, it may be fragmented.  Look to the standard error for
text describing which segments have been snapped.  For example, the
following from a criterium course with an out-and-back section:

"snapping reverse segment: iRange = 25 35 <=> jRange = 54 47"

This is a nice clean replacement

=item B<C<-snapTransition>> <meters>

B<WARNING>: this may be buggy.  Check results carefully.

This is an I<experimental> feature whereby points within this distance
of a snap transition on partially syncronized in altitude, with a
transition weighting depending on distance along the course.  This is
designed to avoid having divergent roads having different slopes while
still overlapping, which can create "ridges" in the pavement which in
real life would cause riders to crash.  It's experimental, however,
and there is no guarantee it will help rather than hurt, because of
the way smoothing affects points near snap transitions, and snapping
is almost always combined with smoothing to avoid abrupt jumps in
position.

=item B<C<-snapZ>> <meters>

This is a synonym for C<-snapAltitude>

=item B<C<-spacing>> <meters>

As an early stage to processing, interpolate points on the route so
that the spacing between points is no more than approximately this
spacing.  If C<-smoothing> and/or C<-smoothingz> are specified, then
smoothing doesn't work over distances much smaller than this spacing.
-autospacing is another option, in which case the code will
selectively interpolate points near points where the direction is
changing.

=item B<C<-splineDegs>> <degrees>

If splines are desired, specifying this will cause spline
interpolation to be done for corners turning at least this much, but
less than the C<-splineMaxDegs> option.  A typical value is 5 degrees.
This angle is the angle between course points, not an angle of a total
turn: the algorithm only looks at points ahead of and behind a given
point.

=item B<C<-splineEnd>> <meters>

Where to end spline fitting, if any.  The default is to end any spline
fitting at the end of the course. This can "wrap around".

=item B<C<-splineMaxDegs>> <degrees>

If a C<-splineDegs> option is specified, specifying this limit the
maximum angle corner for which spline interpolation will be applied.
Splines are good for gradual, rounded corners but are not good for
sharp corners, so an upper bound in the 60 degree range (which is the
default) works generally well.  Splines have the advantage of rounding
corners without "blunting" them, but sometimes they create "S" shapes
where they are not wanted.  Make sure to check the results if using
spline interpolation: strange results can occur if the corner is too
sharp.

=item B<C<-splineStart>> <meters>

Where to start spline fitting, if any.  The default is to start any
spline fitting at the start of the course.  This can be after
C<-splineFitEnd> and the region will wrap-around.

=item B<C<-splitAt>> <meters> ...

Specify one or more locations in the final route, measured in meters
distance from the GPX start, at which the route should be split.

If you specify an output file and do not specify a specific split
number with the C<-splitNumber> option, then the output files will
have a suffix of "_split" followed by a split number (1, 2, 3 ...).

If you want the original route to be split into a number of equal
pieces, then see the C<-autoSplit> option instead.

=item B<C<-splitNumber>> <1, 2, 3..>

If there are multiple splits (C<-splitAt> or C<-autoSplits>), which
splits to output.  The default is to output all splits if a filename
is specified for the output (using a C<_split> with the split number
as a suffix) or just the first split if it's to standard output
("C<->").  The default can be specifed with a non-positive number, or
just omitting this option.

=item B<C<-startCircuitDistance>> <meters>

Sometimes races start with multiple circuits of a loop, before leaving
the circuit for a remainder of the course.  This option allows you to
repeat a beginning portion of the GPX file as a finishing circuit.
To do this, you specify the distance to the end of the circuit, then
an use the C<-startCircuits> option to specify how many copies of this
circuit should be prepended to the route at the beginning.

If the start/end of the circuit lap is not the same place as the desired
beginning of the route, then you'll need to specify a C<-cropMin> value to remove
some of the initial circuit

An alternative to this option is the newer C<-circuitFromPosition>
which if specified with a position of 0 will generate starting
circuits without having to identify the position where the circuits
end.  So for example C<-circuitToPosition 0 3> would generate three
starting circuits automatically.

=item B<C<-startCircuitEnd>> <meters>

Synonym for C<-startCircuitDistance>.

=item B<C<-startCircuits>> <count>

The number of copies of the starting circuit (from distance 0 to the
value in meters specified with the C<-startCircuitDistance> option) to be
added to the beginning of the data.  So a value 1 means adding one
copy, which implies two laps of the circuit, including the one defined
in the original file.

=item B<C<-startTime>> "<time string>"

Specify a start line for an activity using clear notation, for example:

processGPX C<-startTime> "15 Feb 2021 08:00"

would generate a time field beginning at that time, in the local time
zone.  This is useful for uploading a GPX route to "Relive", a website
which generates animations of routes, and requires a time field.  The
time is generated using a heureistic formula which has rider speed
depend on the road grade, calibrated for a strong rider.

=item B<C<-straight>> <meters> (1 or more)

Provide segments to be fit with straights, alternating start distance
from start of GPX, and finish distance from start of GPX.  This is an
alternative to providing values via C<-straightStart> and/or
C<-straightEnd>.  If both methods are used, these will be processed
first.  So for example, C<-straight 400 500 100 200> will fit
straights for points between 400 and 500 meters from the start, then
between 100 and 200 meters from the start.  Note the further points
are listed first so the fit of a straight to these points does not
affect the distance to the nearer points.  This is recommended.

A minimum number of points is needed to straighten a segment.  If
insufficient points are available, then nothing will be done.

=item B<C<-straightEnd>> <meters> (1 or more)

Set one or more distances for straight fitting.

See C<-straightStart>

=item B<C<-straightStart>> <meters> (1 or more)

Set one or more start distances for straight fitting.

Straight fitting is done by finding the endpoints of the straight segment
using the provided distances.  Only existing points will be used: no point
interpolation will be done. Then for points between these endpoints, a projection
operator is used to map the new point onto the segment connecting the two endpoints.
The original data should be close to straight so this projection operation does
not result in any retrograde motion.  This would result in 180 degree turns.
So if the points are nearly straight, and the end points are good, this can
help straighten out sections of road which should be perfectly straight.
The points are moved onto the projected position on the line segment, but
the elevations (or other parameters) are not changed.  So the assumption is that
moving onto the staight line is perpendicular to any altitude gradients.
This could result in a road with a constant gradient but following a curvy
path ending up with a non-constant gradient.  So check altitudes with care.
One possible approach is to use the C<-flatten> option to interpolate the altitudes,
after doing the straight-line fit.

If multiple values are listed, then multiple sections will be replaced.
Distances will be updated after each circular segment replacement.
So if you want to do multiple circular replacements, either list them
from further to closer relative to the start to avoid the distances
for later fits being affected by earlier fits.

=item B<C<-stripSegments>>

if specified, this results in existing segment definitions on input files (including
those specified with C<-join>) being stripped before processing.  This would typically
be used if C<-autoSegments> is specified.

=item B<C<-title>> <string>

Specify the name of the GPX route. The default is the name listed
in the source GPX.  This is synonymous with C<-name>.

=item B<C<-track>> <number>

Specify which track (1, 2, 3, ...) within the file to use.  The default
is 1.  If you specify 0 or a negative number, the default will be used.
Track number can also be specified by putting a suffix after the filename,
for example "file.gpx:2" for the second track in file.gpx.

=item B<C<-v>> or B<C<-version>>

Print the version number and exit.

=item B<C<-xShift>> <meters>

Shift longtidues to shift the course eastward by this distance

=item B<C<-yShift>> <meters>

Shift latitudes to shift the course northward by this distance

=item B<C<-zAutoSmooth>>

Synonym for C<-autoSmoothZ>

=item B<C<-zOffset>> <meters>

This is like C<-zShift>, but is applied I<before> scaling.

=item B<C<-zScale>> <factor>

Multiply altitudes in the original file I<after offset>. but I<before
shift>.  This is useful for fantasy routes where climbing should be
adjusted, or potentially for data from a poorly calibrated barometer
where I want to perfectly tune the net altitude change of a climb.

=item B<C<-zScaleRef>> <meters>

This is the reference altitude which will not be affected by C<-zScale>.
So if you have a course which starts at 100 meters and extends to 600 meters,
but it should go from 100 meters to 700 meters, you would specify
C<-zScaleRef 100 -zScale 1.2>.

=item B<C<-zShift>> <meters>

Add this to the altitudes in the original file.  This is useful for
"fantasy courses", or where altiude is recorded by an improperly
zeroed altimeter.  This is applied I<after scaling>.  So, for example,
C<-zScale 2 -zShift 100> will change an altitude 0 to an altitude
200, and an altitude 100 to an altitude 400.

=item B<C<-zShiftEnd>> <meters>

Distance on the route to end altitude shift.  There will be a transition
outside of this range.  This is also used for C<-zScale> and C<-zOffset>
(it affects all)..

=item B<C<-zShiftStart>> <meters>

Distance on the route to start altitude shift.  There will be a transition
outside of this range.  This is also used for C<-zScale> and C<-zOffset>
(it affects all)..

=item B<C<-zSmooth>>

Synonym for C<-smoothZ>

=item B<C<-zSigma>>

Synonym for C<-smoothZ>

=back


The code has been enhanced to handle "named segments" as was interpreted
by RGT.  Segments are defined in the GPX standard such that a "track"
consists of a series of "segments", and a "segment" consists of a
series of "trackpoints".  In RGT, segments are assumed to be
contiguous, such that a route is defined as the first segment,
connected to the second segment, connected to the third segment, etc.

RGT no longer exists, but this code is retained since there is a
chance another game will implement similar functionality.  If the
details differ, then this code will be updated to accomodate that.

Segments can be either named or unnamed.  Named segments are
intepreted by RGT to be timed separately, similar to Strava segments,
where times it takes riders to go from the beginning to end of the
segment are recorded.  This program interacts with segments in several
ways:

=over

1. if the input file has segments defined in the manner required by
RGT, then these segments will be retained, unless the C<-stripSegments>
option is used.  If there are gaps between segments, then these gaps
will be filled with additional segments, such that there is no
ambiguity about whether a gap belongs to the prior or following
segment.

2. Adjacent unnamed segments will be merged, so for example the
artificial segments assigned to gaps between segments will be assigned
to adjacent unnamed segment(s).

3. You can define your own segments using the C<-segments> option.  This
is followed by a comma-delimited list of a start position, a finish
position, and a name, followed optionally by more of these three
items.  So it can be followed by a number of comma-delimited elements
divisible by three.  For each triplet, a segment is formed between the
first coordinate and the second coordinate and assigned the name of
the third element (if non-blank).  For example, C<-segment>
1000,2000,"timed km" creates a segment from 1000 meters into the
route, up to 2000 meters into the route, and named the segment "timed
km".  These coordinates are of course affected by other operations
performed by this code so order of these operations is important.  The
segments are evaluated after most operations such as smoothing, but
before cropping, so the coordinates do not take into account potential
crops.

4. A more powerful way to create segments is to do so automatically.
This uses an algorithm which examines the route profile and identifies
what it considers to be "climbs".  The default is for no automatic
segments to be generated, so to request this, the C<-autoSegments> option
is used.  It's followed by two numbers.  The first is the threshold
for a climb: small bumps in the road are not assigned for timing.  The
number is vertical meters at a reference 10% grade.  The second number
is a power which describes how much weight is put on steepness for
defining a climb.  A typical range is 0.3 to 3.0, with 0.5 to 1.0
working fairly well in many cases.  A lower number will tend to create
longer segments rather than focusing on steep sections, and will tend
to combine sections which are separated by plateaus or brief descents.
A larger number will tent to split these segmented climbs into
individual climbs, so for example if a road is 10% for 1 km, then flat
for 500 meters, then 8% for the next km, that might be considered one
climb or two.  Additionally automatic segments need to be separated
from each other.  The amount of this separation is specified with the
-autoSegmentMargin option (default is 400).  There's also minimum
spacings to the start (-autoSegmentStartMargin) and finish
(-autoSegmentFinishMargin) lines. If climbs would be too close to each
other, the lower rated one is ignored, as are climbs which would be
too close to the start and/or finish.  So if you're designing a route
for a hillclimbing competition, unless the finish is sufficiently past
the start of the climb and the start is suffiently separate from the
start of the climb, there will not be a segment defined for the climb.

=back

=head1 EXAMPLES

=head2 C<-auto> option

The C<-auto> option attempts to use "reasonable" parameters which may not
be the best in each case, and which may require some fine-tuning, but should
work fairly well:

C<processGPX -auto GPXData.gpx>

This will create an output file "GPXData_processed.gpx" with various options
automatically chosen.

=head2 criterium course

The following example was from a criterium course:

C<processGPX -laneShift -7 -shiftStart 740 -shiftEnd 1390 -spacing 3 -autoSpacing -splineDegs 12 -minRadius 6 -prune -smooth 7 -snapDistance 2 -snap 1 -copyPoint -lap CherryPieCritRGT.gpx>

The course has an out-and-back section ending in a loop.  In the
actual race, the out-and-back is separated by cones. However, for RGT
cycling, riders use the full road width of 8 meters, so the out and
back portions needed to be separated.

Options:

=over

=item B<C<-laneshift -6>>

Riders remain to the left left on the out-and-back portion, so each
direction is shifted 4 meters to the left.  The negative number
implies left, a positive number implies right.

At one time a lane shift of 4 meters was adequate, but with changes to
"asset" placement, a larger lane shift is now needed.  This example
uses 7 meters to the left (UK, perhaps).

=item B<C<-shiftStart 740 -shiftEnd 1390>>

The lane shift is applied starting at 740 meters and ending at 1390
meters, with a transition calculated from the lane shift.  This is
applied after all smoothing, but before the lane shifting, and
importantly, before the route start shift.  Note there is a default
"C<-shiftSF -60>" applied at the end of the process, so if you want to
determine the distance to apply the lane shift, then make sure to
either do a run first with "C<-shiftSF 0 -laneShift 0>", or subtract 100
meters from the distance coordinates to judge what the distance would
have been at the time the lane shift is applied.

It's important to check to make sure at the edge of the lane shift
region the two directions don't get too close, due to the transition.
If they do, then extend the lane shift region somewhat to make room
for the transition.  Also check the lane shift hasn't caused any
corners to fold into points, or invert. If this happens, apply more
smoothing to round the corners more before applying the lane shift.
Unfortunately there is no support yet for position-dependent
smoothing, which would help.

=item B<C<-spacing 3>>

This is a short criterium course with a lot of tight corners, so the
initial spacing between points is set to 3 meters.  This works for the
1.6 km criterium, but would perhaps be too many points for a 75 km
point-to-point course, for example.  But for longer routes, sharp
corners are probably less of a factor.  Note this number should
probably be no greater than the C<-smooth> parameter, unless
C<-autospacing> is used, in which case corners will set with finer
spacing.

=item B<C<-autoSpacing>>

This option is almost always a good idea, setting the spacing in the
corners to provide adequare resolution.

=item B<C<-splineDegs 12>>

This option helps improve prevent corners from "collapsing" when they
don't have enough points to define the curve in the original GPX file.
Instead of being interpreted as polygons with straight segments, they
will be interpreted as smooth curves, if there are corners bending
more than this angle (12 degrees, in this example).  This is usually a
good idea if there are tight turns.

=item B<C<-minRadius 6>>

If a corner turns out sharper than 6 meters, RGT will try to increase the radius
of the turn by extending the road outward, with a smooth transition into
and out of the correction.

=item B<C<-prune>>

Remove useless points which don't affect either the shape of the
route, or the altitude profile.  This should probably be the default.

=item B<C<-smooth 7>>

Position is smoothed with a Gaussin with sigma = 7 meters.  This was done
here to tune the corner rounding, especially since there was a lane-shifted
corner, and lane-shifting reduces inside corner radii.

=item B<C<-snapDistance 2 -snap 1>>

Snap the return leg in the out-and-back to match the outgoing leg when
the two are within 2 meters. The "1" refers to replacing later
occurances of road with preceding cases: "2" would replace the earlier
occurance.  2 meters is presently the default snap distance.  With
Strava Route Editor data, 1 meter can result in a fragmented
replacement, and bad results.  When a road has curves, a larger
snapDistance than the default may be necessary.  Too large a value may
cause merging roads to suddenly "snap" together from too far a range,
however, or even adjacent roads or lanes to merge.  For reference, in
RGT Cycling, road width is 8 meters.

=item B<C<-copyPoint>>

Make sure the last point matches the first, so RGT Cycling recognizes
it as a circuit

=item B<C<-lap>>

It is a multi-lap race, so assure a smooth transition from the end of
a lap to the beginning of a next.  This is also necessary for
C<-copyPoint> to work.

=back

=head2 out-and-back course

This example uses the -outAndBack shortcut to create an out-and-back
course starting from a simple point-to-point GPX file:

C<processGPX -outAndBack outSection.gpx -out outAndBack.gpx>

=over

=item B<C<-outAndBack>>

This specifies that the route should loop around at the turn-around,
then return, with a default lane shift.

=back

=head2 out-and-back circuit

This example uses the -outAndBackLap shortcut to create an
out-and-back circuit with loops at both ends to create a circuit.

C<processGPX -outAndBackLap outSection.gpx -out outAndBackCircuit.gpx>

=over

=item B<C<-outAndBackLap>>

This specifies that the route should loop around at the turn-around,
then return, then loop again, with a default lane shift.

=back

=head2 road course w/ out-and-back

This is from a road course with an out-and-back section.  Note C<-RUTurn>
is not used here, since in this example, the loop at the end of the
out-and-back is part of the original route.

C<processGPX -crop 38730 -anchorSF -spacing 10 -autoSpacing -smoothAngle 20 -prune -smooth 10 -smoothZ 20 -snapDistance 5 -snap 1 -autoSegments 10 0.5 -minRadius 6 NoonRide.gpx>

=over

=item B<C<-crop 38730>>

The finish of this route is on the out-and-back section, so alignment
of the outward and inward legs is important.  Since smoothing at the
end of a GPX file is different than smoothing sufficiently far from
the end, and the desire was to have smoothing similarly affect the out
and back portions at the eventual finish, the GPX file was designed to
extend beyond the ultimate end of the file, then it was cropped back.
Cropping is done after smoothing, so this cropping distance was chosen
by first examining the result of all smoothing, then processGPX was
re-run on the original file with this crop distance added.

=item B<C<-anchorSF>>

Don't move the start point or the finish point of the course.
Smoothing is done as normal, but then at the end, these points are
returned to their original positions, and nearby points nudged to keep
a smooth transition.

=item B<C<-spacing 10>>

A point spacing of 10 meters is initially established.  This is more
than what was used in the criterium course example, since for a longer
course, smaller spacing results in more points.

=item B<C<-autospacing>>

Automatically put extra points near corners before smoothing.  This is
a good option to assure smooth corners.

=item B<C<-smoothAngle 10>>

Target the angle between segments at the apex of corners to be no more
than 20 degrees.  This seems to work fairly well.  You can compare to
10 degrees.  Most of the corner will end up with smaller angles than this,
as will corners which are less than 90 degrees.

=item B<C<-prune>>

Eliminate unnecessary points at the end.  This should probably always
be used.

=item B<C<-smooth 10>>

Use 10 meter smoothing on position and, initially, on altitude.  This
results in some rounding of corners.  For this course the result was
compared with the "GPX Visualizer" website to satellite data, to make
sure corners were fairly well aligned with actual corners, but
additionally that there were no anomalies such as "zig-zags" which did
not exist in the real road.  More than 10 meters and some detail from
the actual road may be lost, such as switchbacks with imperfect
variable radius.

=item B<C<-smoothZ 20>>

Additionally smooth altitude with a 20 meter smoothing distance.  On this
course, there were still gradient spikes with 10 meter smoothing, while more
than 20 meter smoothing would have lost some of the actual variations in
steepness.

=item B<C<-snapDistance 5 -snap 1>>

The course is a "lollypop", meaning it heads out, does a big loop,
then returns (part way).  To make sure the return is well-aligned
with the out, snapping is used.  "C<-snap 1>" means align the return
to the out (rather than the reverse).  "C<-snapDistance 5>" means to snap
points which are as much as 5 meters apart.  5 meters is a lot, and the
result needs to be checked afterwards to make sure this doesn't result
in transitions are too abrupt, but a large snapdistance can help make sure
corners get snapped together.

=item B<C<-autoSegments 10 0.5>>

This specifies that segments should be generated for hills found in
the route.  The first number is the approximate altitude gained in
meters needed for a hill to be marked as a segment. THe second is how
strongly average gradient should be used in segment placement: a
higher number places a higher value on segments having a higher
average gradient.

=item B<C<-minRadius 6>>

If a corner turns out sharper than 6 meters, RGT will try to increase
the radius of the turn by extending the road outward, with a smooth
transition into and out of the correction.

=item B<NoonRide.gpx>

This is the name of the original file.  The processed file will be
F<NoonRide_processed.gpx>.  If the result is good, it's best to rename
this to something different, so if you rerun the C<smoothGPX>, it
doesn't get over-written.

=back

=head2 simplifying

This example applies the automatic settings but then "simplifies" the points.

C<processGPX -auto -simplify original.gpx -out processed.gpx>

=over

=item B<C<-auto>>

Apply the automatic set of options for general smoothing.

=item B<C<-simplify>>

Apply an algorithm reducing the number of points based on a match to interpolated positions
and altitudes.  This is generally more aggressive than C<-prune>,

=item B<C<original.gpx>>

This is the name of the original GPX file

=item B<C<-out processed.gpx>>

This specifies the name of the file to which the result is written

=back

=head2 Multi-step processing: selective smoothing

Here is an example where an urban route with reasonably sharp corners,
except it followed an oval path around a park.  The oval path came out
of Strava Route Editor slightly ragged, so I wanted enough smoothing
there to make it smooth, but the rest of the route, I wanted less
smoothing.

One approach here is to use the -selectiveSmooth option.  For example:

C<processGPX -copyPoint -lap -spacing 3 -zsmooth 10 -selectiveSmooth 15 270 5 1540 15 original.gpx -minRadius 6 -out processed.gpx>

=over

=item B<C<-selectiveSmooth 15 270 5 1540 15>>

This says to smooth with a smoothing length up to 270 meter distance,
then 5 meters from there up to 1540 meter distance, and from there 15
meters again to the end of the lap.

=back

But an alternate approach is to run the code twice, smoothing in two
steps.

For this I used -smoothStart and -smoothEnd, to isolate
the oval, but then to get smoothing on the rest of the loop as well, I
needed to run the code twice:

C<processGPX -shiftSF 0 -lap -spacing 3 -zsmooth 10 -smooth 5 original.gpx -out - | processGPX - -copyPoint -lap -smooth 15 -prune -smoothStart 1540 -smoothEnd 270 -minRadius 6 -out processed.gpx>

This uses a shell "pipe", which is a way to run the program twice on
the same data without saving to an intermediate file. although the
intermediate file would be useful for debugging.

=over

=item B<C<-shiftSF 0>>

The first call to processGPX specifies no S/F line shift (that will be done the
second call, and I want to maintain the position of the start of the GPX for
the first call).

=item B<C<-lap>>

It is a lap course.

=item B<C<-spacing 3>>

A fine spacing is used here, as the loop is only 1600 meters, and I'll rely on
pruning to reduce the number of points later.

=item B<C<-zsmooth 10>>

This is moderate altitude smoothing.  It's an urban course, but the climbs
have fairly smooth transitions, and observing the gradient profile, there
were some anomalies with using 5 meter smoothing.  Strava Route Editor
tends to produce abrupt gradient changes.

=item B<C<-smooth 5>>

This is a fairly small amount of smoothing, for urban corners with some
rounding, or where the actual road is wider than the Magic Roads 8 meter
road width, and wider lines are available.

=item B<original.gpx>

This is the name of the original GPX file

=item B<C<-out ->>

This tells the code to write the resulting GPX to "the standard
output".

=item B<C<| processGPX ->>

This tells the command line shell to "send the standard output to the
standard input of the next program", which is a sepearate call to
processGPX.  It's called a "pipe".  The "C<->" tells the code that this
call takes its input from the pipe.  So think of it as a virtual file, a
direct line of communication from one call of the code to the next.

=item B<C<-copyPoint -lap>>

Tell this call to the code that it's a lap, and I want to copy the
first point to the last point to close the loop.

=item B<C<-smooth 15 -smoothStart 1540 -smoothEnd 270>>

Apply 15 meter smoothing this time, except start it at 1540 meters
into the course, and end it as 270 meters into the course.  The
smoothing domain wraps around, because it starts after it finishes.
So the end of the loop, and the beginning of the loop, will be
additionally smoothed, while the rest will be kept unaltered, with a
transitional range applied to avoid abrupt changes.

=item B<C<-minRadius 6>>

This sets the minimum radius of corners to 6 meters.  This is done in the second step
here to include effects from processing in both steps.

=item B<C<-out processed.gpx>>

=back

=head2 segment generation

C<processGPX -stripSegments -autoSegments 100 0.5 -segments 1500,2000,"bonus segment" input.gpx -out output.gpx>

=over

=item B<C<-stripSegments>>

If the input file has segments already defined, this will ignore those.

=item B<C<-autoSegments 20 0.5>>

This tells the code that automatic segments should be generated for
climbs gaining at least 20 meters if they average 10%
gradient. Shallower climbs need to gain more, steeper climbs don't
need to gain as much.  The power assigned to gradient is 0.5, so for
example if the gradient is 5% instead of 10%, then since the square
root of 5/10 = 0.71, this climb would need to gain at least 28.2
meters instead of 20 meters to be considered as a timed segment.

=item B<C<-segments 1500,2000,"bonus segment">>

This adds an additional segment to the route.  between 1500 and 2000
meters from the start of the route.  This is defined before any
automatic segments are generated, so care should be taken that this
segment is not overlapping anything which will be considered to be a
climb.

=back

C<processGPX -stripSegments -autoSegmentMargin 1000-autoSegmentStretch 1 -autoSegments 5 1 input.gpx -out output.gpx>

This example uses a gradient power of 1, placing a large emphasis on
local gradient, but then increases the auto-segment stretch factor
from its default to 1.  This might be useful if I had a long climb
with intermediate descents along the way, and I wanted separate climb
segments for each climbing portion rather than the net climb, but I
wanted the endpoints of these segments to be on flat road if that was
at all possible within the constraints of he margin, which is set to
400 meters.

=over

=item B<C<-autoSegmentMargin 1000>>

The minimum spacing between auto-segments is set to 1000 meters.  The
minimum spacing to the start line would be set with
-autoSegmentStartMargin, and for the finish, -autoSegmentFinishMargin.

=item B<C<-autoSegmentStretch 1>>

Be willing to increase auto-segment lengths up to their original length
in order to either reach a flat portion for the start or a flat portion
for the finish,

=item B<C<-autoSegments 5 1>>

The climb threshold is set to a relatively low value of 5
meters, meaning I want to pick up even small steps in the larger
climb, and the gradient factor is set to 1, putting an emphasis on
isolating individual climbing portions.

=back

=head2 adding time to an activity

Suppose I wanted to add a time field to the result of the preceding
example, because I want to upload the GPX to "Relive.cc" so I can
generate an animation of the route to include in an event description
of a race I'm organizing on the course.

C<processGPX -startTime "Feb 25 2021 07:00" NoonRide_processed.gpx>

Here I am telling the code to use its bike speed model to predict how
long it will take a relatively fast rider to reach each point of the
route, and to add a time (and "duration") field to the GPX file, which
will be accepted by the RideWithGPX website.  The resulting file will
be F<NoonRide_processed_processed.gpx>.

=over

=item B<C<-startTime "Feb 25 2021 07:00">>

This specifies that the time points begin on the listed data and time
in the local time zone (local to the user, not the course).  The
format of the data and time are flexible, but try to be unambiguous.
For example, rather than put "01/02/03" for a date, try "02 Jan 2003".

=back

=head2 adding gradient signs

This is an I<experimental> feature since RGT, the game which is the
primary target of this code, does not at present include waypoint
support.

The following shows a partial command line, so added to other
elements of a command line:

C<-addGradientSigns -gradientThreshold 20 -gradientPower 2>

=over

=item B<C<-addGradientSigns>>

Tells the code to add waypoints where gradient signs should be placed.

=item B<C<-gradientThreshold 20>>

A 10% grade would need to gain or lose 20 meters to get a sign.  The
altitude required for other gradients depends on the next option.

=item B<C<-gradientPower 2>>

This is the default value, but is listed here for documentation
purposes.  It says the suitability of a climb for a gradient sign is
proportional to gradient squared.  So for example, if a 10% climb gets
one if it climbs 20 meters, than a 5% grade would need to gain 40
meters.  This also affects the placement of signs, since if a climb is
gradual, then steeper, then gradual again, should a single sign be
used to cover the entire climb, or should signs be prioritized to the
steep portion, then possibly add addiitonal signs to the gradual
portions if they meet the threshold?  The higher gradient power, the
greater the priority placed on steepness.  The default of "2" seems to
work well.

=back

=head2 specifying metadata

GPX files have "metadata" which is various tags. You can change values of
metadata with various options. This is an example:

C<processGPX -author "Dan Connelly" -keywords "race, BikeTerra" -copyright "Dan Connelly" -name "Crit Course" crit.gpx -out critBT.gpx -description "the best crit course">

This example specifies an author name, adds keywords, a copyright, a
title, and a description, taking the trackpoints from the file
"crit.gpx", and writing the result to "critBT.gpx".  The time
the file was generated is automatically stored in the "time" metadata
field.  A "processGPX" keywords is additionally automatically added,
to record this program was used,

=head1 BUGS

=over

=item B<lane shifting and sharp corners>

If you apply more lane shift than the radius of the tightest corner,
the corner could end up with a non-positive radius, which is not what
you want.

=item B<snapping isn't perfect.>

The snapping algorithm makes certain assumptions to reduce computation
time and can be conflused for sufficiently complicated routes.  More
testing is needed.

=item B<C<-snapTransition> is suspect.>

=item B<snapping and segments>

If segments are defined before snapping, the code will try to assign
the appropriate segment to each snapped point, but this is imperfect.
It is better to define segments after snapping points.

=back

=head1 AUTHORS

Daniel Connelly <F<djconnel@gmail.com>>

=head1 LICENSE

This application is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
# eof
